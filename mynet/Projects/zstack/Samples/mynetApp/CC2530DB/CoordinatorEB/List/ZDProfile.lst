###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:04 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDProfile.c                           #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDProfile.c -D ZTOOL_P1 -D MT_TASK    #
#                          -D MT_SYS_FUNC -D MT_ZDO_FUNC -D                   #
#                          LCD_SUPPORTED=DEBUG -lC C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\CoordinatorEB\List\ -lA                    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ --diag_suppress Pe001,Pa010 -o                 #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ZDProfile.lst                                   #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ZDProfile.r51                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\stack\zdo\ZDProfile.c
      1          /**************************************************************************************************
      2            Filename:       ZDProfile.c
      3            Revised:        $Date: 2010-01-17 08:58:03 -0800 (Sun, 17 Jan 2010) $
      4            Revision:       $Revision: 21533 $
      5          
      6            Description:    This is the Zigbee Device Profile.
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "NLMEDE.h"
     47          #include "nwk_util.h"
     48          #include "APS.h"
     49          
     50          #include "AddrMgr.h"
     51          #include "ZDConfig.h"
     52          #include "ZDProfile.h"
     53          #include "ZDObject.h"
     54          #include "ZDNwkMgr.h"
     55          
     56          #if defined( LCD_SUPPORTED )
     57            #include "OnBoard.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  typedef void (*halUARTCBack_t) (uint8 port, uint8 event);
                                                          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",119  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    halUARTCBack_t      callBackFunc;
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",141  Error[Pe020]: 
          identifier "halUARTCBack_t" is undefined
     58          #endif
     59          
     60          #include "nwk_util.h"
     61          
     62          #if defined( MT_ZDO_FUNC )
     63            #include "MT_ZDO.h"
     64          #endif
     65          
     66          /*********************************************************************
     67           * MACROS
     68           */
     69          
     70          #define ZADDR_TO_AFADDR( pZADDR, AFADDR ) {                            \
     71            (AFADDR).endPoint = ZDP_AF_ENDPOINT;                                 \
     72            (AFADDR).addrMode = (afAddrMode_t)(pZADDR)->addrMode;                \
     73            (AFADDR).addr.shortAddr = (pZADDR)->addr.shortAddr;                  \
     74          }
     75          
     76          #define FillAndSendBuffer( TRANSSEQ, ADDR, ID, LEN, BUF ) {     \
     77            afStatus_t stat;                                    \
     78            ZDP_TmpBuf = (BUF)+1;                               \
     79            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     80            osal_mem_free( (BUF) );                             \
     81            ZDP_TmpBuf = ZDP_Buf+1;                             \
     82            return stat;                                        \
     83          }
     84          
     85          #define FillAndSendTxOptions( TRANSSEQ, ADDR, ID, LEN, TxO ) {  \
     86            afStatus_t stat;                                    \
     87            ZDP_TxOptions = (TxO);                              \
     88            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     89            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
     90            return stat;                                        \
     91          }
     92          
     93          #define FillAndSendBufferTxOptions( TRANSSEQ, ADDR, ID, LEN, BUF, TxO ) { \
     94            afStatus_t stat;                                    \
     95            ZDP_TmpBuf = (BUF)+1;                               \
     96            ZDP_TxOptions = (TxO);                              \
     97            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     98            osal_mem_free( (BUF) );                             \
     99            ZDP_TmpBuf = ZDP_Buf+1;                             \
    100            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
    101            return stat;                                        \
    102          }
    103          
    104          /*********************************************************************
    105           * CONSTANTS
    106           */
    107          
    108          #define ZDP_BUF_SZ          80
    109          
    110          CONST byte ZDP_AF_ENDPOINT = 0;
    111          
    112          /*********************************************************************
    113           * TYPEDEFS
    114           */
    115          typedef struct
    116          {
    117            void *next;
    118            uint8 taskID;
    119            uint16 clusterID;
    120          } ZDO_MsgCB_t;
    121          
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          byte ZDP_TransID = 0;
    128          
    129          /*********************************************************************
    130           * EXTERNAL VARIABLES
    131           */
    132          
    133          extern endPointDesc_t ZDApp_epDesc;
    134          
    135          /*********************************************************************
    136           * EXTERNAL FUNCTIONS
    137           */
    138          
    139          /*********************************************************************
    140           * LOCAL FUNCTIONS
    141           */
    142          
    143          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len );
    144          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg );
    145          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg );
    146          
    147          /*********************************************************************
    148           * LOCAL VARIABLES
    149           */
    150          
    151          static uint8  ZDP_Buf[ ZDP_BUF_SZ ];
    152          static uint8 *ZDP_TmpBuf = ZDP_Buf+1;
    153          static byte ZDP_TxOptions = AF_TX_OPTIONS_NONE;
    154          
    155          ZDO_MsgCB_t *zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
    156          
    157          /*********************************************************************
    158           * ZDO Message Processing table
    159           */
    160          
    161          typedef void (*pfnZDPMsgProcessor)( zdoIncomingMsg_t *inMsg );
    162          
    163          typedef struct
    164          {
    165            uint16                clusterID;
    166            pfnZDPMsgProcessor    pFn;
    167          } zdpMsgProcItem_t;
    168          
    169          CONST zdpMsgProcItem_t zdpMsgProcs[] =
    170          {
    171          #if ( RFD_RCVC_ALWAYS_ON==TRUE ) || ( ZG_BUILD_RTR_TYPE )
    172            // These aren't processed by sleeping end devices.
    173            { NWK_addr_req,           zdpProcessAddrReq },
    174            { Device_annce,           ZDO_ProcessDeviceAnnce },
    175          #endif
    176            { IEEE_addr_req,          zdpProcessAddrReq },
    177            { Node_Desc_req,          ZDO_ProcessNodeDescReq },
    178            { Power_Desc_req,         ZDO_ProcessPowerDescReq },
    179            { Simple_Desc_req,        ZDO_ProcessSimpleDescReq },
    180            { Active_EP_req,          ZDO_ProcessActiveEPReq },
    181            { Match_Desc_req,         ZDO_ProcessMatchDescReq },
    182          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
    183            { Mgmt_NWK_Disc_req,      ZDO_ProcessMgmtNwkDiscReq },
    184          #endif
    185          #if defined ( ZDO_MGMT_LQI_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    186            { Mgmt_Lqi_req,           ZDO_ProcessMgmtLqiReq },
    187          #endif
    188          #if defined ( ZDO_MGMT_RTG_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    189            { Mgmt_Rtg_req,           ZDO_ProcessMgmtRtgReq },
    190          #endif
    191          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && defined ( REFLECTOR )
    192            { Mgmt_Bind_req,          ZDO_ProcessMgmtBindReq },
    193          #endif
    194          #if defined ( ZDO_MGMT_JOINDIRECT_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    195            { Mgmt_Direct_Join_req,   ZDO_ProcessMgmtDirectJoinReq },
    196          #endif
    197          #if defined ( ZDO_MGMT_LEAVE_RESPONSE )
    198            { Mgmt_Leave_req,         ZDO_ProcessMgmtLeaveReq },
    199          #endif
    200          #if defined ( ZDO_MGMT_PERMIT_JOIN_RESPONSE )  && ( ZG_BUILD_RTR_TYPE )
    201            { Mgmt_Permit_Join_req,   ZDO_ProcessMgmtPermitJoinReq },
    202          #endif
    203          #if defined ( ZDO_USERDESC_RESPONSE )
    204            { User_Desc_req,          ZDO_ProcessUserDescReq },
    205          #endif
    206          #if defined ( ZDO_USERDESCSET_RESPONSE )
    207            { User_Desc_set,          ZDO_ProcessUserDescSet },
    208          #endif
    209          #if defined ( ZDO_SERVERDISC_RESPONSE )
    210            { Server_Discovery_req,   ZDO_ProcessServerDiscReq },
    211          #endif
    212            {0xFFFF, NULL} // Last
    213          };
    214          
    215          /*********************************************************************
    216           * @fn          fillAndSend
    217           *
    218           * @brief       Combined to reduce space
    219           *
    220           * @param
    221           * @param
    222           *
    223           * @return      afStatus_t
    224           */
    225          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len )
    226          {
    227            afAddrType_t afAddr;
    228          
    229            osal_memset( &afAddr, 0, sizeof(afAddrType_t) );
    230            ZADDR_TO_AFADDR( addr, afAddr );
    231          
    232            *(ZDP_TmpBuf-1) = *transSeq;
    233          
    234            return AF_DataRequest( &afAddr, &ZDApp_epDesc, clusterID,
    235                                     (uint16)(len+1), (uint8*)(ZDP_TmpBuf-1),
    236                                     transSeq, ZDP_TxOptions,  AF_DEFAULT_RADIUS );
    237          
    238          }
    239          
    240          /*********************************************************************
    241           * @fn          ZDP_SendData
    242           *
    243           * @brief       This builds and send a request message that has
    244           *              NWKAddrOfInterest as its only parameter.
    245           *
    246           * @param       dstAddr - destination address
    247           * @param       cmd - clusterID
    248           * @param       dataLen - number of bytes of data
    249           * @param       data - pointer to the data
    250           * @param       SecurityEnable - Security Options
    251           *
    252           * @return      afStatus_t
    253           */
    254          afStatus_t ZDP_SendData( uint8 *TransSeq, zAddrType_t *dstAddr, uint16 cmd,
    255                                  byte len, uint8 *buf, byte SecurityEnable )
    256          {
    257            uint8 *pBuf = ZDP_TmpBuf;
    258            byte cnt = len;
    259          
    260            while ( cnt-- )
    261            {
    262              *pBuf++ = *buf++;
    263            }
    264          
    265            FillAndSendTxOptions( TransSeq, dstAddr, cmd, len,
    266                         (AF_DEFAULT_RADIUS | ((SecurityEnable) ? AF_EN_SECURITY : 0)) );
    267          }
    268          
    269          /*********************************************************************
    270           * @fn          ZDP_NWKAddrOfInterestReq
    271           *
    272           * @brief       This builds and send a request message that has
    273           *              NWKAddrOfInterest as its only parameter.
    274           *
    275           * @param       dstAddr - destination address
    276           * @param       nwkAddr - 16 bit address
    277           * @param       SecurityEnable - Security Options
    278           *
    279           * @return      afStatus_t
    280           */
    281          afStatus_t ZDP_NWKAddrOfInterestReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    282                                               byte cmd, byte SecurityEnable )
    283          {
    284            (void)SecurityEnable;  // Intentionally unreferenced parameter
    285          
    286            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
    287            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
    288          
    289            return fillAndSend( &ZDP_TransID, dstAddr, cmd, 2 );
    290          }
    291          
    292          /*********************************************************************
    293           * Address Requests
    294           */
    295          
    296          /*********************************************************************
    297           * @fn          ZDP_NwkAddrReq
    298           *
    299           * @brief       This builds and send a NWK_addr_req message.  This
    300           *              function sends a broadcast message looking for a 16
    301           *              bit address with a 64 bit address as bait.
    302           *
    303           * @param       IEEEAddress - looking for this device
    304           * @param       SecurityEnable - Security Options
    305           *
    306           * @return      afStatus_t
    307           */
    308          afStatus_t ZDP_NwkAddrReq( uint8 *IEEEAddress, byte ReqType,
    309                                     byte StartIndex, byte SecurityEnable )
    310          {
    311            uint8 *pBuf = ZDP_TmpBuf;
    312            byte len = Z_EXTADDR_LEN + 1 + 1;  // IEEEAddress + ReqType + StartIndex.
    313            zAddrType_t dstAddr;
    314          
    315            (void)SecurityEnable;  // Intentionally unreferenced parameter
    316          
    317            if ( osal_ExtAddrEqual( saveExtAddr, IEEEAddress ) == FALSE )
    318            {
    319              dstAddr.addrMode = AddrBroadcast;
    320              dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    321            }
    322            else
    323            {
    324              dstAddr.addrMode = Addr16Bit;
    325              dstAddr.addr.shortAddr = ZDAppNwkAddr.addr.shortAddr;
    326            }
    327          
    328            pBuf = osal_cpyExtAddr( pBuf, IEEEAddress );
    329          
    330            *pBuf++ = ReqType;
    331            *pBuf++ = StartIndex;
    332          
    333            return fillAndSend( &ZDP_TransID, &dstAddr, NWK_addr_req, len );
    334          }
    335          
    336          /*********************************************************************
    337           * @fn          ZDP_IEEEAddrReq
    338           *
    339           * @brief       This builds and send a IEEE_addr_req message.  This
    340           *              function sends a unicast message looking for a 64
    341           *              bit IEEE address with a 16 bit address as bait.
    342           *
    343           * @param       ReqType - ZDP_IEEEADDR_REQTYPE_SINGLE or
    344           *                        ZDP_IEEEADDR_REQTYPE_EXTENDED
    345           * @param       SecurityEnable - Security Options
    346           *
    347           * @return      afStatus_t
    348           */
    349          afStatus_t ZDP_IEEEAddrReq( uint16 shortAddr, byte ReqType,
    350                                      byte StartIndex, byte SecurityEnable )
    351          {
    352            uint8 *pBuf = ZDP_TmpBuf;
    353            byte len = 2 + 1 + 1;  // shortAddr + ReqType + StartIndex.
    354            zAddrType_t dstAddr;
    355          
    356            (void)SecurityEnable;  // Intentionally unreferenced parameter
    357          
    358            dstAddr.addrMode = (afAddrMode_t)Addr16Bit;
    359            dstAddr.addr.shortAddr = shortAddr;
    360          
    361            *pBuf++ = LO_UINT16( shortAddr );
    362            *pBuf++ = HI_UINT16( shortAddr );
    363          
    364            *pBuf++ = ReqType;
    365            *pBuf++ = StartIndex;
    366          
    367            return fillAndSend( &ZDP_TransID, &dstAddr, IEEE_addr_req, len );
    368          }
    369          
    370          /*********************************************************************
    371           * @fn          ZDP_MatchDescReq
    372           *
    373           * @brief       This builds and send a Match_Desc_req message.  This
    374           *              function sends a broadcast or unicast message
    375           *              requesting the list of endpoint/interfaces that
    376           *              match profile ID and cluster IDs.
    377           *
    378           * @param       dstAddr - destination address
    379           * @param       nwkAddr - network address of interest
    380           * @param       ProfileID - Profile ID
    381           * @param       NumInClusters - number of input clusters
    382           * @param       InClusterList - input cluster ID list
    383           * @param       NumOutClusters - number of output clusters
    384           * @param       OutClusterList - output cluster ID list
    385           * @param       SecurityEnable - Security Options
    386           *
    387           * @return      afStatus_t
    388           */
    389          afStatus_t ZDP_MatchDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    390                                          uint16 ProfileID,
    391                                          byte NumInClusters, cId_t *InClusterList,
    392                                          byte NumOutClusters, cId_t *OutClusterList,
    393                                          byte SecurityEnable )
    394          {
    395            uint8 *pBuf = ZDP_TmpBuf;
    396            // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
    397            byte i, len = 2 + 2 + 1 + 1;  // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
    398          
    399            (void)SecurityEnable;  // Intentionally unreferenced parameter
    400          
    401            len += (NumInClusters + NumOutClusters) * sizeof(uint16);
    402          
    403            if ( len >= ZDP_BUF_SZ-1 )
    404            {
    405              return afStatus_MEM_FAIL;
    406            }
    407          
    408            // The spec changed in Zigbee 2007 (2.4.3.1.7.1) to not allow sending
    409            // this command to 0xFFFF.  So, here we will filter this and replace 
    410            // with 0xFFFD to only send to devices with RX ON.  This includes the 
    411            // network address of interest.
    412            if ( ((dstAddr->addrMode == AddrBroadcast) || (dstAddr->addrMode == Addr16Bit))
    413                && (dstAddr->addr.shortAddr == NWK_BROADCAST_SHORTADDR_DEVALL) )
    414            {
    415              dstAddr->addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    416            }
    417            if ( nwkAddr == NWK_BROADCAST_SHORTADDR_DEVALL )
    418            {
    419              nwkAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    420            }
    421            
    422            *pBuf++ = LO_UINT16( nwkAddr );   // NWKAddrOfInterest
    423            *pBuf++ = HI_UINT16( nwkAddr );
    424          
    425            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
    426            *pBuf++ = HI_UINT16( ProfileID );
    427          
    428            *pBuf++ = NumInClusters; // Input cluster list
    429            if ( NumInClusters )
    430            {
    431              for (i=0; i<NumInClusters; ++i)  {
    432                *pBuf++ = LO_UINT16( InClusterList[i] );
    433                *pBuf++ = HI_UINT16( InClusterList[i] );
    434              }
    435            }
    436          
    437            *pBuf++ = NumOutClusters; // Output cluster list
    438            if ( NumOutClusters )
    439            {
    440              for (i=0; i<NumOutClusters; ++i)  {
    441                *pBuf++ = LO_UINT16( OutClusterList[i] );
    442                *pBuf++ = HI_UINT16( OutClusterList[i] );
    443              }
    444            }
    445          
    446            return fillAndSend( &ZDP_TransID, dstAddr, Match_Desc_req, len );
    447          }
    448          
    449          /*********************************************************************
    450           * @fn          ZDP_SimpleDescReq
    451           *
    452           * @brief       This builds and send a NWK_Simple_Desc_req
    453           *              message.  This function sends unicast message to the
    454           *              destination device.
    455           *
    456           * @param       dstAddr - destination address
    457           * @param       nwkAddr - 16 bit address
    458           * @param       epIntf - endpoint/interface
    459           * @param       SecurityEnable - Security Options
    460           *
    461           * @return      afStatus_t
    462           */
    463          afStatus_t ZDP_SimpleDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
    464                                              byte endPoint, byte SecurityEnable )
    465          
    466          {
    467            (void)SecurityEnable;  // Intentionally unreferenced parameter
    468          
    469            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
    470            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
    471            ZDP_TmpBuf[2] = endPoint;
    472          
    473            return fillAndSend( &ZDP_TransID, dstAddr, Simple_Desc_req, 3 );
    474          }
    475          
    476          /*********************************************************************
    477           * @fn          ZDP_UserDescSet
    478           *
    479           * @brief       This builds and send a User_Desc_set message to set
    480           *              the user descriptor.  This function sends unicast
    481           *              message to the destination device.
    482           *
    483           * @param       dstAddr - destination address
    484           * @param       nwkAddr - 16 bit address
    485           * @param       UserDescriptor - user descriptor
    486           * @param       SecurityEnable - Security Options
    487           *
    488           * @return      afStatus_t
    489           */
    490          afStatus_t ZDP_UserDescSet( zAddrType_t *dstAddr, uint16 nwkAddr,
    491                                    UserDescriptorFormat_t *UserDescriptor,
    492                                    byte SecurityEnable )
    493          {
    494            uint8 *pBuf = ZDP_TmpBuf;
    495            byte len = (UserDescriptor->len < AF_MAX_USER_DESCRIPTOR_LEN) ?
    496                        UserDescriptor->len : AF_MAX_USER_DESCRIPTOR_LEN;
    497            byte addrLen = 2;
    498          
    499            (void)SecurityEnable;  // Intentionally unreferenced parameter
    500          
    501            *pBuf++ = LO_UINT16( nwkAddr );
    502            *pBuf++ = HI_UINT16( nwkAddr );
    503          
    504            *pBuf++ = len;
    505            addrLen = 3;
    506          
    507            pBuf = osal_memcpy( pBuf, UserDescriptor->desc, len );
    508            osal_memset( pBuf, AF_USER_DESCRIPTOR_FILL, AF_MAX_USER_DESCRIPTOR_LEN-len );
    509          
    510            return fillAndSend( &ZDP_TransID, dstAddr, User_Desc_set, (AF_MAX_USER_DESCRIPTOR_LEN + addrLen) );
    511          }
    512          
    513          /*********************************************************************
    514           * @fn          ZDP_ServerDiscReq
    515           *
    516           * @brief       Build and send a Server_Discovery_req request message.
    517           *
    518           * @param       serverMask - 16-bit bit-mask of server services being sought.
    519           * @param       SecurityEnable - Security Options
    520           *
    521           * @return      afStatus_t
    522           */
    523          afStatus_t ZDP_ServerDiscReq( uint16 serverMask, byte SecurityEnable )
    524          {
    525            uint8 *pBuf = ZDP_TmpBuf;
    526            zAddrType_t dstAddr;
    527          
    528            dstAddr.addrMode = AddrBroadcast;
    529            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    530          
    531            *pBuf++ = LO_UINT16( serverMask );
    532            *pBuf = HI_UINT16( serverMask );
    533          
    534            FillAndSendTxOptions( &ZDP_TransID, &dstAddr, Server_Discovery_req, 2,
    535                       ((SecurityEnable) ? AF_EN_SECURITY : AF_TX_OPTIONS_NONE) );
    536          }
    537          
    538          /*********************************************************************
    539           * @fn          ZDP_DeviceAnnce
    540           *
    541           * @brief       This builds and send a Device_Annce message.  This
    542           *              function sends a broadcast message.
    543           *
    544           * @param       nwkAddr - 16 bit address of the device
    545           * @param       IEEEAddr - 64 bit address of the device
    546           * @param       capabilities - device capabilities.  This field is only
    547           *                 sent for v1.1 networks.
    548           * @param       SecurityEnable - Security Options
    549           *
    550           * @return      afStatus_t
    551           */
    552          afStatus_t ZDP_DeviceAnnce( uint16 nwkAddr, uint8 *IEEEAddr,
    553                                        byte capabilities, byte SecurityEnable )
    554          {
    555            zAddrType_t dstAddr;
    556            uint8 len;
    557          
    558            (void)SecurityEnable;  // Intentionally unreferenced parameter
    559          
    560            dstAddr.addrMode = (afAddrMode_t)AddrBroadcast;
    561            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    562          
    563            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
    564            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
    565            osal_cpyExtAddr( &ZDP_TmpBuf[2], IEEEAddr );
    566            len = 2 + Z_EXTADDR_LEN;
    567          
    568            ZDP_TmpBuf[10] = capabilities;
    569            len++;
    570          
    571            return fillAndSend( &ZDP_TransID, &dstAddr, Device_annce, len );
    572          }
    573          
    574          /*********************************************************************
    575           * Address Responses
    576           */
    577          
    578          /*********************************************************************
    579           * @fn      zdpProcessAddrReq
    580           *
    581           * @brief   Process an incoming NWK_addr_req or IEEE_addr_req message and then
    582           *          build and send a corresponding NWK_addr_rsp or IEEE_addr_rsp msg.
    583           *
    584           * @param   inMsg - incoming message
    585           *
    586           * @return  none
    587           */
    588          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg )
    589          {
    590            associated_devices_t *pAssoc;
    591            uint8 reqType;
    592            uint16 aoi = INVALID_NODE_ADDR;
    593            uint8 *ieee = NULL;
    594          
    595            reqType = inMsg->asdu[(inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 ) ];
    596          
    597            if ( inMsg->clusterID == NWK_addr_req )
    598          
    599            {
    600              ieee = inMsg->asdu;
    601          
    602              if ( osal_ExtAddrEqual( saveExtAddr, ieee ) )
    603              {
    604                aoi = ZDAppNwkAddr.addr.shortAddr;
    605              }
    606              // Handle response for sleeping end devices
    607              else if ( (ZSTACK_ROUTER_BUILD)
    608                && (((pAssoc = AssocGetWithExt( ieee )) != NULL)
    609                       && (pAssoc->nodeRelation == CHILD_RFD)) )
    610              {
    611                aoi = pAssoc->shortAddr;
    612                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
    613                  reqType = 0xFF; // Force Invalid
    614              }
    615            }
    616            else  // if ( inMsg->clusterID == IEEE_addr_req )
    617            {
    618              aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    619          
    620              if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    621              {
    622                ieee = saveExtAddr;
    623              }
    624              else if ( (ZSTACK_ROUTER_BUILD)
    625                && (((pAssoc = AssocGetWithShort( aoi )) != NULL)
    626                       && (pAssoc->nodeRelation == CHILD_RFD)) )
    627              {
    628                AddrMgrEntry_t addrEntry;
    629                addrEntry.user = ADDRMGR_USER_DEFAULT;
    630                addrEntry.index = pAssoc->addrIdx;
    631                if ( AddrMgrEntryGet( &addrEntry ) )
    632                {
    633                  ieee = addrEntry.extAddr;
    634                }
    635          
    636                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
    637                  reqType = 0xFF; // Force Invalid
    638              }
    639            }
    640          
    641            if ( ((aoi != INVALID_NODE_ADDR) && (ieee != NULL)) || (inMsg->wasBroadcast == FALSE) )
    642            {
    643              uint8 stat;
    644              uint8 *pBuf = ZDP_TmpBuf;
    645              // Status + IEEE-Addr + Nwk-Addr.
    646              uint8 len = 1 + Z_EXTADDR_LEN + 2;
    647              
    648              // If aoi and iee are both setup, we found results
    649              if ( (aoi != INVALID_NODE_ADDR) && (ieee != NULL) )
    650              {
    651                stat = ((reqType == ZDP_ADDR_REQTYPE_SINGLE) || (reqType == ZDP_ADDR_REQTYPE_EXTENDED)) 
    652                              ? ZDP_SUCCESS : ZDP_INVALID_REQTYPE;
    653              }
    654              else 
    655              {
    656                // not found and the req was unicast to this device
    657                stat = ZDP_DEVICE_NOT_FOUND;
    658                
    659                // Fill in the missing field with this device's address
    660                if ( inMsg->clusterID == NWK_addr_req )
    661                {
    662                  aoi = ZDAppNwkAddr.addr.shortAddr;
    663                }
    664                else
    665                {
    666                  ieee = saveExtAddr;
    667                }
    668              }
    669          
    670              *pBuf++ = stat;
    671          
    672              pBuf = osal_cpyExtAddr( pBuf, ieee );
    673          
    674              *pBuf++ = LO_UINT16( aoi );
    675              *pBuf++ = HI_UINT16( aoi );
    676          
    677              if ( ZSTACK_ROUTER_BUILD )
    678              {
    679                if ( (reqType == ZDP_ADDR_REQTYPE_EXTENDED) && (aoi == ZDAppNwkAddr.addr.shortAddr)
    680                     && (stat == ZDP_SUCCESS) )
    681                {
    682                  uint8  cnt = 0;
    683                  uint16 *list = AssocMakeList( &cnt );
    684          
    685                  if ( list != NULL )
    686                  {
    687                    byte idx = inMsg->asdu[(((inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 )) + 1)];
    688                    uint16 *pList = list + idx;
    689          
    690                    // NumAssocDev field is only present on success.
    691                    if ( cnt > idx )
    692                    {
    693                      cnt -= idx;
    694                      len += (cnt * sizeof( uint16 ));
    695                    }
    696                    else
    697                    {
    698                      cnt = 0;
    699                    }
    700                    *pBuf++ = cnt;
    701                    len++;
    702          
    703                    // StartIndex field is only present if NumAssocDev field is non-zero.
    704                    *pBuf++ = idx;
    705                    len++;
    706          
    707                    while ( cnt != 0 )
    708                    {
    709                      *pBuf++ = LO_UINT16( *pList );
    710                      *pBuf++ = HI_UINT16( *pList );
    711                      pList++;
    712                      cnt--;
    713                    }
    714          
    715                    osal_mem_free( (uint8 *)list );
    716                  }
    717                  else
    718                  {
    719                    // NumAssocDev field is only present on success.
    720                    *pBuf++ = 0;
    721                    len++;
    722                  }
    723                }
    724              }
    725          
    726              ZDP_TxOptions = AF_MSG_ACK_REQUEST;
    727              fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), (cId_t)(inMsg->clusterID | ZDO_RESPONSE_BIT), len );
    728              ZDP_TxOptions = AF_TX_OPTIONS_NONE;
    729            }
    730          }
    731          
    732          /*********************************************************************
    733           * @fn          ZDP_NodeDescMsg
    734           *
    735           * @brief       Builds and sends a Node Descriptor message, unicast to the
    736           *              specified device.
    737           *
    738           * @param       inMsg - incoming message
    739           * @param       nwkAddr - 16 bit network address for device
    740           * @param       pNodeDesc - pointer to the node descriptor
    741           *
    742           * @return      afStatus_t
    743           */
    744          afStatus_t ZDP_NodeDescMsg( zdoIncomingMsg_t *inMsg,
    745                                     uint16 nwkAddr, NodeDescriptorFormat_t *pNodeDesc )
    746          {
    747            uint8 *pBuf = ZDP_TmpBuf;
    748            byte len;
    749          
    750            len = 1 + 2 + 13;  // Status + nwkAddr + Node descriptor
    751          
    752            *pBuf++ = ZDP_SUCCESS;
    753          
    754            *pBuf++ = LO_UINT16( nwkAddr );
    755            *pBuf++ = HI_UINT16( nwkAddr );
    756          
    757            *pBuf++ = (byte)((pNodeDesc->ComplexDescAvail << 3) |
    758                               (pNodeDesc->UserDescAvail << 4) |
    759                               (pNodeDesc->LogicalType & 0x07));
    760          
    761            *pBuf++ = (byte)((pNodeDesc->FrequencyBand << 3) | (pNodeDesc->APSFlags & 0x07));
    762            *pBuf++ = pNodeDesc->CapabilityFlags;
    763            *pBuf++ = pNodeDesc->ManufacturerCode[0];
    764            *pBuf++ = pNodeDesc->ManufacturerCode[1];
    765            *pBuf++ = pNodeDesc->MaxBufferSize;
    766            *pBuf++ = pNodeDesc->MaxInTransferSize[0];
    767            *pBuf++ = pNodeDesc->MaxInTransferSize[1];
    768          
    769            *pBuf++ = LO_UINT16( pNodeDesc->ServerMask );
    770            *pBuf++ = HI_UINT16( pNodeDesc->ServerMask );
    771            *pBuf++ = pNodeDesc->MaxOutTransferSize[0];
    772            *pBuf++ = pNodeDesc->MaxOutTransferSize[1];
    773            *pBuf = pNodeDesc->DescriptorCapability;
    774          
    775            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Node_Desc_rsp, len );
    776          }
    777          
    778          /*********************************************************************
    779           * @fn          ZDP_PowerDescMsg
    780           *
    781           * @brief       Builds and sends a Power Descriptor message, unicast to the
    782           *              specified device.
    783           *
    784           * @param       inMsg - incoming message (request)
    785           * @param       nwkAddr - 16 bit network address for device
    786           * @param       pPowerDesc - pointer to the node descriptor
    787           *
    788           * @return      afStatus_t
    789           */
    790          afStatus_t ZDP_PowerDescMsg( zdoIncomingMsg_t *inMsg,
    791                               uint16 nwkAddr, NodePowerDescriptorFormat_t *pPowerDesc )
    792          {
    793            uint8 *pBuf = ZDP_TmpBuf;
    794            byte len = 1 + 2 + 2;  // Status + nwkAddr + Node Power descriptor.
    795          
    796            *pBuf++ = ZDP_SUCCESS;
    797          
    798            *pBuf++ = LO_UINT16( nwkAddr );
    799            *pBuf++ = HI_UINT16( nwkAddr );
    800          
    801            *pBuf++ = (byte)((pPowerDesc->AvailablePowerSources << 4)
    802                              | (pPowerDesc->PowerMode & 0x0F));
    803            *pBuf++ = (byte)((pPowerDesc->CurrentPowerSourceLevel << 4)
    804                              | (pPowerDesc->CurrentPowerSource & 0x0F));
    805          
    806            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Power_Desc_rsp, len );
    807          }
    808          
    809          /*********************************************************************
    810           * @fn          ZDP_SimpleDescMsg
    811           *
    812           * @brief       Builds and sends a Simple Descriptor message, unicast to the
    813           *              specified device.
    814           *
    815           * @param       inMsg - incoming message (request)
    816           * @param       Status - message status (ZDP_SUCCESS or other)
    817           * @param       pSimpleDesc - pointer to the node descriptor
    818           *
    819           * @return      afStatus_t
    820           */
    821          afStatus_t ZDP_SimpleDescMsg( zdoIncomingMsg_t *inMsg, byte Status,
    822                                        SimpleDescriptionFormat_t *pSimpleDesc )
    823          {
    824            uint8 *pBuf = ZDP_TmpBuf;
    825            uint8 i, len;
    826          
    827            if ( Status == ZDP_SUCCESS && pSimpleDesc )
    828            {
    829              // Status + NWKAddrOfInterest + desc length + empty simple descriptor.
    830              len = 1 + 2 + 1 + 8;
    831              len += (pSimpleDesc->AppNumInClusters + pSimpleDesc->AppNumOutClusters) * sizeof ( uint16 );
    832            }
    833            else
    834            {
    835              len = 1 + 2 + 1; // Status + desc length
    836            }
    837            if ( len >= ZDP_BUF_SZ-1 )
    838            {
    839              return afStatus_MEM_FAIL;
    840            }
    841          
    842            *pBuf++ = Status;
    843          
    844            *pBuf++ = LO_UINT16( ZDAppNwkAddr.addr.shortAddr );
    845            *pBuf++ = HI_UINT16( ZDAppNwkAddr.addr.shortAddr );
    846          
    847            if ( len > 4 )
    848            {
    849              *pBuf++ = len - 4;   // Simple descriptor length
    850          
    851              *pBuf++ = pSimpleDesc->EndPoint;
    852              *pBuf++ = LO_UINT16( pSimpleDesc->AppProfId );
    853              *pBuf++ = HI_UINT16( pSimpleDesc->AppProfId );
    854              *pBuf++ = LO_UINT16( pSimpleDesc->AppDeviceId );
    855              *pBuf++ = HI_UINT16( pSimpleDesc->AppDeviceId );
    856          
    857              *pBuf++ = (byte)(pSimpleDesc->AppDevVer << 4);
    858          
    859              *pBuf++ = pSimpleDesc->AppNumInClusters;
    860              if ( pSimpleDesc->AppNumInClusters )
    861              {
    862                for (i=0; i<pSimpleDesc->AppNumInClusters; ++i)
    863                {
    864                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppInClusterList[i] );
    865                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppInClusterList[i] );
    866                }
    867              }
    868          
    869              *pBuf++ = pSimpleDesc->AppNumOutClusters;
    870              if ( pSimpleDesc->AppNumOutClusters )
    871              {
    872                for (i=0; i<pSimpleDesc->AppNumOutClusters; ++i)
    873                {
    874                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppOutClusterList[i] );
    875                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppOutClusterList[i] );
    876                }
    877              }
    878            }
    879          
    880            else
    881            {
    882              *pBuf = 0; // Description Length = 0;
    883            }
    884          
    885            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Simple_Desc_rsp, len );
    886          }
    887          
    888          /*********************************************************************
    889           * @fn          ZDP_EPRsp
    890           *
    891           * @brief       This builds and send an endpoint list. Used in
    892           *              Active_EP_rsp and Match_Desc_Rsp
    893           *              message.  This function sends unicast message to the
    894           *              requesting device.
    895           *
    896           * @param       MsgType - either Active_EP_rsp or Match_Desc_Rsp
    897           * @param       dstAddr - destination address
    898           * @param       Status - message status (ZDP_SUCCESS or other)
    899           * @param       nwkAddr - Device's short address that this response describes
    900           * @param       Count - number of endpoint/interfaces in list
    901           * @param       pEPIntfList - Array of Endpoint/Interfaces
    902           * @param       SecurityEnable - Security Options
    903           *
    904           * @return      afStatus_t
    905           */
    906          afStatus_t ZDP_EPRsp( uint16 MsgType, byte TransSeq, zAddrType_t *dstAddr,
    907                                  byte Status, uint16 nwkAddr, byte Count,
    908                                  uint8 *pEPList,
    909                                  byte SecurityEnable )
    910          {
    911            uint8 *pBuf = ZDP_TmpBuf;
    912            byte len = 1 + 2 + 1;  // Status + nwkAddr + endpoint/interface count.
    913            byte txOptions;
    914          
    915            (void)SecurityEnable;  // Intentionally unreferenced parameter
    916          
    917            if ( MsgType == Match_Desc_rsp )
    918              txOptions = AF_MSG_ACK_REQUEST;
    919            else
    920              txOptions = 0;
    921          
    922              *pBuf++ = Status;
    923            *pBuf++ = LO_UINT16( nwkAddr );
    924            *pBuf++ = HI_UINT16( nwkAddr );
    925          
    926            *pBuf++ = Count;   // Endpoint/Interface count
    927          
    928            if ( Count )
    929            {
    930              len += Count;
    931              osal_memcpy( pBuf, pEPList, Count );
    932            }
    933          
    934            FillAndSendTxOptions( &TransSeq, dstAddr, MsgType, len, txOptions );
    935          }
    936          
    937          /*********************************************************************
    938           * @fn          ZDP_UserDescRsp
    939           *
    940           * @brief       Build and send the User Decriptor Response.
    941           *
    942           *
    943           * @param       dstAddr - destination address
    944           * @param       nwkAddrOfInterest -
    945           * @param       userDesc -
    946           * @param       SecurityEnable - Security Options
    947           *
    948           * @return      ZStatus_t
    949           */
    950          ZStatus_t ZDP_UserDescRsp( byte TransSeq, zAddrType_t *dstAddr,
    951                          uint16 nwkAddrOfInterest, UserDescriptorFormat_t *userDesc,
    952                          byte SecurityEnable )
    953          {
    954            uint8 *pBuf = ZDP_TmpBuf;
    955            byte len = 1 + 2 + 1;  // Status + nwkAddr + descriptor length.
    956          
    957            (void)SecurityEnable;  // Intentionally unreferenced parameter
    958          
    959            len += userDesc->len;
    960          
    961            *pBuf++ = ZSUCCESS;
    962          
    963            *pBuf++ = LO_UINT16( nwkAddrOfInterest );
    964            *pBuf++ = HI_UINT16( nwkAddrOfInterest );
    965          
    966            *pBuf++ = userDesc->len;
    967            osal_memcpy( pBuf, userDesc->desc, userDesc->len );
    968          
    969            return (ZStatus_t)fillAndSend( &TransSeq, dstAddr, User_Desc_rsp, len );
    970          }
    971          
    972          /*********************************************************************
    973           * @fn          ZDP_ServerDiscRsp
    974           *
    975           * @brief       Build and send the Server_Discovery_rsp response.
    976           *
    977           * @param       transID - Transaction sequence number of request.
    978           * @param       dstAddr - Network Destination Address.
    979           * @param       status - Status of response to request.
    980           * @param       aoi - Network Address of Interest of request.
    981           * @param       serverMask - Bit map of service(s) being sought.
    982           * @param       SecurityEnable - Security Options
    983           *
    984           * @return      ZStatus_t
    985           */
    986          ZStatus_t ZDP_ServerDiscRsp( byte transID, zAddrType_t *dstAddr, byte status,
    987                                     uint16 aoi, uint16 serverMask, byte SecurityEnable )
    988          {
    989            const byte len = 1  + 2;  // status + aoi + mask.
    990            uint8 *pBuf = ZDP_TmpBuf;
    991            ZStatus_t stat;
    992          
    993            // Intentionally unreferenced parameters
    994            (void)aoi;
    995            (void)SecurityEnable;
    996          
    997            *pBuf++ = status;
    998          
    999            *pBuf++ = LO_UINT16( serverMask );
   1000            *pBuf++ = HI_UINT16( serverMask );
   1001          
   1002            ZDP_TxOptions = AF_MSG_ACK_REQUEST;
   1003            stat = fillAndSend( &transID, dstAddr, Server_Discovery_rsp, len );
   1004            ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   1005          
   1006            return ( stat );
   1007          }
   1008          
   1009          /*********************************************************************
   1010           * @fn          ZDP_GenericRsp
   1011           *
   1012           * @brief       Sends a response message with only the parameter status
   1013           *              byte and the addr of interest for data.
   1014           *              This function sends unicast message to the
   1015           *              requesting device.
   1016           *
   1017           * @param       dstAddr - destination address
   1018           * @param       status  - generic status for response
   1019           * @param       aoi     - address of interest
   1020           * @param       dstAddr - destination address
   1021           * @param       rspId   - response cluster ID
   1022           * @param       SecurityEnable - Security Options
   1023           *
   1024           * @return      afStatus_t
   1025           */
   1026          afStatus_t ZDP_GenericRsp( byte TransSeq, zAddrType_t *dstAddr,
   1027                               byte status, uint16 aoi, uint16 rspID, byte SecurityEnable )
   1028          {
   1029            uint8 len;
   1030          
   1031            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1032          
   1033            ZDP_TmpBuf[0] = status;
   1034            ZDP_TmpBuf[1] = LO_UINT16( aoi );
   1035            ZDP_TmpBuf[2] = HI_UINT16( aoi );
   1036          
   1037            // Length byte
   1038            ZDP_TmpBuf[3] = 0;
   1039            len = 4;
   1040          
   1041            return fillAndSend( &TransSeq, dstAddr, rspID, len );
   1042          }
   1043          
   1044          /*********************************************************************
   1045           * Binding
   1046           */
   1047          /*********************************************************************
   1048           * @fn          ZDP_EndDeviceBindReq
   1049           *
   1050           * @brief       This builds and sends a End_Device_Bind_req message.
   1051           *              This function sends a unicast message.
   1052           *
   1053           * @param       dstAddr - destination address
   1054           * @param       LocalCoordinator - short address of local coordinator
   1055           * @param       epIntf - Endpoint/Interface of Simple Desc
   1056           * @param       ProfileID - Profile ID
   1057           *
   1058           *   The Input cluster list is the opposite of what you would think.
   1059           *   This is the output cluster list of this device
   1060           * @param       NumInClusters - number of input clusters
   1061           * @param       InClusterList - input cluster ID list
   1062           *
   1063           *   The Output cluster list is the opposite of what you would think.
   1064           *   This is the input cluster list of this device
   1065           * @param       NumOutClusters - number of output clusters
   1066           * @param       OutClusterList - output cluster ID list
   1067           *
   1068           * @param       SecurityEnable - Security Options
   1069           *
   1070           * @return      afStatus_t
   1071           */
   1072          afStatus_t ZDP_EndDeviceBindReq( zAddrType_t *dstAddr,
   1073                                           uint16 LocalCoordinator,
   1074                                           byte endPoint,
   1075                                           uint16 ProfileID,
   1076                                           byte NumInClusters, cId_t *InClusterList,
   1077                                           byte NumOutClusters, cId_t *OutClusterList,
   1078                                           byte SecurityEnable )
   1079          {
   1080            uint8 *pBuf = ZDP_TmpBuf;
   1081            uint8 i, len;
   1082            uint8 *ieeeAddr;
   1083          
   1084            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1085          
   1086            // LocalCoordinator + SrcExtAddr + ep + ProfileID +  NumInClusters + NumOutClusters.
   1087            len = 2 + Z_EXTADDR_LEN + 1 + 2 + 1 + 1;
   1088            len += (NumInClusters + NumOutClusters) * sizeof ( uint16 );
   1089          
   1090            if ( len >= ZDP_BUF_SZ-1 )
   1091            {
   1092              return afStatus_MEM_FAIL;
   1093            }
   1094          
   1095            if ( LocalCoordinator != NLME_GetShortAddr() )
   1096            {
   1097              return afStatus_INVALID_PARAMETER;
   1098            }
   1099          
   1100            *pBuf++ = LO_UINT16( LocalCoordinator );
   1101            *pBuf++ = HI_UINT16( LocalCoordinator );
   1102          
   1103            ieeeAddr = NLME_GetExtAddr();
   1104            pBuf = osal_cpyExtAddr( pBuf, ieeeAddr );
   1105          
   1106            *pBuf++ = endPoint;
   1107          
   1108            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
   1109            *pBuf++ = HI_UINT16( ProfileID );
   1110          
   1111            *pBuf++ = NumInClusters; // Input cluster list
   1112            for ( i = 0; i < NumInClusters; ++i )
   1113            {
   1114              *pBuf++ = LO_UINT16(InClusterList[i]);
   1115              *pBuf++ = HI_UINT16(InClusterList[i]);
   1116            }
   1117          
   1118            *pBuf++ = NumOutClusters; // Output cluster list
   1119            for ( i = 0; i < NumOutClusters; ++i )
   1120            {
   1121              *pBuf++ = LO_UINT16(OutClusterList[i]);
   1122              *pBuf++ = HI_UINT16(OutClusterList[i]);
   1123            }
   1124          
   1125            return fillAndSend( &ZDP_TransID, dstAddr, End_Device_Bind_req, len );
   1126          }
   1127          
   1128          /*********************************************************************
   1129           * @fn          ZDP_BindUnbindReq
   1130           *
   1131           * @brief       This builds and send a Bind_req or Unbind_req message
   1132           *              Depending on the ClusterID. This function
   1133           *              sends a unicast message to the local coordinator.
   1134           *
   1135           * @param       BindOrUnbind - either Bind_req or Unbind_req
   1136           * @param       dstAddr - destination address of the message
   1137           * @param       SourceAddr - source 64 bit address of the binding
   1138           * @param       SrcEPIntf - Source endpoint/interface
   1139           * @param       ClusterID - Binding cluster ID
   1140           * @param       DestinationAddr - destination 64 bit addr of binding
   1141           * @param       DstEPIntf - destination endpoint/interface
   1142           * @param       SecurityEnable - Security Options
   1143           *
   1144           * @return      afStatus_t
   1145           */
   1146          afStatus_t ZDP_BindUnbindReq( uint16 BindOrUnbind, zAddrType_t *dstAddr,
   1147                                        uint8 *SourceAddr, byte SrcEndPoint,
   1148                                        cId_t ClusterID,
   1149                                        zAddrType_t *destinationAddr, byte DstEndPoint,
   1150                                        byte SecurityEnable )
   1151          {
   1152            uint8 *pBuf = ZDP_TmpBuf;
   1153            byte len;
   1154          
   1155            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1156          
   1157            // SourceAddr + SrcEPIntf + ClusterID +  addrMode.
   1158            len = Z_EXTADDR_LEN + 1 + sizeof( cId_t ) + sizeof( uint8 );
   1159            if ( destinationAddr->addrMode == Addr64Bit )
   1160              len += Z_EXTADDR_LEN + 1;     // +1 for DstEPIntf
   1161            else if ( destinationAddr->addrMode == AddrGroup )
   1162              len += sizeof ( uint16 );
   1163          
   1164            pBuf = osal_cpyExtAddr( pBuf, SourceAddr );
   1165            *pBuf++ = SrcEndPoint;
   1166          
   1167            *pBuf++ = LO_UINT16( ClusterID );
   1168          
   1169            *pBuf++ = HI_UINT16( ClusterID );
   1170            *pBuf++ = destinationAddr->addrMode;
   1171            if ( destinationAddr->addrMode == Addr64Bit )
   1172            {
   1173              pBuf = osal_cpyExtAddr( pBuf, destinationAddr->addr.extAddr );
   1174              *pBuf = DstEndPoint;
   1175            }
   1176            else if ( destinationAddr->addrMode == AddrGroup )
   1177            {
   1178              *pBuf++ = LO_UINT16( destinationAddr->addr.shortAddr );
   1179              *pBuf++ = HI_UINT16( destinationAddr->addr.shortAddr );
   1180            }
   1181          
   1182            FillAndSendTxOptions( &ZDP_TransID, dstAddr, BindOrUnbind, len, AF_MSG_ACK_REQUEST );
   1183          }
   1184          
   1185          /*********************************************************************
   1186           * Network Management
   1187           */
   1188          
   1189          /*********************************************************************
   1190           * @fn          ZDP_MgmtNwkDiscReq
   1191           *
   1192           * @brief       This builds and send a Mgmt_NWK_Disc_req message. This
   1193           *              function sends a unicast message.
   1194           *
   1195           * @param       dstAddr - destination address of the message
   1196           * @param       ScanChannels - 32 bit address bit map
   1197           * @param       StartIndex - Starting index within the reporting network
   1198           *                           list
   1199           * @param       SecurityEnable - Security Options
   1200           *
   1201           * @return      afStatus_t
   1202           */
   1203          afStatus_t ZDP_MgmtNwkDiscReq( zAddrType_t *dstAddr,
   1204                                         uint32 ScanChannels,
   1205                                         byte ScanDuration,
   1206                                         byte StartIndex,
   1207                                         byte SecurityEnable )
   1208          {
   1209            uint8 *pBuf = ZDP_TmpBuf;
   1210            byte len = sizeof( uint32 )+1+1;  // ScanChannels + ScanDuration + StartIndex.
   1211          
   1212            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1213          
   1214            pBuf = osal_buffer_uint32( pBuf, ScanChannels );
   1215          
   1216            *pBuf++ = ScanDuration;
   1217            *pBuf = StartIndex;
   1218          
   1219            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Disc_req, len );
   1220          }
   1221          
   1222          /*********************************************************************
   1223           * @fn          ZDP_MgmtDirectJoinReq
   1224           *
   1225           * @brief       This builds and send a Mgmt_Direct_Join_req message. This
   1226           *              function sends a unicast message.
   1227           *
   1228           * @param       dstAddr - destination address of the message
   1229           * @param       deviceAddr - 64 bit IEEE Address
   1230           * @param       SecurityEnable - Security Options
   1231           *
   1232           * @return      afStatus_t
   1233           */
   1234          afStatus_t ZDP_MgmtDirectJoinReq( zAddrType_t *dstAddr,
   1235                                         uint8 *deviceAddr,
   1236                                         byte capInfo,
   1237                                         byte SecurityEnable )
   1238          {
   1239            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1240          
   1241            osal_cpyExtAddr( ZDP_TmpBuf, deviceAddr );
   1242            ZDP_TmpBuf[Z_EXTADDR_LEN] = capInfo;
   1243          
   1244            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Direct_Join_req, (Z_EXTADDR_LEN + 1) );
   1245          }
   1246          
   1247          /*********************************************************************
   1248           * @fn          ZDP_MgmtPermitJoinReq
   1249           *
   1250           * @brief       This builds and send a Mgmt_Permit_Join_req message.
   1251           *
   1252           * @param       dstAddr - destination address of the message
   1253           * @param       duration - Permit duration
   1254           * @param       TcSignificance - Trust Center Significance
   1255           *
   1256           * @return      afStatus_t
   1257           */
   1258          afStatus_t ZDP_MgmtPermitJoinReq( zAddrType_t *dstAddr, byte duration,
   1259                                            byte TcSignificance, byte SecurityEnable )
   1260          {
   1261            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1262          
   1263            // Build buffer
   1264            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION] = duration;
   1265            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG]   = TcSignificance;
   1266          
   1267            // Send the message
   1268            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Permit_Join_req,
   1269                                ZDP_MGMT_PERMIT_JOIN_REQ_SIZE );
   1270          }
   1271          
   1272          /*********************************************************************
   1273           * @fn          ZDP_MgmtLeaveReq
   1274           *
   1275           * @brief       This builds and send a Mgmt_Leave_req message.
   1276           *
   1277           * @param       dstAddr - destination address of the message
   1278           *              IEEEAddr - IEEE adddress of device that is removed
   1279           *              RemoveChildren - set to 1 to remove the children of the
   1280           *                                device as well. 0 otherwise.
   1281           *              Rejoin - set to 1 if the removed device should rejoin
   1282                                   afterwards. 0 otherwise.
   1283           *
   1284           * @return      afStatus_t
   1285           */
   1286          afStatus_t ZDP_MgmtLeaveReq( zAddrType_t *dstAddr, uint8 *IEEEAddr, uint8 RemoveChildren,
   1287                           uint8 Rejoin, uint8 SecurityEnable )
   1288          
   1289          {
   1290            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1291          
   1292            osal_cpyExtAddr( ZDP_TmpBuf, IEEEAddr );
   1293            ZDP_TmpBuf[Z_EXTADDR_LEN] = 0;
   1294          
   1295            if ( RemoveChildren == TRUE )
   1296            {
   1297              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_RC;
   1298            }
   1299            if ( Rejoin == TRUE )
   1300            {
   1301              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_REJOIN;
   1302            }
   1303          
   1304            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Leave_req, (Z_EXTADDR_LEN + 1) );
   1305          }
   1306          
   1307          /*********************************************************************
   1308           * @fn          ZDP_MgmtNwkUpdateReq
   1309           *
   1310           * @brief       This builds and send a Mgmt_NWK_Update_req message. This
   1311           *              function sends a unicast or broadcast message.
   1312           *
   1313           * @param       dstAddr - destination address of the message
   1314           * @param       ChannelMask - 32 bit address bit map
   1315           * @param       ScanDuration - length of time to spend scanning each channel
   1316           * @param       ScanCount - number of energy scans to be conducted
   1317           * @param       NwkUpdateId - NWk Update Id value
   1318           * @param       NwkManagerAddr - NWK address for device with Network Manager
   1319           *                               bit set in its Node Descriptor
   1320           *
   1321           * @return      afStatus_t
   1322           */
   1323          afStatus_t ZDP_MgmtNwkUpdateReq( zAddrType_t *dstAddr,
   1324                                           uint32 ChannelMask,
   1325                                           uint8 ScanDuration,
   1326                                           uint8 ScanCount,
   1327                                           uint8 NwkUpdateId,
   1328                                           uint16 NwkManagerAddr )
   1329          {
   1330            uint8 *pBuf = ZDP_TmpBuf;
   1331            byte len = sizeof( uint32 ) + 1;  // ChannelMask + ScanDuration
   1332          
   1333            pBuf = osal_buffer_uint32( pBuf, ChannelMask );
   1334          
   1335            *pBuf++ = ScanDuration;
   1336          
   1337            if ( ScanDuration <= 0x05 )
   1338            {
   1339              // Request is to scan over channelMask
   1340              len += sizeof( uint8 );
   1341          
   1342              *pBuf++ = ScanCount;
   1343            }
   1344            else if ( ( ScanDuration == 0xFE ) || ( ScanDuration == 0xFF ) )
   1345            {
   1346              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   1347              len += sizeof( uint8 );
   1348          
   1349              *pBuf++ = NwkUpdateId;
   1350          
   1351              if ( ScanDuration == 0xFF )
   1352              {
   1353                len += sizeof( uint16 );
   1354          
   1355                *pBuf++  = LO_UINT16( NwkManagerAddr );
   1356                *pBuf++  = HI_UINT16( NwkManagerAddr );
   1357              }
   1358            }
   1359          
   1360            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Update_req, len );
   1361          }
   1362          
   1363          
   1364          /*********************************************************************
   1365           * Network Management Responses
   1366           */
   1367          
   1368          /*********************************************************************
   1369           * @fn          ZDP_MgmtNwkDiscRsp
   1370           *
   1371           * @brief       This builds and send a Mgmt_NWK_Disc_rsp message. This
   1372           *              function sends a unicast message.
   1373           *
   1374           * @param       dstAddr - destination address of the message
   1375           * @param       Status - message status (ZDP_SUCCESS or other)
   1376           * @param       NetworkCount - Total number of networks found
   1377           * @param       StartIndex - Starting index within the reporting network
   1378           *                           list
   1379           * @param       NetworkListCount - number of network lists included
   1380           *                                 in this message
   1381           * @param       NetworkList - List of network descriptors
   1382           * @param       SecurityEnable - Security Options
   1383           *
   1384           * @return      afStatus_t
   1385           */
   1386          afStatus_t ZDP_MgmtNwkDiscRsp( byte TransSeq, zAddrType_t *dstAddr,
   1387                                      byte Status,
   1388                                      byte NetworkCount,
   1389                                      byte StartIndex,
   1390                                      byte NetworkListCount,
   1391                                      networkDesc_t *NetworkList,
   1392                                      byte SecurityEnable )
   1393          {
   1394            uint8 *buf;
   1395            uint8 *pBuf;
   1396            byte len = 1+1+1+1;  // Status + NetworkCount + StartIndex + NetworkCountList.
   1397            byte idx;
   1398          
   1399            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1400          
   1401            len += (NetworkListCount * ( ZDP_NETWORK_EXTENDED_DISCRIPTOR_SIZE - 2 ));
   1402          
   1403            buf = osal_mem_alloc( len+1 );
   1404            if ( buf == NULL )
   1405            {
   1406              return afStatus_MEM_FAIL;
   1407            }
   1408          
   1409            pBuf = buf+1;
   1410          
   1411            *pBuf++ = Status;
   1412            *pBuf++ = NetworkCount;
   1413            *pBuf++ = StartIndex;
   1414            *pBuf++ = NetworkListCount;
   1415          
   1416            for ( idx = 0; idx < NetworkListCount; idx++ )
   1417            {
   1418              osal_cpyExtAddr( pBuf, NetworkList->extendedPANID);
   1419              pBuf += Z_EXTADDR_LEN;
   1420          
   1421              *pBuf++  = NetworkList->logicalChannel;                // LogicalChannel
   1422              *pBuf    = NetworkList->stackProfile;                  // Stack profile
   1423              *pBuf++ |= (byte)(NetworkList->version << 4);          // ZigBee Version
   1424              *pBuf    = NetworkList->beaconOrder;                   // Beacon Order
   1425              *pBuf++ |= (byte)(NetworkList->superFrameOrder << 4);  // Superframe Order
   1426          
   1427              if ( NetworkList->chosenRouter != INVALID_NODE_ADDR )
   1428              {
   1429                *pBuf++ = TRUE;                         // Permit Joining
   1430              }
   1431              else
   1432              {
   1433                *pBuf++ = FALSE;
   1434              }
   1435          
   1436              NetworkList = NetworkList->nextDesc;    // Move to next list entry
   1437            }
   1438          
   1439            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_NWK_Disc_rsp, len, buf );
   1440          }
   1441          
   1442          /*********************************************************************
   1443           * @fn          ZDP_MgmtLqiRsp
   1444           *
   1445           * @brief       This builds and send a Mgmt_Lqi_rsp message. This
   1446           *              function sends a unicast message.
   1447           *
   1448           * @param       dstAddr - destination address of the message
   1449           * @param       Status - message status (ZDP_SUCCESS or other)
   1450           * @param       NeighborLqiEntries - Total number of entries found
   1451           * @param       StartIndex - Starting index within the reporting list
   1452           * @param       NeighborLqiCount - number of lists included
   1453           *                                 in this message
   1454           * @param       NeighborLqiList - List of NeighborLqiItems.  This list
   1455           *                is the list to be sent, not the entire list
   1456           * @param       SecurityEnable - true if secure
   1457           *
   1458           * @return      ZStatus_t
   1459           */
   1460          ZStatus_t ZDP_MgmtLqiRsp( byte TransSeq, zAddrType_t *dstAddr,
   1461                                    byte Status,
   1462                                    byte NeighborLqiEntries,
   1463                                    byte StartIndex,
   1464                                    byte NeighborLqiCount,
   1465                                    ZDP_MgmtLqiItem_t* NeighborList,
   1466                                    byte SecurityEnable )
   1467          {
   1468            ZDP_MgmtLqiItem_t* list = NeighborList;
   1469            uint8 *buf, *pBuf;
   1470            byte len, x;
   1471          
   1472            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1473          
   1474            if ( ZSuccess != Status )
   1475            {
   1476              ZDP_TmpBuf[0] = Status;
   1477              return fillAndSend( &TransSeq, dstAddr, Mgmt_Lqi_rsp, 1 );
   1478            }
   1479          
   1480            // (Status + NeighborLqiEntries + StartIndex + NeighborLqiCount) +
   1481            //  neighbor LQI data.
   1482            len = (1 + 1 + 1 + 1) + (NeighborLqiCount * ZDP_MGMTLQI_EXTENDED_SIZE);
   1483          
   1484            buf = osal_mem_alloc( len+1 );
   1485            if ( buf == NULL )
   1486            {
   1487              return afStatus_MEM_FAIL;
   1488            }
   1489          
   1490            pBuf = buf+1;
   1491          
   1492            *pBuf++ = Status;
   1493            *pBuf++ = NeighborLqiEntries;
   1494            *pBuf++ = StartIndex;
   1495            *pBuf++ = NeighborLqiCount;
   1496          
   1497            for ( x = 0; x < NeighborLqiCount; x++ )
   1498            {
   1499              osal_cpyExtAddr( pBuf, list->extPanID);         // Extended PanID
   1500              pBuf += Z_EXTADDR_LEN;
   1501          
   1502              // EXTADDR
   1503              pBuf = osal_cpyExtAddr( pBuf, list->extAddr );
   1504          
   1505              // NWKADDR
   1506              *pBuf++ = LO_UINT16( list->nwkAddr );
   1507              *pBuf++ = HI_UINT16( list->nwkAddr );
   1508          
   1509              // DEVICETYPE
   1510              *pBuf = list->devType;
   1511          
   1512              // RXONIDLE
   1513              *pBuf |= (uint8)(list->rxOnIdle << 2);
   1514          
   1515              // RELATIONSHIP
   1516              *pBuf++ |= (uint8)(list->relation << 4);
   1517          
   1518              // PERMITJOINING
   1519              *pBuf++ = (uint8)(list->permit);
   1520          
   1521              // DEPTH
   1522              *pBuf++ = list->depth;
   1523          
   1524              // LQI
   1525              *pBuf++ = list->lqi;
   1526          
   1527              list++; // next list entry
   1528            }
   1529          
   1530            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Lqi_rsp, len, buf );
   1531          }
   1532          
   1533          /*********************************************************************
   1534           * @fn          ZDP_MgmtRtgRsp
   1535           *
   1536           * @brief       This builds and send a Mgmt_Rtg_rsp message. This
   1537           *              function sends a unicast message.
   1538           *
   1539           * @param       dstAddr - destination address of the message
   1540           * @param       Status - message status (ZDP_SUCCESS or other)
   1541           * @param       RoutingTableEntries - Total number of entries
   1542           * @param       StartIndex - Starting index within the reporting list
   1543           * @param       RoutingTableListCount - number of entries included
   1544           *                                      in this message
   1545           * @param       RoutingTableList - List of Routing Table entries
   1546           * @param       SecurityEnable - true to enable security for this message
   1547           *
   1548           * @return      ZStatus_t
   1549           */
   1550          ZStatus_t ZDP_MgmtRtgRsp( byte TransSeq, zAddrType_t *dstAddr,
   1551                                      byte Status,
   1552                                      byte RoutingTableEntries,
   1553                                      byte StartIndex,
   1554                                      byte RoutingListCount,
   1555                                      rtgItem_t *RoutingTableList,
   1556                                      byte SecurityEnable )
   1557          {
   1558            uint8 *buf;
   1559            uint8 *pBuf;
   1560            // Status + RoutingTableEntries + StartIndex + RoutingListCount.
   1561            byte len = 1 + 1 + 1 + 1;
   1562            byte x;
   1563          
   1564            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1565          
   1566            // Add an array for Routing List data
   1567            len += (RoutingListCount * ZDP_ROUTINGENTRY_SIZE);
   1568          
   1569            buf = osal_mem_alloc( (short)(len+1) );
   1570            if ( buf == NULL )
   1571            {
   1572              return afStatus_MEM_FAIL;
   1573            }
   1574          
   1575            pBuf = buf+1;
   1576          
   1577            *pBuf++ = Status;
   1578            *pBuf++ = RoutingTableEntries;
   1579            *pBuf++ = StartIndex;
   1580            *pBuf++ = RoutingListCount;
   1581          
   1582            for ( x = 0; x < RoutingListCount; x++ )
   1583            {
   1584              *pBuf++ = LO_UINT16( RoutingTableList->dstAddress );  // Destination Address
   1585              *pBuf++ = HI_UINT16( RoutingTableList->dstAddress );
   1586              *pBuf++ = RoutingTableList->status;
   1587              *pBuf++ = LO_UINT16( RoutingTableList->nextHopAddress );  // Next hop
   1588              *pBuf++ = HI_UINT16( RoutingTableList->nextHopAddress );
   1589              RoutingTableList++;    // Move to next list entry
   1590            }
   1591          
   1592            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Rtg_rsp, len, buf );
   1593          }
   1594          
   1595          /*********************************************************************
   1596           * @fn          ZDP_MgmtBindRsp
   1597           *
   1598           * @brief       This builds and send a Mgmt_Bind_rsp message. This
   1599           *              function sends a unicast message.
   1600           *
   1601           * @param       dstAddr - destination address of the message
   1602           * @param       Status - message status (ZDP_SUCCESS or other)
   1603           * @param       BindingTableEntries - Total number of entries
   1604           * @param       StartIndex - Starting index within the reporting list
   1605           * @param       BindingTableListCount - number of entries included
   1606           *                                 in this message
   1607           * @param       BindingTableList - List of Binding Table entries
   1608           * @param       SecurityEnable - Security Options
   1609           *
   1610           * @return      ZStatus_t
   1611           */
   1612          ZStatus_t ZDP_MgmtBindRsp( byte TransSeq, zAddrType_t *dstAddr,
   1613                                      byte Status,
   1614                                      byte BindingTableEntries,
   1615                                      byte StartIndex,
   1616                                      byte BindingTableListCount,
   1617                                      apsBindingItem_t *BindingTableList,
   1618                                      byte SecurityEnable )
   1619          {
   1620            uint8 *buf;
   1621            uint8 *pBuf;
   1622            uint8 maxLen; // maxLen is the maximum packet length to allocate enough memory space
   1623            uint8 len;    // Actual length varies due to different addrMode
   1624            uint8 x;
   1625            byte extZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1; // One more byte for cluserID and DstAddrMode
   1626            byte shortZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1 + 2 - 8 - 1; // clusterID + DstAddrMode + shortAddr - ExtAddr - DstEndpoint
   1627          
   1628            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1629          
   1630            // Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1631            maxLen = 1 + 1 + 1 + 1;
   1632            maxLen += (BindingTableListCount * extZdpBindEntrySize );  //max length
   1633            buf = osal_mem_alloc( maxLen + 1 );  // +1 for transaction ID
   1634          
   1635            if ( buf == NULL )
   1636            {
   1637              return afStatus_MEM_FAIL;
   1638            }
   1639          
   1640            pBuf = buf+1;
   1641          
   1642            *pBuf++ = Status;
   1643            *pBuf++ = BindingTableEntries;
   1644            *pBuf++ = StartIndex;
   1645            *pBuf++ = BindingTableListCount;
   1646          
   1647            // Initial length = Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1648            // length += ZDP_BINDINGENTRY_SIZE   -- Version 1.0
   1649            //           extZdpBindEntrySize     -- Version 1.1 extended address mode
   1650            //           shortZdpBindEntrySize   -- Version 1.1 group address mode
   1651          
   1652            len = 1 + 1 + 1 + 1;
   1653            for ( x = 0; x < BindingTableListCount; x++ )
   1654            {
   1655              pBuf = osal_cpyExtAddr( pBuf, BindingTableList->srcAddr );
   1656              *pBuf++ = BindingTableList->srcEP;
   1657          
   1658              // Cluster ID
   1659              *pBuf++ = LO_UINT16( BindingTableList->clusterID );
   1660              *pBuf++ = HI_UINT16( BindingTableList->clusterID );
   1661          
   1662              *pBuf++ = BindingTableList->dstAddr.addrMode;
   1663              if ( BindingTableList->dstAddr.addrMode == Addr64Bit )
   1664              {
   1665                len += extZdpBindEntrySize;
   1666                pBuf = osal_cpyExtAddr( pBuf, BindingTableList->dstAddr.addr.extAddr );
   1667                *pBuf++ = BindingTableList->dstEP;
   1668              }
   1669              else
   1670              {
   1671                len += shortZdpBindEntrySize;
   1672                *pBuf++ = LO_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   1673                *pBuf++ = HI_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   1674              }
   1675              BindingTableList++;    // Move to next list entry
   1676            }
   1677          
   1678            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Bind_rsp, len, buf );
   1679          }
   1680          
   1681          /*********************************************************************
   1682           * @fn          ZDP_MgmtNwkUpdateNotify
   1683           *
   1684           * @brief       This builds and send a Mgmt_NWK_Update_notify message. This
   1685           *              function sends a unicast message.
   1686           *
   1687           * @param       dstAddr - destination address of the message
   1688           * @param       status - message status (ZDP_SUCCESS or other)
   1689           * @param       scannedChannels - List of channels scanned by the request
   1690           * @param       totalTransmissions - Total transmissions
   1691           * @param       transmissionFailures - Sum of transmission failures
   1692           * @param       listCount - Number of records contained in the energyValues list
   1693           * @param       energyValues - List of descriptors, one for each of ListCount,
   1694           *                             of the enegry detect descriptors
   1695           * @param       txOptions - Transmit options
   1696           * @param       securityEnable - Security options
   1697           *
   1698           * @return      afStatus_t
   1699           */
   1700          afStatus_t ZDP_MgmtNwkUpdateNotify( uint8 TransSeq, zAddrType_t *dstAddr,
   1701                                              uint8 status, uint32 scannedChannels,
   1702                                              uint16 totalTransmissions, uint16 transmissionFailures,
   1703                                              uint8 listCount, uint8 *energyValues, uint8 txOptions,
   1704                                              uint8 securityEnable )
   1705          {
   1706            uint8 *buf;
   1707            uint8 *pBuf;
   1708            uint8 len;
   1709          
   1710            (void)securityEnable;  // Intentionally unreferenced parameter
   1711          
   1712            // Status + ScannedChannels + totalTransmissions + transmissionFailures + ListCount + energyValues
   1713            len = 1 + 4 + 2 + 2 + 1 + listCount;
   1714          
   1715            buf = osal_mem_alloc( len+1 ); // +1 for transaction ID
   1716            if ( buf == NULL )
   1717            {
   1718              return afStatus_MEM_FAIL;
   1719            }
   1720          
   1721            pBuf = buf+1;
   1722          
   1723            *pBuf++ = status;
   1724          
   1725            pBuf = osal_buffer_uint32( pBuf, scannedChannels );
   1726          
   1727            *pBuf++ = LO_UINT16( totalTransmissions );
   1728            *pBuf++ = HI_UINT16( totalTransmissions );
   1729          
   1730            *pBuf++ = LO_UINT16( transmissionFailures );
   1731            *pBuf++ = HI_UINT16( transmissionFailures );
   1732          
   1733            *pBuf++ = listCount;
   1734          
   1735            if ( listCount > 0 )
   1736              osal_memcpy( pBuf, energyValues, listCount );
   1737          
   1738            FillAndSendBufferTxOptions( &TransSeq, dstAddr, Mgmt_NWK_Update_notify, len, buf, txOptions );
   1739          }
   1740          
   1741          /*********************************************************************
   1742           * Functions to register for ZDO Over-the-air messages
   1743           */
   1744          
   1745          /*********************************************************************
   1746           * @fn          ZDO_RegisterForZDOMsg
   1747           *
   1748           * @brief       Call this function to register of an incoming over
   1749           *              the air ZDO message - probably a response message
   1750           *              but requests can also be received.
   1751           *              Messages are delivered to the task with ZDO_CB_MSG
   1752           *              as the message ID.
   1753           *
   1754           * @param       taskID - Where you would like the message delivered
   1755           * @param       clusterID - What message?
   1756           *
   1757           * @return      ZSuccess - successful, ZMemError if not
   1758           */
   1759          ZStatus_t ZDO_RegisterForZDOMsg( uint8 taskID, uint16 clusterID )
   1760          {
   1761            ZDO_MsgCB_t *pList;
   1762            ZDO_MsgCB_t *pLast;
   1763            ZDO_MsgCB_t *pNew;
   1764          
   1765            // Look for duplicate
   1766            pList = pLast = zdoMsgCBs;
   1767            while ( pList )
   1768            {
   1769              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   1770                return ( ZSuccess );
   1771              pLast = pList;
   1772              pList = (ZDO_MsgCB_t *)pList->next;
   1773            }
   1774          
   1775            // Add to the list
   1776            pNew = (ZDO_MsgCB_t *)osal_mem_alloc( sizeof ( ZDO_MsgCB_t ) );
   1777            if ( pNew )
   1778            {
   1779              pNew->taskID = taskID;
   1780              pNew->clusterID = clusterID;
   1781              pNew->next = NULL;
   1782              if ( zdoMsgCBs )
   1783              {
   1784                pLast->next = pNew;
   1785              }
   1786              else
   1787                zdoMsgCBs = pNew;
   1788              return ( ZSuccess );
   1789            }
   1790            else
   1791              return ( ZMemError );
   1792          }
   1793          
   1794          /*********************************************************************
   1795           * @fn          ZDO_RemoveRegisteredCB
   1796           *
   1797           * @brief       Call this function if you don't want to receive the
   1798           *              incoming message.
   1799           *
   1800           * @param       taskID - Where the messages are being delivered.
   1801           * @param       clusterID - What message?
   1802           *
   1803           * @return      ZSuccess - successful, ZFailure if not found
   1804           */
   1805          ZStatus_t ZDO_RemoveRegisteredCB( uint8 taskID, uint16 clusterID )
   1806          {
   1807            ZDO_MsgCB_t *pList;
   1808            ZDO_MsgCB_t *pLast = NULL;
   1809          
   1810            pList = zdoMsgCBs;
   1811            while ( pList )
   1812            {
   1813              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   1814              {
   1815                if ( pLast )
   1816                {
   1817                  // remove this one from the linked list
   1818                  pLast->next = pList->next;
   1819                }
   1820                else if ( pList->next )
   1821                {
   1822                  // remove the first one from the linked list
   1823                  zdoMsgCBs = pList->next;
   1824                }
   1825                else
   1826                {
   1827                  // remove the only item from the list
   1828                  zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
   1829                }
   1830                osal_mem_free( pList );
   1831                return ( ZSuccess );
   1832              }
   1833              pLast = pList;
   1834              pList = pList->next;
   1835            }
   1836          
   1837            return ( ZFailure );
   1838          }
   1839          
   1840          /*********************************************************************
   1841           * @fn          ZDO_SendMsgCBs
   1842           *
   1843           * @brief       This function sends messages to registered tasks.
   1844           *              Local to ZDO and shouldn't be called outside of ZDO.
   1845           *
   1846           * @param       inMsg - incoming message
   1847           *
   1848           * @return      TRUE if sent to at least 1 task, FALSE if not
   1849           */
   1850          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg )
   1851          {
   1852            uint8 ret = FALSE;
   1853            ZDO_MsgCB_t *pList = zdoMsgCBs;
   1854            while ( pList )
   1855            {
   1856              if ( pList->clusterID == inMsg->clusterID )
   1857              {
   1858                zdoIncomingMsg_t *msgPtr;
   1859          
   1860                // Send the address to the task
   1861                msgPtr = (zdoIncomingMsg_t *)osal_msg_allocate( sizeof( zdoIncomingMsg_t ) + inMsg->asduLen );
   1862                if ( msgPtr )
   1863                {
   1864                  // copy struct
   1865                  osal_memcpy( msgPtr, inMsg, sizeof( zdoIncomingMsg_t ));
   1866          
   1867                  if ( inMsg->asduLen )
   1868                  {
   1869                    msgPtr->asdu = (byte*)(((byte*)msgPtr) + sizeof( zdoIncomingMsg_t ));
   1870                    osal_memcpy( msgPtr->asdu, inMsg->asdu, inMsg->asduLen );
   1871                  }
   1872          
   1873                  msgPtr->hdr.event = ZDO_CB_MSG;
   1874                  osal_msg_send( pList->taskID, (uint8 *)msgPtr );
   1875                  ret = TRUE;
   1876                }
   1877              }
   1878              pList = (ZDO_MsgCB_t *)pList->next;
   1879            }
   1880            return ( ret );
   1881          }
   1882          
   1883          /*********************************************************************
   1884           * Incoming message processor
   1885           */
   1886          
   1887          /*********************************************************************
   1888           * @fn          ZDP_IncomingData
   1889           *
   1890           * @brief       This function indicates the transfer of a data PDU (ASDU)
   1891           *              from the APS sub-layer to the ZDO.
   1892           *
   1893           * @param       pData - Incoming Message
   1894           *
   1895           * @return      none
   1896           */
   1897          void ZDP_IncomingData( afIncomingMSGPacket_t *pData )
   1898          {
   1899            uint8 x = 0;
   1900            uint8 handled;
   1901            zdoIncomingMsg_t inMsg;
   1902          
   1903            inMsg.srcAddr.addrMode = Addr16Bit;
   1904            inMsg.srcAddr.addr.shortAddr = pData->srcAddr.addr.shortAddr;
   1905            inMsg.wasBroadcast = pData->wasBroadcast;
   1906            inMsg.clusterID = pData->clusterId;
   1907            inMsg.SecurityUse = pData->SecurityUse;
   1908          
   1909            inMsg.asduLen = pData->cmd.DataLength-1;
   1910            inMsg.asdu = pData->cmd.Data+1;
   1911            inMsg.TransSeq = pData->cmd.Data[0];
   1912            inMsg.macDestAddr = pData->macDestAddr;
   1913          
   1914            handled = ZDO_SendMsgCBs( &inMsg );
   1915          
   1916          #if (defined MT_ZDO_CB_FUNC)
   1917          #if !defined MT_TASK
   1918            if (zgZdoDirectCB)
   1919          #endif
   1920            {
   1921              MT_ZdoDirectCB( pData, &inMsg );
   1922            }
   1923          #endif
   1924          
   1925            while ( zdpMsgProcs[x].clusterID != 0xFFFF )
   1926            {
   1927              if ( zdpMsgProcs[x].clusterID == inMsg.clusterID )
   1928              {
   1929                zdpMsgProcs[x].pFn( &inMsg );
   1930                return;
   1931              }
   1932              x++;
   1933            }
   1934          
   1935            // Handle unhandled messages
   1936            if ( !handled )
   1937              ZDApp_InMsgCB( &inMsg );
   1938          }
   1939          
   1940          /*********************************************************************
   1941          *********************************************************************/
   1942          

Errors: 25
Warnings: 2
