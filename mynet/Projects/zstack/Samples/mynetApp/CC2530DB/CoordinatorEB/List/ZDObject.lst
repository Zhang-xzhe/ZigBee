###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:00 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDObject.c                            #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDObject.c -D ZTOOL_P1 -D MT_TASK -D  #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proj #
#                          ects\zstack\Samples\mynetApp\CC2530DB\CoordinatorE #
#                          B\List\ -lA C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\Coor #
#                          dinatorEB\List\ --diag_suppress Pe001,Pa010 -o     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ZDObject.lst                                    #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ZDObject.r51                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\stack\zdo\ZDObject.c
      1          /**************************************************************************************************
      2            Filename:       ZDObject.c
      3            Revised:        $Date: 2009-12-29 11:40:43 -0800 (Tue, 29 Dec 2009) $
      4            Revision:       $Revision: 21414 $
      5          
      6            Description:    This is the Zigbee Device Object.
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "rtg.h"
     47          #include "NLMEDE.h"
     48          #include "nwk_globals.h"
     49          #include "APS.h"
     50          #include "APSMEDE.h"
     51          #include "AssocList.h"
     52          #include "BindingTable.h"
     53          #include "AddrMgr.h"
     54          #include "AF.h"
     55          #include "ZDObject.h"
     56          #include "ZDProfile.h"
     57          #include "ZDConfig.h"
     58          #include "ZDSecMgr.h"
     59          #include "ZDApp.h"
     60          #include "nwk_util.h"   // NLME_IsAddressBroadcast()
     61          #include "ZGlobals.h"
     62          #if defined MT_ZDO_CB_FUNC
     63          #include "MT.h"
     64          #endif
     65          
     66          #if defined( LCD_SUPPORTED )
     67            #include "OnBoard.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  typedef void (*halUARTCBack_t) (uint8 port, uint8 event);
                                                          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",119  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    halUARTCBack_t      callBackFunc;
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",141  Error[Pe020]: 
          identifier "halUARTCBack_t" is undefined
     68          #endif
     69          
     70          /* HAL */
     71          #include "hal_lcd.h"
     72          
     73          /*********************************************************************
     74           * MACROS
     75           */
     76          
     77          /*********************************************************************
     78           * CONSTANTS
     79           */
     80          // NLME Stub Implementations
     81          #define ZDO_ProcessMgmtPermitJoinTimeout NLME_PermitJoiningTimeout
     82          
     83          // Status fields used by ZDO_ProcessMgmtRtgReq
     84          #define ZDO_MGMT_RTG_ENTRY_ACTIVE             0x00
     85          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY 0x01
     86          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED   0x02
     87          #define ZDO_MGMT_RTG_ENTRY_INACTIVE           0x03
     88          
     89          /*********************************************************************
     90           * TYPEDEFS
     91           */
     92          #if defined ( REFLECTOR )
     93          typedef struct
     94          {
     95            byte SrcTransSeq;
     96            zAddrType_t SrcAddr;
     97            uint16 LocalCoordinator;
     98            byte epIntf;
     99            uint16 ProfileID;
    100            byte numInClusters;
    101            uint16 *inClusters;
    102            byte numOutClusters;
    103            uint16 *outClusters;
    104            byte SecurityUse;
    105            byte status;
    106          } ZDO_EDBind_t;
    107          #endif // defined ( REFLECTOR )
    108          
    109          enum
    110          {
    111            ZDMATCH_INIT,           // Initialized
    112            ZDMATCH_WAIT_REQ,       // Received first request, waiting for second
    113            ZDMATCH_SENDING_BINDS   // Received both requests, sending unbind/binds
    114          };
    115          
    116          enum
    117          {
    118            ZDMATCH_SENDING_NOT,
    119            ZDMATCH_SENDING_UNBIND,
    120            ZDMATCH_SENDING_BIND
    121          };
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */
    138          static uint16 ZDOBuildBuf[26];  // temp area to build data without allocation
    139          
    140          #if defined ( REFLECTOR )
    141          static ZDO_EDBind_t *ZDO_EDBind;     // Null when not used
    142          #endif
    143          
    144          #if defined ( MANAGED_SCAN )
    145            uint32 managedScanNextChannel = 0;
    146            uint32 managedScanChannelMask = 0;
    147            uint8  managedScanTimesPerChannel = 0;
    148          #endif
    149          
    150          ZDMatchEndDeviceBind_t *matchED = (ZDMatchEndDeviceBind_t *)NULL;
    151          
    152          uint32 apsChannelMask = 0;
    153          
    154          /*********************************************************************
    155           * LOCAL FUNCTIONS
    156           */
    157          static void ZDODeviceSetup( void );
    158          #if defined ( MANAGED_SCAN )
    159            static void ZDOManagedScan_Next( void );
    160          #endif
    161          #if defined ( REFLECTOR )
    162            static void ZDO_RemoveEndDeviceBind( void );
    163            static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse );
    164          #endif
    165          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    166                                          byte numList2, uint16 *list2, uint16 *pMatches );
    167          static void ZDO_RemoveMatchMemory( void );
    168          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq );
    169          static void ZDO_EndDeviceBindMatchTimeoutCB( void );
    170          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList );
    171          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId);
    172          
    173          /*********************************************************************
    174           * @fn          ZDO_Init
    175           *
    176           * @brief       ZDObject and ZDProfile initialization.
    177           *
    178           * @param       none
    179           *
    180           * @return      none
    181           */
    182          void ZDO_Init( void )
    183          {
    184            // Initialize ZD items
    185            #if defined ( REFLECTOR )
    186            ZDO_EDBind = NULL;
    187            #endif
    188          
    189            // Initialize default ZDO_UseExtendedPANID to the APS one.
    190            osal_cpyExtAddr( ZDO_UseExtendedPANID, AIB_apsUseExtendedPANID );
    191          
    192            // Setup the device - type of device to create.
    193            ZDODeviceSetup();
    194          }
    195          
    196          #if defined ( MANAGED_SCAN )
    197          /*********************************************************************
    198           * @fn      ZDOManagedScan_Next()
    199           *
    200           * @brief   Setup a managed scan.
    201           *
    202           * @param   none
    203           *
    204           * @return  none
    205           */
    206          static void ZDOManagedScan_Next( void )
    207          {
    208            // Is it the first time
    209            if ( managedScanNextChannel == 0 && managedScanTimesPerChannel == 0 )
    210            {
    211              // Setup the defaults
    212              managedScanNextChannel  = 1;
    213          
    214              while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    215                managedScanNextChannel <<= 1;
    216          
    217              managedScanChannelMask = managedScanNextChannel;
    218              managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    219            }
    220            else
    221            {
    222              // Do we need to go to the next channel
    223              if ( managedScanTimesPerChannel == 0 )
    224              {
    225                // Find next active channel
    226                managedScanChannelMask  = managedScanNextChannel;
    227                managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    228              }
    229              else
    230              {
    231                managedScanTimesPerChannel--;
    232          
    233                if ( managedScanTimesPerChannel == 0 )
    234                {
    235                  managedScanNextChannel  <<= 1;
    236                  while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    237                    managedScanNextChannel <<= 1;
    238          
    239                  if ( managedScanNextChannel == 0 )
    240                    zdoDiscCounter  = NUM_DISC_ATTEMPTS + 1; // Stop
    241                }
    242              }
    243            }
    244          }
    245          #endif // MANAGED_SCAN
    246          
    247          /*********************************************************************
    248           * @fn      ZDODeviceSetup()
    249           *
    250           * @brief   Call set functions depending on the type of device compiled.
    251           *
    252           * @param   none
    253           *
    254           * @return  none
    255           */
    256          static void ZDODeviceSetup( void )
    257          {
    258            if ( ZG_BUILD_COORDINATOR_TYPE )
    259            {
    260              NLME_CoordinatorInit();
    261            }
    262          
    263          #if defined ( REFLECTOR )
    264            APS_ReflectorInit( (ZG_DEVICE_COORDINATOR_TYPE) ? APS_REFLECTOR_PUBLIC :  APS_REFLECTOR_PRIVATE );
    265          #endif
    266          
    267            if ( ZG_BUILD_JOINING_TYPE )
    268            {
    269              NLME_DeviceJoiningInit();
    270            }
    271          }
    272          
    273          /*********************************************************************
    274           * @fn          ZDO_StartDevice
    275           *
    276           * @brief       This function starts a device in a network.
    277           *
    278           * @param       logicalType     - Device type to start
    279           *              startMode       - indicates mode of device startup
    280           *              beaconOrder     - indicates time betwen beacons
    281           *              superframeOrder - indicates length of active superframe
    282           *
    283           * @return      none
    284           */
    285          void ZDO_StartDevice( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )
    286          {
    287            ZStatus_t ret;
    288          #if defined ( ZIGBEE_FREQ_AGILITY )
    289            static uint8 discRetries = 0;
    290          #endif
    291          #if defined ( ZIGBEE_COMMISSIONING )
    292            static uint8 scanCnt = 0;
    293          #endif
    294          
    295            ret = ZUnsupportedMode;
    296          
    297            if ( ZG_BUILD_COORDINATOR_TYPE && logicalType == NODETYPE_COORDINATOR )
    298            {
    299              if ( startMode == MODE_HARD )
    300              {
    301                devState = DEV_COORD_STARTING;
    302                ret = NLME_NetworkFormationRequest( zgConfigPANID, zgApsUseExtendedPANID, zgDefaultChannelList,
    303                                                    zgDefaultStartingScanDuration, beaconOrder,
    304                                                    superframeOrder, false );
    305              }
    306              else if ( startMode == MODE_RESUME )
    307              {
    308                // Just start the coordinator
    309                devState = DEV_COORD_STARTING;
    310                ret = NLME_StartRouterRequest( beaconOrder, beaconOrder, false );
    311              }
    312              else
    313              {
    314          #if defined( LCD_SUPPORTED )
    315                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    316          #endif
    317              }
    318            }
    319          
    320            if ( ZG_BUILD_JOINING_TYPE && (logicalType == NODETYPE_ROUTER || logicalType == NODETYPE_DEVICE) )
    321            {
    322              if ( (startMode == MODE_JOIN) || (startMode == MODE_REJOIN) )
    323              {
    324                devState = DEV_NWK_DISC;
    325          
    326            #if defined( MANAGED_SCAN )
    327                ZDOManagedScan_Next();
    328                ret = NLME_NetworkDiscoveryRequest( managedScanChannelMask, BEACON_ORDER_15_MSEC );
    329            #else
    330                ret = NLME_NetworkDiscoveryRequest( zgDefaultChannelList, zgDefaultStartingScanDuration );
    331              #if defined ( ZIGBEE_FREQ_AGILITY )
    332                if ( !( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE ) &&
    333                      ( ret == ZSuccess ) && ( ++discRetries == 4 ) )
    334                {
    335                  // For devices with RxOnWhenIdle equals to FALSE, any network channel
    336                  // change will not be recieved. On these devices or routers that have
    337                  // lost the network, an active scan shall be conducted on the Default
    338                  // Channel list using the extended PANID to find the network. If the
    339                  // extended PANID isn't found using the Default Channel list, an scan
    340                  // should be completed using all channels.
    341                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
    342                }
    343              #endif // ZIGBEE_FREQ_AGILITY
    344              #if defined ( ZIGBEE_COMMISSIONING )
    345                if (startMode == MODE_REJOIN && scanCnt++ >= 5 )
    346                {
    347                  // When ApsUseExtendedPanID is commissioned to a non zero value via
    348                  // application specific means, the device shall conduct an active scan
    349                  // on the Default Channel list and join the PAN with the same
    350                  // ExtendedPanID. If the PAN is not found, an scan should be completed
    351                  // on all channels.
    352                  // When devices rejoin the network and the PAN is not found from
    353                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
    354                }
    355              #endif // ZIGBEE_COMMISSIONING
    356            #endif
    357              }
    358              else if ( startMode == MODE_RESUME )
    359              {
    360                if ( logicalType == NODETYPE_ROUTER )
    361                {
    362                  ZMacScanCnf_t scanCnf;
    363                  devState = DEV_NWK_ORPHAN;
    364          
    365                  /* if router and nvram is available, fake successful orphan scan */
    366                  scanCnf.hdr.Status = ZSUCCESS;
    367                  scanCnf.ScanType = ZMAC_ORPHAN_SCAN;
    368                  scanCnf.UnscannedChannels = 0;
    369                  scanCnf.ResultListSize = 0;
    370                  nwk_ScanJoiningOrphan(&scanCnf);
    371          
    372                  ret = ZSuccess;
    373                }
    374                else
    375                {
    376                  devState = DEV_NWK_ORPHAN;
    377                  ret = NLME_OrphanJoinRequest( zgDefaultChannelList,
    378                                                zgDefaultStartingScanDuration );
    379                }
    380              }
    381              else
    382              {
    383          #if defined( LCD_SUPPORTED )
    384                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    385          #endif
    386              }
    387            }
    388          
    389            if ( ret != ZSuccess )
    390              osal_start_timerEx(ZDAppTaskID, ZDO_NETWORK_INIT, NWK_RETRY_DELAY );
    391          }
    392          
    393          /**************************************************************************************************
    394           * @fn          zdoSendStateChangeMsg
    395           *
    396           * @brief       Helper function for ZDO_UpdateNwkStatus.
    397           *
    398           * input parameters
    399           *
    400           * @param       taskId - The OSAL task identifier to which to send the ZDO_STATE_CHANGE_EVT.
    401           * @param       state - The current device state.
    402           *
    403           * output parameters
    404           *
    405           * None.
    406           *
    407           * @return      None.
    408           **************************************************************************************************
    409           */
    410          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId)
    411          {
    412            osal_event_hdr_t *pMsg = (osal_event_hdr_t *)osal_msg_find(taskId, ZDO_STATE_CHANGE);
    413          
    414            if (NULL == pMsg)
    415            {
    416              if (NULL == (pMsg = (osal_event_hdr_t *)osal_msg_allocate(sizeof(osal_event_hdr_t))))
    417              {
    418                // Upon failure to notify any EndPoint of the state change, re-set the ZDO event to
    419                // try again later when more Heap may be available.
    420                osal_set_event(ZDAppTaskID, ZDO_STATE_CHANGE_EVT);
    421              }
    422              else
    423              {
    424                pMsg->event = ZDO_STATE_CHANGE;
    425                pMsg->status = state;
    426          
    427                (void)osal_msg_send(taskId, (uint8 *)pMsg);
    428              }
    429            }
    430            else
    431            {
    432              // Modify in place the status of an existing ZDO_STATE_CHANGE message to the EndPoint.
    433              pMsg->status = state;
    434            }
    435          }
    436          
    437          /**************************************************************************************************
    438           * @fn          ZDO_UpdateNwkStatus
    439           *
    440           * @brief       This function sends a ZDO_STATE_CHANGE message to the task of every EndPoint
    441           *              registered with AF (except, of course, the ZDO_EP). Even if a single task has more
    442           *              than one registered EndPoint, it will only receive one notification per state
    443           *              change. Although the device may go through a sequence of state changes, the
    444           *              Application task may only receive notification of the final, steady-state state
    445           *              because it has the lowest priority and never even runs to receive the intermediate
    446           *              state change notifications.
    447           *
    448           * input parameters
    449           *
    450           * @param       state - The current device state.
    451           *
    452           * output parameters
    453           *
    454           * None.
    455           *
    456           * @return      None.
    457           **************************************************************************************************
    458           */
    459          void ZDO_UpdateNwkStatus(devStates_t state)
    460          {
    461            epList_t *pItem = epList;
    462          
    463            while (pItem != NULL)
    464            {
    465              if (pItem->epDesc->endPoint != ZDO_EP)
    466              {
    467                zdoSendStateChangeMsg(state, *(pItem->epDesc->task_id));
    468              }
    469          
    470              pItem = pItem->nextDesc;
    471            }
    472          #if defined MT_ZDO_CB_FUNC
    473            zdoSendStateChangeMsg(state, MT_TaskID);
    474          #endif
    475          
    476            ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
    477            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
    478          }
    479          
    480          #if defined ( REFLECTOR )
    481          /*********************************************************************
    482           * @fn          ZDO_RemoveEndDeviceBind
    483           *
    484           * @brief       Remove the end device bind
    485           *
    486           * @param  none
    487           *
    488           * @return      none
    489           */
    490          static void ZDO_RemoveEndDeviceBind( void )
    491          {
    492            if ( ZDO_EDBind != NULL )
    493            {
    494              // Free the RAM
    495              if ( ZDO_EDBind->inClusters != NULL )
    496                osal_mem_free( ZDO_EDBind->inClusters );
    497              if ( ZDO_EDBind->outClusters != NULL )
    498                osal_mem_free( ZDO_EDBind->outClusters );
    499              osal_mem_free( ZDO_EDBind );
    500              ZDO_EDBind = NULL;
    501            }
    502          }
    503          #endif // REFLECTOR
    504          
    505          #if defined ( REFLECTOR )
    506          /*********************************************************************
    507           * @fn          ZDO_RemoveEndDeviceBind
    508           *
    509           * @brief       Remove the end device bind
    510           *
    511           * @param  none
    512           *
    513           * @return      none
    514           */
    515          static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse )
    516          {
    517            ZDP_EndDeviceBindRsp( TransSeq, dstAddr, Status, secUse );
    518          
    519          #if defined( LCD_SUPPORTED )
    520            HalLcdWriteString( "End Device Bind", HAL_LCD_LINE_1 );
    521            if ( Status == ZDP_SUCCESS )
    522              HalLcdWriteString( "Success Sent", HAL_LCD_LINE_2 );
    523            else
    524              HalLcdWriteString( "Timeout", HAL_LCD_LINE_2 );
    525          #endif
    526          
    527          }
    528          #endif // REFLECTOR
    529          
    530          /*********************************************************************
    531           * @fn          ZDO_CompareClusterLists
    532           *
    533           * @brief       Compare one list to another list
    534           *
    535           * @param       numList1 - number of items in list 1
    536           * @param       list1 - first list of cluster IDs
    537           * @param       numList2 - number of items in list 2
    538           * @param       list2 - second list of cluster IDs
    539           * @param       pMatches - buffer to put matches
    540           *
    541           * @return      number of matches
    542           */
    543          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    544                                    byte numList2, uint16 *list2, uint16 *pMatches )
    545          {
    546            byte x, y;
    547            uint16 z;
    548            byte numMatches = 0;
    549          
    550            // Check the first in against the seconds out
    551            for ( x = 0; x < numList1; x++ )
    552            {
    553              for ( y = 0; y < numList2; y++ )
    554              {
    555                z = list2[y];
    556                if ( list1[x] == z )
    557                  pMatches[numMatches++] = z;
    558              }
    559            }
    560          
    561            return ( numMatches );
    562          }
    563          
    564          /*********************************************************************
    565           * Utility functions
    566           */
    567          
    568          /*********************************************************************
    569           * @fn          ZDO_CompareByteLists
    570           *
    571           * @brief       Compares two lists for matches.
    572           *
    573           * @param       ACnt  - number of entries in list A
    574           * @param       AList  - List A
    575           * @param       BCnt  - number of entries in list B
    576           * @param       BList  - List B
    577           *
    578           * @return      true if a match is found
    579           */
    580          byte ZDO_AnyClusterMatches( byte ACnt, uint16 *AList, byte BCnt, uint16 *BList )
    581          {
    582            byte x, y;
    583          
    584            for ( x = 0; x < ACnt; x++ )
    585            {
    586              for ( y = 0; y < BCnt; y++ )
    587              {
    588                if ( AList[x] == BList[y] )
    589                {
    590                  return true;
    591                }
    592              }
    593            }
    594          
    595            return false;
    596          }
    597          
    598          /*********************************************************************
    599           * Callback functions from ZDProfile
    600           */
    601          
    602          /*********************************************************************
    603           * @fn          ZDO_ProcessNodeDescReq
    604           *
    605           * @brief       This function processes and responds to the
    606           *              Node_Desc_req message.
    607           *
    608           * @param       inMsg - incoming message
    609           *
    610           * @return      none
    611           */
    612          void ZDO_ProcessNodeDescReq( zdoIncomingMsg_t *inMsg )
    613          {
    614            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    615            NodeDescriptorFormat_t *desc = NULL;
    616          
    617            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    618            {
    619              desc = &ZDO_Config_Node_Descriptor;
    620            }
    621          
    622            if ( desc != NULL )
    623            {
    624              ZDP_NodeDescMsg( inMsg, aoi, desc );
    625            }
    626            else
    627            {
    628              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    629                        ZDP_INVALID_REQTYPE, aoi, Node_Desc_rsp, inMsg->SecurityUse );
    630            }
    631          }
    632          
    633          /*********************************************************************
    634           * @fn          ZDO_ProcessPowerDescReq
    635           *
    636           * @brief       This function processes and responds to the
    637           *              Node_Power_req message.
    638           *
    639           * @param       inMsg  - incoming request
    640           *
    641           * @return      none
    642           */
    643          void ZDO_ProcessPowerDescReq( zdoIncomingMsg_t *inMsg )
    644          {
    645            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    646            NodePowerDescriptorFormat_t *desc = NULL;
    647          
    648            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    649            {
    650              desc = &ZDO_Config_Power_Descriptor;
    651            }
    652          
    653            if ( desc != NULL )
    654            {
    655              ZDP_PowerDescMsg( inMsg, aoi, desc );
    656            }
    657            else
    658            {
    659              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    660                        ZDP_INVALID_REQTYPE, aoi, Power_Desc_rsp, inMsg->SecurityUse );
    661            }
    662          }
    663          
    664          /*********************************************************************
    665           * @fn          ZDO_ProcessSimpleDescReq
    666           *
    667           * @brief       This function processes and responds to the
    668           *              Simple_Desc_req message.
    669           *
    670           * @param       inMsg - incoming message (request)
    671           *
    672           * @return      none
    673           */
    674          void ZDO_ProcessSimpleDescReq( zdoIncomingMsg_t *inMsg )
    675          {
    676            SimpleDescriptionFormat_t *sDesc = NULL;
    677            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    678            byte endPoint = inMsg->asdu[2];
    679            byte free = false;
    680            byte stat = ZDP_SUCCESS;
    681          
    682            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
    683            {
    684              stat = ZDP_INVALID_EP;
    685            }
    686            else if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    687            {
    688              free = afFindSimpleDesc( &sDesc, endPoint );
    689              if ( sDesc == NULL )
    690              {
    691                stat = ZDP_NOT_ACTIVE;
    692              }
    693            }
    694            else
    695            {
    696              if ( ZSTACK_ROUTER_BUILD )
    697              {
    698                stat = ZDP_DEVICE_NOT_FOUND;
    699              }
    700              else if ( ZSTACK_END_DEVICE_BUILD )
    701              {
    702                stat = ZDP_INVALID_REQTYPE;
    703              }
    704            }
    705          
    706            ZDP_SimpleDescMsg( inMsg, stat, sDesc );
    707          
    708            if ( free && sDesc )
    709            {
    710              osal_mem_free( sDesc );
    711            }
    712          }
    713          
    714          /*********************************************************************
    715           * @fn          ZDO_ProcessActiveEPReq
    716           *
    717           * @brief       This function processes and responds to the
    718           *              Active_EP_req message.
    719           *
    720           * @param       inMsg  - incoming message (request)
    721           *
    722           * @return      none
    723           */
    724          void ZDO_ProcessActiveEPReq( zdoIncomingMsg_t *inMsg )
    725          {
    726            byte cnt = 0;
    727            uint16 aoi;
    728            byte stat = ZDP_SUCCESS;
    729          
    730            aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    731          
    732            if ( aoi == NLME_GetShortAddr() )
    733            {
    734              cnt = afNumEndPoints() - 1;  // -1 for ZDO endpoint descriptor
    735              afEndPoints( (uint8 *)ZDOBuildBuf, true );
    736            }
    737            else
    738            {
    739              stat = ZDP_INVALID_REQTYPE;
    740            }
    741          
    742            ZDP_ActiveEPRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat,
    743                            aoi, cnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse );
    744          }
    745          
    746          /*********************************************************************
    747           * @fn          ZDO_ConvertOTAClusters
    748           *
    749           * @brief       This function will convert the over-the-air cluster list
    750           *              format to an internal format.
    751           *
    752           * @param       inMsg  - incoming message (request)
    753           *
    754           * @return      pointer to incremented inBuf
    755           */
    756          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList )
    757          {
    758            uint8 x;
    759          
    760            for ( x = 0; x < cnt; x++ )
    761            {
    762              // convert ota format to internal
    763              outList[x] = BUILD_UINT16( inBuf[0], inBuf[1] );
    764              inBuf += sizeof( uint16 );
    765            }
    766            return ( inBuf );
    767          }
    768          
    769          /*********************************************************************
    770           * @fn          ZDO_ProcessMatchDescReq
    771           *
    772           * @brief       This function processes and responds to the
    773           *              Match_Desc_req message.
    774           *
    775           * @param       inMsg  - incoming message (request)
    776           *
    777           * @return      none
    778           */
    779          void ZDO_ProcessMatchDescReq( zdoIncomingMsg_t *inMsg )
    780          {
    781            uint8 epCnt = 0;
    782            uint8 numInClusters;
    783            uint16 *inClusters = NULL;
    784            uint8 numOutClusters;
    785            uint16 *outClusters = NULL;
    786            epList_t *epDesc;
    787            SimpleDescriptionFormat_t *sDesc = NULL;
    788            uint8 allocated;
    789            uint8 *msg;
    790            uint16 aoi;
    791            uint16 profileID;
    792          
    793            // Parse the incoming message
    794            msg = inMsg->asdu;
    795            aoi = BUILD_UINT16( msg[0], msg[1] );
    796            profileID = BUILD_UINT16( msg[2], msg[3] );
    797            msg += 4;
    798          
    799            if ( ADDR_BCAST_NOT_ME == NLME_IsAddressBroadcast(aoi) )
    800            {
    801              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    802                                    ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
    803              return;
    804            }
    805            else if ( (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi)) && (aoi != ZDAppNwkAddr.addr.shortAddr) )
    806            {
    807              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    808                                       ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
    809              return;
    810            }
    811          
    812            if ((numInClusters = *msg++) &&
    813                (inClusters = (uint16*)osal_mem_alloc( numInClusters * sizeof( uint16 ) )))
    814            {
    815              msg = ZDO_ConvertOTAClusters( numInClusters, msg, inClusters );
    816            }
    817            else
    818            {
    819              numInClusters = 0;
    820            }
    821          
    822            if ((numOutClusters = *msg++) &&
    823                (outClusters = (uint16 *)osal_mem_alloc( numOutClusters * sizeof( uint16 ) )))
    824            {
    825              msg = ZDO_ConvertOTAClusters( numOutClusters, msg, outClusters );
    826            }
    827            else
    828            {
    829              numOutClusters = 0;
    830            }
    831          
    832            // First count the number of endpoints that match.
    833            epDesc = epList;
    834            while ( epDesc )
    835            {
    836              // Don't search endpoint 0 and check if response is allowed
    837              if ( epDesc->epDesc->endPoint != ZDO_EP && (epDesc->flags&eEP_AllowMatch) )
    838              {
    839                if ( epDesc->pfnDescCB )
    840                {
    841                  sDesc = (SimpleDescriptionFormat_t *)epDesc->pfnDescCB( AF_DESCRIPTOR_SIMPLE, epDesc->epDesc->endPoint );
    842                  allocated = TRUE;
    843                }
    844                else
    845                {
    846                  sDesc = epDesc->epDesc->simpleDesc;
    847                  allocated = FALSE;
    848                }
    849          
    850                if ( sDesc && sDesc->AppProfId == profileID )
    851                {
    852                  uint8 *uint8Buf = (uint8 *)ZDOBuildBuf;
    853          
    854                  // If there are no search input/ouput clusters - respond
    855                  if ( ((numInClusters == 0) && (numOutClusters == 0))
    856                      // Are there matching input clusters?
    857                       || (ZDO_AnyClusterMatches( numInClusters, inClusters,
    858                            sDesc->AppNumInClusters, sDesc->pAppInClusterList ))
    859                      // Are there matching output clusters?
    860                       || (ZDO_AnyClusterMatches( numOutClusters, outClusters,
    861                            sDesc->AppNumOutClusters, sDesc->pAppOutClusterList ))     )
    862                  {
    863                    // Notify the endpoint of the match.
    864                    uint8 bufLen = sizeof( ZDO_MatchDescRspSent_t ) + (numOutClusters + numInClusters) * sizeof(uint16);
    865                    ZDO_MatchDescRspSent_t *pRspSent = (ZDO_MatchDescRspSent_t *) osal_msg_allocate( bufLen );
    866          
    867                    if (pRspSent)
    868                    {
    869                      pRspSent->hdr.event = ZDO_MATCH_DESC_RSP_SENT;
    870                      pRspSent->nwkAddr = inMsg->srcAddr.addr.shortAddr;
    871                      pRspSent->numInClusters = numInClusters;
    872                      pRspSent->numOutClusters = numOutClusters;
    873          
    874                      if (numInClusters)
    875                      {
    876                        pRspSent->pInClusters = (uint16*) (pRspSent + 1);
    877                        osal_memcpy(pRspSent->pInClusters, inClusters, numInClusters * sizeof(uint16));
    878                      }
    879                      else
    880                      {
    881                        pRspSent->pInClusters = NULL;
    882                      }
    883          
    884                      if (numOutClusters)
    885                      {
    886                        pRspSent->pOutClusters = (uint16*)(pRspSent + 1) + numInClusters;
    887                        osal_memcpy(pRspSent->pOutClusters, outClusters, numOutClusters * sizeof(uint16));
    888                      }
    889                      else
    890                      {
    891                        pRspSent->pOutClusters = NULL;
    892                      }
    893          
    894                      osal_msg_send( *epDesc->epDesc->task_id, (uint8 *)pRspSent );
    895                    }
    896          
    897                    uint8Buf[epCnt++] = sDesc->EndPoint;
    898                  }
    899                }
    900          
    901                if ( allocated )
    902                  osal_mem_free( sDesc );
    903              }
    904              epDesc = epDesc->nextDesc;
    905            }
    906          
    907            // Send the message only if at least one match found.
    908            if ( epCnt )
    909            {
    910              if ( ZSuccess == ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_SUCCESS,
    911                        ZDAppNwkAddr.addr.shortAddr, epCnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse ) )
    912              {
    913          #if defined( LCD_SUPPORTED )
    914                HalLcdWriteScreen( "Match Desc Req", "Rsp Sent" );
    915          #endif
    916              }
    917            }
    918            else
    919            {
    920          #if defined( LCD_SUPPORTED )
    921              HalLcdWriteScreen( "Match Desc Req", "Non Matched" );
    922          #endif
    923            }
    924          
    925            if ( inClusters != NULL )
    926              osal_mem_free( inClusters );
    927            if ( outClusters != NULL )
    928              osal_mem_free( outClusters );
    929          }
    930          
    931          
    932          /*********************************************************************
    933           * @fn      ZDO_ProcessBindUnbindReq()
    934           *
    935           * @brief   Called to process a Bind or Unbind Request message.
    936           *
    937           * @param   inMsg  - incoming message (request)
    938           * @param   pReq - place to put parsed information
    939           *
    940           * @return  none
    941           */
    942          void ZDO_ProcessBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
    943          {
    944            zAddrType_t SourceAddr;       // Binding Source addres
    945            byte bindStat;
    946          
    947            SourceAddr.addrMode = Addr64Bit;
    948            osal_cpyExtAddr( SourceAddr.addr.extAddr, pReq->srcAddress );
    949          
    950          
    951            // If the local device is not the primary binding cache
    952            // check the src address of the bind request.
    953            // If it is not the local device's extended address
    954            // discard the request.
    955            if ( !osal_ExtAddrEqual( SourceAddr.addr.extAddr, NLME_GetExtAddr()) ||
    956                  (pReq->dstAddress.addrMode != Addr64Bit &&
    957                   pReq->dstAddress.addrMode != AddrGroup) )
    958            {
    959              bindStat = ZDP_NOT_SUPPORTED;
    960            }
    961            else
    962            {
    963              // Check source & destination endpoints
    964              if ( (pReq->srcEndpoint == 0 || pReq->srcEndpoint > MAX_ENDPOINTS)
    965                  || (( pReq->dstAddress.addrMode == Addr64Bit ) &&
    966                      (pReq->dstEndpoint == 0 || pReq->dstEndpoint > MAX_ENDPOINTS)) )
    967              {
    968                bindStat = ZDP_INVALID_EP;
    969              }
    970              else
    971              {
    972                if ( inMsg->clusterID == Bind_req )
    973                {
    974                  // Assume the table is full
    975                  bindStat = ZDP_TABLE_FULL;
    976          
    977                  if ( bindNumOfEntries() < gNWK_MAX_BINDING_ENTRIES )
    978                  {
    979                    if ( APSME_BindRequest( pReq->srcEndpoint, pReq->clusterID,
    980                                   &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
    981                    {
    982                      uint16 nwkAddr;
    983          
    984                      // valid entry
    985                      bindStat = ZDP_SUCCESS;
    986          
    987                      // Notify to save info into NV
    988                      ZDApp_NVUpdate();
    989          
    990                      // Check for the destination address
    991                      if ( pReq->dstAddress.addrMode == Addr64Bit )
    992                      {
    993                        if ( APSME_LookupNwkAddr( pReq->dstAddress.addr.extAddr, &nwkAddr ) == FALSE )
    994                        {
    995                          ZDP_NwkAddrReq( pReq->dstAddress.addr.extAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
    996                        }
    997                      }
    998                    }
    999                  }
   1000                }
   1001                else // Unbind_req
   1002                {
   1003                  if ( APSME_UnBindRequest( pReq->srcEndpoint, pReq->clusterID,
   1004                                 &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
   1005                  {
   1006                    bindStat = ZDP_SUCCESS;
   1007          
   1008                    // Notify to save info into NV
   1009                    ZDApp_NVUpdate();
   1010                  }
   1011                  else
   1012                    bindStat = ZDP_NO_ENTRY;
   1013                }
   1014              }
   1015            }
   1016          
   1017            // Send back a response message
   1018            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr),
   1019                         (inMsg->clusterID | ZDO_RESPONSE_BIT), 1, &bindStat,
   1020                         inMsg->SecurityUse );
   1021          }
   1022          
   1023          /*********************************************************************
   1024           * @fn      ZDO_UpdateAddrManager
   1025           *
   1026           * @brief   Update the Address Manager.
   1027           *
   1028           * @param   nwkAddr - network address
   1029           * @param   extAddr - extended address
   1030           *
   1031           * @return  none
   1032           */
   1033          void ZDO_UpdateAddrManager( uint16 nwkAddr, uint8 *extAddr )
   1034          {
   1035            AddrMgrEntry_t addrEntry;
   1036          
   1037            // Update the address manager
   1038            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1039            addrEntry.nwkAddr = nwkAddr;
   1040            AddrMgrExtAddrSet( addrEntry.extAddr, extAddr );
   1041            AddrMgrEntryUpdate( &addrEntry );
   1042          }
   1043          
   1044          /*********************************************************************
   1045           * @fn      ZDO_ProcessServerDiscReq
   1046           *
   1047           * @brief   Process the Server_Discovery_req message.
   1048           *
   1049           * @param   inMsg  - incoming message (request)
   1050           *
   1051           * @return  none
   1052           */
   1053          void ZDO_ProcessServerDiscReq( zdoIncomingMsg_t *inMsg )
   1054          {
   1055            uint16 serverMask = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   1056            uint16 matchMask = serverMask & ZDO_Config_Node_Descriptor.ServerMask;
   1057          
   1058            if ( matchMask )
   1059            {
   1060              ZDP_ServerDiscRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSUCCESS,
   1061                          ZDAppNwkAddr.addr.shortAddr, matchMask, inMsg->SecurityUse );
   1062            }
   1063          }
   1064          
   1065          /*********************************************************************
   1066           * Call Back Functions from APS  - API
   1067           */
   1068          
   1069          /*********************************************************************
   1070           * @fn          ZDO_EndDeviceTimeoutCB
   1071           *
   1072           * @brief       This function handles the binding timer for the End
   1073           *              Device Bind command.
   1074           *
   1075           * @param       none
   1076           *
   1077           * @return      none
   1078           */
   1079          void ZDO_EndDeviceTimeoutCB( void )
   1080          {
   1081          #if defined ( REFLECTOR )
   1082            byte stat;
   1083            if ( ZDO_EDBind )
   1084            {
   1085              stat = ZDO_EDBind->status;
   1086          
   1087              // Send the response message to the first sent
   1088              ZDO_SendEDBindRsp( ZDO_EDBind->SrcTransSeq, &(ZDO_EDBind->SrcAddr),
   1089                                  stat, ZDO_EDBind->SecurityUse );
   1090          
   1091              ZDO_RemoveEndDeviceBind();
   1092            }
   1093          #endif  // REFLECTOR
   1094          }
   1095          
   1096          /*********************************************************************
   1097           * Optional Management Messages
   1098           */
   1099          
   1100          /*********************************************************************
   1101           * @fn          ZDO_ProcessMgmtLqiReq
   1102           *
   1103           * @brief       This function handles parsing the incoming Management
   1104           *              LQI request and generate the response.
   1105           *
   1106           *   Note:      This function will limit the number of items returned
   1107           *              to ZDO_MAX_LQI_ITEMS items.
   1108           *
   1109           * @param       inMsg - incoming message (request)
   1110           *
   1111           * @return      none
   1112           */
   1113          void ZDO_ProcessMgmtLqiReq( zdoIncomingMsg_t *inMsg )
   1114          {
   1115            byte x;
   1116            byte index;
   1117            byte numItems;
   1118            byte maxItems;
   1119            ZDP_MgmtLqiItem_t* table = NULL;
   1120            ZDP_MgmtLqiItem_t* item;
   1121            neighborEntry_t    entry;
   1122            byte aItems;
   1123            associated_devices_t *aDevice;
   1124            AddrMgrEntry_t  nwkEntry;
   1125            uint8 StartIndex = inMsg->asdu[0];
   1126          
   1127            // Get the number of neighbor items
   1128            NLME_GetRequest( nwkNumNeighborTableEntries, 0, &maxItems );
   1129          
   1130            // Get the number of associated items
   1131            aItems = (uint8)AssocCount( PARENT, CHILD_FFD_RX_IDLE );
   1132          
   1133            // Total number of items
   1134            maxItems += aItems;
   1135          
   1136            // Start with the supplied index
   1137            if ( maxItems > StartIndex )
   1138            {
   1139              numItems = maxItems - StartIndex;
   1140          
   1141              // limit the size of the list
   1142              if ( numItems > ZDO_MAX_LQI_ITEMS )
   1143                numItems = ZDO_MAX_LQI_ITEMS;
   1144          
   1145              // Allocate the memory to build the table
   1146              table = (ZDP_MgmtLqiItem_t*)osal_mem_alloc( (short)
   1147                        ( numItems * sizeof( ZDP_MgmtLqiItem_t ) ) );
   1148          
   1149              if ( table != NULL )
   1150              {
   1151                x = 0;
   1152                item = table;
   1153                index = StartIndex;
   1154          
   1155                // Loop through associated items and build list
   1156                for ( ; x < numItems; x++ )
   1157                {
   1158                  if ( index < aItems )
   1159                  {
   1160                    // get next associated device
   1161                    aDevice = AssocFindDevice( index++ );
   1162          
   1163                    // set basic fields
   1164                    item->panID   = _NIB.nwkPanId;
   1165                    osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1166                    item->nwkAddr = aDevice->shortAddr;
   1167                    item->permit  = ZDP_MGMT_BOOL_UNKNOWN;
   1168                    item->depth   = 0xFF;
   1169                    item->lqi     = aDevice->linkInfo.rxLqi;
   1170          
   1171                    // set extented address
   1172                    nwkEntry.user    = ADDRMGR_USER_DEFAULT;
   1173                    nwkEntry.nwkAddr = aDevice->shortAddr;
   1174          
   1175                    if ( AddrMgrEntryLookupNwk( &nwkEntry ) == TRUE )
   1176                    {
   1177                      osal_cpyExtAddr( item->extAddr, nwkEntry.extAddr );
   1178                    }
   1179                    else
   1180                    {
   1181                      osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   1182                    }
   1183          
   1184                    // use association info to set other fields
   1185                    if ( aDevice->nodeRelation == PARENT )
   1186                    {
   1187                      if (  aDevice->shortAddr == 0 )
   1188                      {
   1189                        item->devType = ZDP_MGMT_DT_COORD;
   1190                        item->depth = 0;
   1191                      }
   1192                      else
   1193                      {
   1194                        item->devType = ZDP_MGMT_DT_ROUTER;
   1195                        item->depth = _NIB.nodeDepth - 1;
   1196                      }
   1197          
   1198                      item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1199                      item->relation = ZDP_MGMT_REL_PARENT;
   1200                    }
   1201                    else
   1202                    {
   1203                      // If not parent, then it's a child
   1204                      item->depth = _NIB.nodeDepth + 1;
   1205          
   1206                      if ( aDevice->nodeRelation < CHILD_FFD )
   1207                      {
   1208                        item->devType = ZDP_MGMT_DT_ENDDEV;
   1209          
   1210                        if ( aDevice->nodeRelation == CHILD_RFD )
   1211                        {
   1212                          item->rxOnIdle = FALSE;
   1213                        }
   1214                        else
   1215                        {
   1216                          item->rxOnIdle = TRUE;
   1217                        }
   1218                      }
   1219                      else
   1220                      {
   1221                        item->devType = ZDP_MGMT_DT_ROUTER;
   1222          
   1223                        if ( aDevice->nodeRelation == CHILD_FFD )
   1224                        {
   1225                          item->rxOnIdle = FALSE;
   1226                        }
   1227                        else
   1228                        {
   1229                          item->rxOnIdle = TRUE;
   1230                        }
   1231                      }
   1232          
   1233                      item->relation = ZDP_MGMT_REL_CHILD;
   1234                    }
   1235          
   1236                    item++;
   1237                  }
   1238                  else
   1239                  {
   1240                    if ( StartIndex <= aItems )
   1241                      // Start with 1st neighbor
   1242                      index = 0;
   1243                    else
   1244                      // Start with >1st neighbor
   1245                      index = StartIndex - aItems;
   1246                    break;
   1247                  }
   1248                }
   1249          
   1250                // Loop through neighbor items and finish list
   1251                for ( ; x < numItems; x++ )
   1252                {
   1253                  // Add next neighbor table item
   1254                  NLME_GetRequest( nwkNeighborTable, index++, &entry );
   1255          
   1256                  // set ZDP_MgmtLqiItem_t fields
   1257                  item->panID    = entry.panId;
   1258                  osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1259                  osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   1260                  item->nwkAddr  = entry.neighborAddress;
   1261                  item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1262                  item->relation = ZDP_MGMT_REL_UNKNOWN;
   1263                  item->permit   = ZDP_MGMT_BOOL_UNKNOWN;
   1264                  item->depth    = 0xFF;
   1265                  item->lqi      = entry.linkInfo.rxLqi;
   1266          
   1267                  if ( item->nwkAddr == 0 )
   1268                  {
   1269                    item->devType = ZDP_MGMT_DT_COORD;
   1270                  }
   1271                  else
   1272                  {
   1273                    item->devType = ZDP_MGMT_DT_ROUTER;
   1274                  }
   1275          
   1276                  item++;
   1277                }
   1278              }
   1279            }
   1280            else
   1281            {
   1282              numItems = 0;
   1283            }
   1284          
   1285            // Send response
   1286            ZDP_MgmtLqiRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxItems,
   1287                            StartIndex, numItems, table, false );
   1288          
   1289            if ( table )
   1290            {
   1291              osal_mem_free( table );
   1292            }
   1293          }
   1294          
   1295          /*********************************************************************
   1296           * @fn          ZDO_ProcessMgmtNwkDiscReq
   1297           *
   1298           * @brief       This function handles parsing the incoming Management
   1299           *              Network Discover request and starts the request.
   1300           *
   1301           * @param       inMsg - incoming message (request)
   1302           *
   1303           * @return      none
   1304           */
   1305          void ZDO_ProcessMgmtNwkDiscReq( zdoIncomingMsg_t *inMsg )
   1306          {
   1307            NLME_ScanFields_t scan;
   1308            uint8             index;
   1309            uint8             *msg;
   1310          
   1311            msg = inMsg->asdu;
   1312            scan.channels = osal_build_uint32( msg, 4 );
   1313            msg += 4;
   1314            scan.duration = *msg++;
   1315            index         = *msg;
   1316            scan.scanType = ZMAC_ACTIVE_SCAN;
   1317            scan.scanApp  = NLME_DISC_SCAN;
   1318          
   1319            // Save off the information to be used for the response
   1320            zdappMgmtNwkDiscReqInProgress          = true;
   1321            zdappMgmtNwkDiscRspAddr.addrMode       = Addr16Bit;
   1322            zdappMgmtNwkDiscRspAddr.addr.shortAddr = inMsg->srcAddr.addr.shortAddr;
   1323            zdappMgmtNwkDiscStartIndex             = index;
   1324            zdappMgmtNwkDiscRspTransSeq            = inMsg->TransSeq;
   1325          
   1326            if ( NLME_NwkDiscReq2( &scan ) != ZSuccess )
   1327            {
   1328              NLME_NwkDiscTerm();
   1329          
   1330              // zdappMgmtNwkDiscReqInProgress will be reset in the confirm callback
   1331            }
   1332          }
   1333          
   1334          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1335          /*********************************************************************
   1336           * @fn          ZDO_FinishProcessingMgmtNwkDiscReq
   1337           *
   1338           * @brief       This function finishes the processing of the Management
   1339           *              Network Discover Request and generates the response.
   1340           *
   1341           *   Note:      This function will limit the number of items returned
   1342           *              to ZDO_MAX_NWKDISC_ITEMS items.
   1343           *
   1344           * @param       ResultCountSrcAddr - source of the request
   1345           * @param       msg - pointer to incoming message
   1346           * @param       SecurityUse -
   1347           *
   1348           * @return      none
   1349           */
   1350          void ZDO_FinishProcessingMgmtNwkDiscReq( byte ResultCount,
   1351                                                   networkDesc_t *NetworkList )
   1352          {
   1353            byte count, i;
   1354            networkDesc_t *newDesc = NULL, *pList = NetworkList;
   1355          
   1356            if ( ZSTACK_ROUTER_BUILD )
   1357            {
   1358              // Look for my PanID.
   1359              while ( pList )
   1360              {
   1361                if ( pList->panId == _NIB.nwkPanId )
   1362                {
   1363                  break;
   1364                }
   1365          
   1366          
   1367                if ( !pList->nextDesc )
   1368                {
   1369                  break;
   1370                }
   1371                pList = pList->nextDesc;
   1372              }
   1373          
   1374          
   1375              // If my Pan not present (query to a star network ZC or an isolated ZR?),
   1376              // prepend it.
   1377              if ( !pList || (pList->panId != _NIB.nwkPanId) )
   1378              {
   1379                newDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
   1380                if ( newDesc )
   1381                {
   1382                  byte pJoin;
   1383          
   1384                  newDesc->panId = _NIB.nwkPanId;
   1385                  newDesc->logicalChannel = _NIB.nwkLogicalChannel;
   1386                  newDesc->beaconOrder = _NIB.beaconOrder;
   1387                  newDesc->superFrameOrder = _NIB.superFrameOrder;
   1388                  newDesc->version = NLME_GetProtocolVersion();
   1389                  newDesc->stackProfile = zgStackProfile;
   1390                  //Extended PanID
   1391                  osal_cpyExtAddr( newDesc->extendedPANID, _NIB.extendedPANID);
   1392          
   1393                  ZMacGetReq( ZMacAssociationPermit, &pJoin );
   1394                  newDesc->chosenRouter = ((pJoin) ? ZDAppNwkAddr.addr.shortAddr :
   1395                                                     INVALID_NODE_ADDR);
   1396          
   1397                  newDesc->nextDesc = NetworkList;
   1398                  NetworkList = newDesc;
   1399                  ResultCount++;
   1400                }
   1401              }
   1402            }
   1403          
   1404            // Calc the count and apply a max count.
   1405            if ( zdappMgmtNwkDiscStartIndex > ResultCount )
   1406            {
   1407              count = 0;
   1408            }
   1409            else
   1410            {
   1411              count = ResultCount - zdappMgmtNwkDiscStartIndex;
   1412              if ( count > ZDO_MAX_NWKDISC_ITEMS )
   1413              {
   1414                count = ZDO_MAX_NWKDISC_ITEMS;
   1415              }
   1416          
   1417              // Move the list pointer up to the start index.
   1418              for ( i = 0; i < zdappMgmtNwkDiscStartIndex; i++ )
   1419              {
   1420                NetworkList = NetworkList->nextDesc;
   1421              }
   1422            }
   1423          
   1424            ZDP_MgmtNwkDiscRsp( zdappMgmtNwkDiscRspTransSeq,
   1425                               &zdappMgmtNwkDiscRspAddr, ZSuccess, ResultCount,
   1426                                zdappMgmtNwkDiscStartIndex,
   1427                                count,
   1428                                NetworkList,
   1429                                false );
   1430          
   1431            if ( ZSTACK_ROUTER_BUILD )
   1432            {
   1433              if ( newDesc != NULL )
   1434              {
   1435                osal_mem_free( newDesc );
   1436              }
   1437            }
   1438          
   1439            NLME_NwkDiscTerm();
   1440          }
   1441          #endif
   1442          
   1443          /*********************************************************************
   1444           * @fn          ZDO_ProcessMgmtRtgReq
   1445           *
   1446           * @brief       This function finishes the processing of the Management
   1447           *              Routing Request and generates the response.
   1448           *
   1449           *   Note:      This function will limit the number of items returned
   1450           *              to ZDO_MAX_RTG_ITEMS items.
   1451           *
   1452           * @param       inMsg - incoming message (request)
   1453           *
   1454           * @return      none
   1455           */
   1456          void ZDO_ProcessMgmtRtgReq( zdoIncomingMsg_t *inMsg )
   1457          {
   1458            byte x;
   1459            byte maxNumItems;
   1460            byte numItems = 0;
   1461            uint8 *pBuf = NULL;
   1462            rtgItem_t *pList;
   1463            uint8 StartIndex = inMsg->asdu[0];
   1464          
   1465            // Get the number of table items
   1466            NLME_GetRequest( nwkNumRoutingTableEntries, 0, &maxNumItems );
   1467          
   1468            if ( maxNumItems > StartIndex )
   1469            {
   1470              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   1471          
   1472              // limit the size of the list
   1473              if ( numItems > ZDO_MAX_RTG_ITEMS )
   1474              {
   1475                numItems = ZDO_MAX_RTG_ITEMS;
   1476              }
   1477          
   1478              // Allocate the memory to build the table
   1479              pBuf = osal_mem_alloc( (short)(sizeof( rtgItem_t ) * numItems) );
   1480          
   1481              if ( pBuf != NULL )
   1482              {
   1483                // Convert buffer to list
   1484                pList = (rtgItem_t *)pBuf;
   1485          
   1486                // Loop through items and build list
   1487                for ( x = 0; x < numItems; x++ )
   1488                {
   1489                  NLME_GetRequest( nwkRoutingTable, (uint16)(x + StartIndex), (void*)pList );
   1490          
   1491                  // Remap the status to the RoutingTableList Record Format defined in the ZigBee spec
   1492                  switch( pList->status )
   1493                  {
   1494                    case RT_ACTIVE:
   1495                      pList->status = ZDO_MGMT_RTG_ENTRY_ACTIVE;
   1496                      break;
   1497          
   1498                    case RT_DISC:
   1499                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY;
   1500                      break;
   1501          
   1502                    case RT_LINK_FAIL:
   1503                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED;
   1504          
   1505                    case RT_INIT:
   1506                    case RT_REPAIR:
   1507                    default:
   1508                      pList->status = ZDO_MGMT_RTG_ENTRY_INACTIVE;
   1509                      break;
   1510                  }
   1511          
   1512                  // Increment pointer to next record
   1513                  pList++;
   1514                }
   1515              }
   1516              else
   1517              {
   1518                numItems = 0;
   1519              }
   1520            }
   1521          
   1522            // Send response
   1523            ZDP_MgmtRtgRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxNumItems, StartIndex, numItems,
   1524                                  (rtgItem_t *)pBuf, false );
   1525          
   1526            if ( pBuf )
   1527            {
   1528              osal_mem_free( pBuf );
   1529            }
   1530          }
   1531          
   1532          /*********************************************************************
   1533           * @fn          ZDO_ProcessMgmtBindReq
   1534           *
   1535           * @brief       This function finishes the processing of the Management
   1536           *              Bind Request and generates the response.
   1537           *
   1538           *   Note:      This function will limit the number of items returned
   1539           *              to ZDO_MAX_BIND_ITEMS items.
   1540           *
   1541           * @param       inMsg - incoming message (request)
   1542           *
   1543           * @return      none
   1544           */
   1545          void ZDO_ProcessMgmtBindReq( zdoIncomingMsg_t *inMsg )
   1546          {
   1547          #if defined ( REFLECTOR )
   1548            byte x;
   1549            uint16 maxNumItems;
   1550            uint16 numItems;
   1551            uint8 *pBuf = NULL;
   1552            apsBindingItem_t *pList;
   1553            uint8 StartIndex = inMsg->asdu[0];
   1554            uint8 status;
   1555          
   1556            // Get the number of table items
   1557            APSME_GetRequest( apsNumBindingTableEntries, 0, (byte*)(&maxNumItems) );
   1558          
   1559            if ( maxNumItems > StartIndex )
   1560            {
   1561              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   1562            }
   1563            else
   1564            {
   1565              numItems = 0;
   1566            }
   1567          
   1568            // limit the size of the list
   1569            if ( numItems > ZDO_MAX_BIND_ITEMS )
   1570            {
   1571              numItems = ZDO_MAX_BIND_ITEMS;
   1572            }
   1573          
   1574            // Allocate the memory to build the table
   1575            if ( numItems && (pBuf = osal_mem_alloc( sizeof( apsBindingItem_t ) * numItems )) )
   1576            {
   1577              status = ZSuccess;
   1578          
   1579              // Convert buffer to list
   1580              pList = (apsBindingItem_t *)pBuf;
   1581          
   1582              // Loop through items and build list
   1583              for ( x = 0; x < numItems; x++ )
   1584              {
   1585                APSME_GetRequest( apsBindingTable, (x + StartIndex), (void*)pList );
   1586                pList++;
   1587              }
   1588          
   1589            }
   1590            else
   1591            {
   1592              status = ZDP_NOT_PERMITTED;
   1593              numItems = 0;
   1594            }
   1595          
   1596            // Send response
   1597            ZDP_MgmtBindRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, (byte)maxNumItems, StartIndex,
   1598                             (byte)numItems, (apsBindingItem_t *)pBuf, false );
   1599          
   1600            if ( pBuf )
   1601            {
   1602              osal_mem_free( pBuf );
   1603            }
   1604          #else
   1605            (void)inMsg;
   1606          #endif
   1607          }
   1608          
   1609          /*********************************************************************
   1610           * @fn          ZDO_ProcessMgmtDirectJoinReq
   1611           *
   1612           * @brief       This function finishes the processing of the Management
   1613           *              Direct Join Request and generates the response.
   1614           *
   1615           * @param       inMsg - incoming message (request)
   1616           *
   1617           * @return      none
   1618           */
   1619          void ZDO_ProcessMgmtDirectJoinReq( zdoIncomingMsg_t *inMsg )
   1620          {
   1621            uint8 *deviceAddr;
   1622            uint8 capInfo;
   1623            uint8 stat;
   1624          
   1625            // Parse the message
   1626            deviceAddr = inMsg->asdu;
   1627            capInfo = inMsg->asdu[Z_EXTADDR_LEN];
   1628          
   1629            stat = (byte) NLME_DirectJoinRequest( deviceAddr, capInfo );
   1630          
   1631            ZDP_MgmtDirectJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   1632          }
   1633          
   1634          /*********************************************************************
   1635           * @fn          ZDO_ProcessMgmtLeaveReq
   1636           *
   1637           * @brief       This function processes a Management Leave Request
   1638           *              and generates the response.
   1639           *
   1640           * @param       inMsg - incoming message (request)
   1641           *
   1642           * @return      none
   1643           */
   1644          void ZDO_ProcessMgmtLeaveReq( zdoIncomingMsg_t *inMsg )
   1645          {
   1646            NLME_LeaveReq_t req;
   1647            ZStatus_t       status;
   1648            uint8           option;
   1649            uint8 *msg = inMsg->asdu;
   1650          
   1651            if ( ( AddrMgrExtAddrValid( msg ) == FALSE                 ) ||
   1652                 ( osal_ExtAddrEqual( msg, NLME_GetExtAddr() ) == TRUE )    )
   1653            {
   1654              // Remove this device
   1655              req.extAddr = NULL;
   1656            }
   1657            else
   1658            {
   1659              // Remove child device
   1660              req.extAddr = msg;
   1661            }
   1662          
   1663            option = msg[Z_EXTADDR_LEN];
   1664            if ( option & ZDP_MGMT_LEAVE_REQ_RC )
   1665            {
   1666              req.removeChildren = TRUE;
   1667            }
   1668          
   1669            if ( option & ZDP_MGMT_LEAVE_REQ_REJOIN )
   1670            {
   1671               req.rejoin = TRUE;
   1672            }
   1673          
   1674            req.silent = FALSE;
   1675          
   1676            status = NLME_LeaveReq( &req );
   1677          
   1678            ZDP_MgmtLeaveRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, FALSE );
   1679          }
   1680          
   1681          
   1682          /*********************************************************************
   1683           * @fn          ZDO_ProcessMgmtPermitJoinReq
   1684           *
   1685           * @brief       This function processes a Management Permit Join Request
   1686           *              and generates the response.
   1687           *
   1688           * @param       inMsg - incoming message (request)
   1689           *
   1690           * @return      none
   1691           */
   1692          void ZDO_ProcessMgmtPermitJoinReq( zdoIncomingMsg_t *inMsg )
   1693          {
   1694            uint8 stat;
   1695            uint8 duration;
   1696            uint8 tcsig;
   1697          
   1698            duration = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   1699            tcsig    = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG];
   1700          
   1701            // Set the network layer permit join duration
   1702            stat = (byte) NLME_PermitJoiningRequest( duration );
   1703          
   1704            // Handle the Trust Center Significance
   1705            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1706            {
   1707              if ( tcsig == TRUE )
   1708              {
   1709                ZDSecMgrPermitJoining( duration );
   1710              }
   1711            }
   1712          
   1713            // Send a response if unicast
   1714            if (inMsg->srcAddr.addr.shortAddr != NWK_BROADCAST_SHORTADDR)
   1715            {
   1716              ZDP_MgmtPermitJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   1717            }
   1718          }
   1719          
   1720          /*
   1721           * This function stub allows the next higher layer to be notified of
   1722           * a permit joining timeout.
   1723           */
   1724          /*********************************************************************
   1725           * @fn          ZDO_ProcessMgmtPermitJoinTimeout
   1726           *
   1727           * @brief       This function stub allows the next higher layer to be
   1728           *              notified of a permit joining timeout. Currently, this
   1729           *              directly bypasses the APS layer.
   1730           *
   1731           * @param       none
   1732           *
   1733           * @return      none
   1734           */
   1735          void ZDO_ProcessMgmtPermitJoinTimeout( void )
   1736          {
   1737            #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE )
   1738            // Currently, only the ZDSecMgr needs to be notified
   1739            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1740            {
   1741              ZDSecMgrPermitJoiningTimeout();
   1742            }
   1743            #endif
   1744          }
   1745          
   1746          /*********************************************************************
   1747           * @fn          ZDO_ProcessUserDescReq
   1748           *
   1749           * @brief       This function finishes the processing of the User
   1750           *              Descriptor Request and generates the response.
   1751           *
   1752           * @param       inMsg - incoming message (request)
   1753           *
   1754           * @return      none
   1755           */
   1756          void ZDO_ProcessUserDescReq( zdoIncomingMsg_t *inMsg )
   1757          {
   1758            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   1759            UserDescriptorFormat_t userDesc;
   1760          
   1761            if ( (aoi == ZDAppNwkAddr.addr.shortAddr) && (ZSUCCESS == osal_nv_read(
   1762                       ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc )) )
   1763            {
   1764              ZDP_UserDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), aoi, &userDesc, false );
   1765            }
   1766            else
   1767            {
   1768              ZDP_GenericRsp(inMsg->TransSeq, &(inMsg->srcAddr),
   1769                     ZDP_NOT_SUPPORTED, aoi, User_Desc_rsp, inMsg->SecurityUse );
   1770            }
   1771          }
   1772          
   1773          /*********************************************************************
   1774           * @fn          ZDO_ProcessUserDescSet
   1775           *
   1776           * @brief       This function finishes the processing of the User
   1777           *              Descriptor Set and generates the response.
   1778           *
   1779           * @param       inMsg - incoming message (request)
   1780           *
   1781           * @return      none
   1782           */
   1783          void ZDO_ProcessUserDescSet( zdoIncomingMsg_t *inMsg )
   1784          {
   1785            uint8 *msg;
   1786            uint16 aoi;
   1787            UserDescriptorFormat_t userDesc;
   1788            uint8 outMsg[3];
   1789            uint8 status;
   1790          
   1791            msg = inMsg->asdu;
   1792            aoi = BUILD_UINT16( msg[0], msg[1] );
   1793          
   1794            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   1795            {
   1796              userDesc.len = (msg[2] < AF_MAX_USER_DESCRIPTOR_LEN) ? msg[2] : AF_MAX_USER_DESCRIPTOR_LEN;
   1797              msg ++;  // increment one for the length field
   1798          
   1799              osal_memcpy( userDesc.desc, &msg[2], userDesc.len );
   1800              osal_nv_write( ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc );
   1801              if ( userDesc.len != 0 )
   1802              {
   1803                ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   1804              }
   1805              else
   1806              {
   1807                ZDO_Config_Node_Descriptor.UserDescAvail = FALSE;
   1808              }
   1809          
   1810              status = ZDP_SUCCESS;
   1811            }
   1812            else
   1813            {
   1814              status =  ZDP_NOT_SUPPORTED;
   1815            }
   1816          
   1817            outMsg[0] = status;
   1818            outMsg[1] = LO_UINT16( aoi );
   1819            outMsg[2] = LO_UINT16( aoi );
   1820          
   1821            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr), User_Desc_conf, 3, outMsg,
   1822                         inMsg->SecurityUse );
   1823          }
   1824          
   1825          /*********************************************************************
   1826           * @fn          ZDO_ProcessDeviceAnnce
   1827           *
   1828           * @brief       This function processes a device annouce message.
   1829           *
   1830           * @param       inMsg - incoming message
   1831           *
   1832           * @return      none
   1833           */
   1834          void ZDO_ProcessDeviceAnnce( zdoIncomingMsg_t *inMsg )
   1835          {
   1836            ZDO_DeviceAnnce_t Annce;
   1837            AddrMgrEntry_t addrEntry;
   1838            uint8 parentExt[Z_EXTADDR_LEN];
   1839          
   1840            // Parse incoming message
   1841            ZDO_ParseDeviceAnnce( inMsg, &Annce );
   1842          
   1843            if ( ZSTACK_END_DEVICE_BUILD )
   1844            {
   1845              // Make sure the message didn't come from myself - end device only
   1846              if ( osal_ExtAddrEqual( NLME_GetExtAddr(), Annce.extAddr ) && Annce.nwkAddr == NLME_GetShortAddr() )
   1847              {
   1848                return;
   1849              }
   1850            }
   1851          
   1852          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1853            // Clean up the neighbor table
   1854            nwkNeighborRemoveAllStranded();
   1855          
   1856            // If address conflict is detected, no need to update the address manager
   1857            if ( NLME_CheckNewAddrSet( Annce.nwkAddr, Annce.extAddr )== ZFailure )
   1858            {
   1859              return;
   1860            }
   1861          #endif
   1862          
   1863          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1864            // Check for parent's address
   1865            NLME_GetCoordExtAddr( parentExt );
   1866            if ( osal_ExtAddrEqual( parentExt, Annce.extAddr ) )
   1867            {
   1868              if ( Annce.nwkAddr != NLME_GetCoordShortAddr() )
   1869              {
   1870                // Set the Parent's MAC's new short address
   1871                _NIB.nwkCoordAddress = Annce.nwkAddr;
   1872                ZMacSetReq( ZMacCoordShortAddress, (byte*)&(_NIB.nwkCoordAddress) );
   1873              }
   1874            }
   1875          
   1876            if ( ZSTACK_ROUTER_BUILD )
   1877            {
   1878              // If the device annce comes from a end device child that has moved
   1879              // to another parent, remove it from associated device list
   1880          
   1881              // If the dev annce is coming from other device's children,
   1882              // (The dev annce from its own children shall be unicast to itself,
   1883              // So check the mac destination address)
   1884              // Remove it from the associated device list. If it is not
   1885              // a child, no action will be taken in AssocRemove() anyway.
   1886              if ( inMsg->macDestAddr != NLME_GetShortAddr() )
   1887              {
   1888                associated_devices_t *dev_ptr;
   1889          
   1890                // If it's an end device child
   1891                dev_ptr = AssocGetWithExt( Annce.extAddr );
   1892                if ( dev_ptr )
   1893                {
   1894                  if ( dev_ptr->nodeRelation == CHILD_RFD ||
   1895                       dev_ptr->nodeRelation == CHILD_RFD_RX_IDLE )
   1896                  {
   1897                    AssocRemove( Annce.extAddr );
   1898                  }
   1899                }
   1900              }
   1901          
   1902              if ( Annce.nwkAddr != NLME_GetShortAddr() )
   1903              {
   1904                // If an associated device is found with matched extended Address,
   1905                // update its short address
   1906                if ( AssocChangeNwkAddr( Annce.nwkAddr, Annce.extAddr ) )
   1907                {
   1908                  // Update the neighbor table
   1909                  nwkNeighborUpdateNwkAddr( Annce.nwkAddr, Annce.extAddr );
   1910          
   1911                  // Set event to save NV
   1912                  ZDApp_NVUpdate();
   1913                }
   1914              }
   1915            }
   1916            
   1917            // Assume that the device has moved, remove existing routing entries
   1918            RTG_RemoveRtgEntry( Annce.nwkAddr, 0 );
   1919            
   1920          #endif // ZIGBEE_STOCHASTIC_ADDRESSING
   1921          
   1922          
   1923            // Fill in the extended address in address manager if we don't have it already.
   1924            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1925            addrEntry.nwkAddr = Annce.nwkAddr;
   1926            if ( AddrMgrEntryLookupNwk( &addrEntry ) )
   1927            {
   1928              osal_memset( parentExt, 0, Z_EXTADDR_LEN );
   1929              if ( osal_ExtAddrEqual( parentExt, addrEntry.extAddr ) )
   1930              {
   1931                AddrMgrExtAddrSet( addrEntry.extAddr, Annce.extAddr );
   1932                AddrMgrEntryUpdate( &addrEntry );
   1933              }
   1934            }
   1935          }
   1936          
   1937          /*********************************************************************
   1938           * @fn          ZDO_BuildSimpleDescBuf
   1939           *
   1940           * @brief       Build a byte sequence representation of a Simple Descriptor.
   1941           *
   1942           * @param       buf  - pointer to a byte array big enough for data.
   1943           * @param       desc - SimpleDescriptionFormat_t *
   1944           *
   1945           * @return      none
   1946           */
   1947          void ZDO_BuildSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   1948          {
   1949            byte cnt;
   1950            uint16 *ptr;
   1951          
   1952            *buf++ = desc->EndPoint;
   1953            *buf++ = HI_UINT16( desc->AppProfId );
   1954            *buf++ = LO_UINT16( desc->AppProfId );
   1955            *buf++ = HI_UINT16( desc->AppDeviceId );
   1956            *buf++ = LO_UINT16( desc->AppDeviceId );
   1957          
   1958            *buf++ = (byte)(desc->AppDevVer << 4);
   1959          
   1960            *buf++ = desc->AppNumInClusters;
   1961            ptr = desc->pAppInClusterList;
   1962            for ( cnt = 0; cnt < desc->AppNumInClusters; ptr++, cnt++ )
   1963            {
   1964              *buf++ = HI_UINT16( *ptr );
   1965              *buf++ = LO_UINT16( *ptr );
   1966            }
   1967          
   1968            *buf++ = desc->AppNumOutClusters;
   1969            ptr = desc->pAppOutClusterList;
   1970            for ( cnt = 0; cnt < desc->AppNumOutClusters; ptr++, cnt++ )
   1971            {
   1972              *buf++ = HI_UINT16( *ptr );
   1973              *buf++ = LO_UINT16( *ptr );
   1974            }
   1975          }
   1976          
   1977          /*********************************************************************
   1978           * @fn      ZDO_MatchEndDeviceBind()
   1979           *
   1980           * @brief
   1981           *
   1982           *   Called to match end device binding requests
   1983           *
   1984           * @param  bindReq  - binding request information
   1985           * @param  SecurityUse - Security enable/disable
   1986           *
   1987           * @return  none
   1988           */
   1989          void ZDO_MatchEndDeviceBind( ZDEndDeviceBind_t *bindReq )
   1990          {
   1991            zAddrType_t dstAddr;
   1992            uint8 sendRsp = FALSE;
   1993            uint8 status;
   1994          
   1995            // Is this the first request?
   1996            if ( matchED == NULL )
   1997            {
   1998              // Create match info structure
   1999              matchED = (ZDMatchEndDeviceBind_t *)osal_mem_alloc( sizeof ( ZDMatchEndDeviceBind_t ) );
   2000              if ( matchED )
   2001              {
   2002                // Clear the structure
   2003                osal_memset( (uint8 *)matchED, 0, sizeof ( ZDMatchEndDeviceBind_t ) );
   2004          
   2005                // Copy the first request's information
   2006                if ( !ZDO_CopyMatchInfo( &(matchED->ed1), bindReq ) )
   2007                {
   2008          
   2009                  status = ZDP_NO_ENTRY;
   2010                  sendRsp = TRUE;
   2011                }
   2012              }
   2013              else
   2014              {
   2015                status = ZDP_NO_ENTRY;
   2016                sendRsp = TRUE;
   2017              }
   2018          
   2019              if ( !sendRsp )
   2020              {
   2021                // Set into the correct state
   2022                matchED->state = ZDMATCH_WAIT_REQ;
   2023          
   2024                // Setup the timeout
   2025                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2026              }
   2027            }
   2028            else
   2029            {
   2030                matchED->state = ZDMATCH_SENDING_BINDS;
   2031          
   2032                // Copy the 2nd request's information
   2033                if ( !ZDO_CopyMatchInfo( &(matchED->ed2), bindReq ) )
   2034                {
   2035                  status = ZDP_NO_ENTRY;
   2036                  sendRsp = TRUE;
   2037                }
   2038          
   2039                // Make a source match for ed1
   2040                matchED->ed1numMatched = ZDO_CompareClusterLists(
   2041                            matchED->ed1.numOutClusters, matchED->ed1.outClusters,
   2042                            matchED->ed2.numInClusters, matchED->ed2.inClusters, ZDOBuildBuf );
   2043                if ( matchED->ed1numMatched )
   2044                {
   2045                  // Save the match list
   2046                  matchED->ed1Matched = osal_mem_alloc( (short)(matchED->ed1numMatched * sizeof ( uint16 )) );
   2047                  if ( matchED->ed1Matched )
   2048                  {
   2049                    osal_memcpy( matchED->ed1Matched, ZDOBuildBuf, (matchED->ed1numMatched * sizeof ( uint16 )) );
   2050                  }
   2051                  else
   2052                  {
   2053                    // Allocation error, stop
   2054                    status = ZDP_NO_ENTRY;
   2055                    sendRsp = TRUE;
   2056                  }
   2057                }
   2058          
   2059                // Make a source match for ed2
   2060                matchED->ed2numMatched = ZDO_CompareClusterLists(
   2061                            matchED->ed2.numOutClusters, matchED->ed2.outClusters,
   2062                            matchED->ed1.numInClusters, matchED->ed1.inClusters, ZDOBuildBuf );
   2063                if ( matchED->ed2numMatched )
   2064                {
   2065                  // Save the match list
   2066                  matchED->ed2Matched = osal_mem_alloc( (short)(matchED->ed2numMatched * sizeof ( uint16 )) );
   2067                  if ( matchED->ed2Matched )
   2068                  {
   2069                    osal_memcpy( matchED->ed2Matched, ZDOBuildBuf, (matchED->ed2numMatched * sizeof ( uint16 )) );
   2070                  }
   2071                  else
   2072                  {
   2073                    // Allocation error, stop
   2074                    status = ZDP_NO_ENTRY;
   2075                    sendRsp = TRUE;
   2076                  }
   2077                }
   2078          
   2079                if ( (sendRsp == FALSE) && (matchED->ed1numMatched || matchED->ed2numMatched) )
   2080                {
   2081                  // Do the first unbind/bind state
   2082                  ZDMatchSendState( ZDMATCH_REASON_START, ZDP_SUCCESS, 0 );
   2083                }
   2084                else
   2085                {
   2086                  status = ZDP_NO_MATCH;
   2087                  sendRsp = TRUE;
   2088                }
   2089            }
   2090          
   2091            if ( sendRsp )
   2092            {
   2093              // send response to this requester
   2094              dstAddr.addrMode = Addr16Bit;
   2095              dstAddr.addr.shortAddr = bindReq->srcAddr;
   2096              ZDP_EndDeviceBindRsp( bindReq->TransSeq, &dstAddr, status, bindReq->SecurityUse );
   2097          
   2098              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   2099              {
   2100                // send response to first requester
   2101                dstAddr.addrMode = Addr16Bit;
   2102                dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   2103                ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, status, matchED->ed1.SecurityUse );
   2104              }
   2105          
   2106              // Process ended - release memory used
   2107              ZDO_RemoveMatchMemory();
   2108            }
   2109          }
   2110          
   2111          /*********************************************************************
   2112           * @fn      ZDO_RemoveMatchMemory()
   2113           *
   2114           * @brief   Called to clear the memory used for the end device bind.
   2115           *
   2116           * @param  none
   2117           *
   2118           * @return  none
   2119           */
   2120          static void ZDO_RemoveMatchMemory( void )
   2121          {
   2122            if ( matchED != NULL )
   2123            {
   2124              if ( matchED->ed2Matched != NULL )
   2125                osal_mem_free( matchED->ed2Matched );
   2126              if ( matchED->ed1Matched != NULL )
   2127                osal_mem_free( matchED->ed1Matched );
   2128          
   2129              if ( matchED->ed1.inClusters != NULL )
   2130                osal_mem_free( matchED->ed1.inClusters );
   2131          
   2132              if ( matchED->ed1.outClusters != NULL )
   2133                osal_mem_free( matchED->ed1.outClusters );
   2134          
   2135              if ( matchED->ed2.inClusters != NULL )
   2136                osal_mem_free( matchED->ed2.inClusters );
   2137          
   2138              if ( matchED->ed2.outClusters != NULL )
   2139                osal_mem_free( matchED->ed2.outClusters );
   2140          
   2141              osal_mem_free( matchED );
   2142          
   2143              matchED = (ZDMatchEndDeviceBind_t *)NULL;
   2144            }
   2145          }
   2146          
   2147          /*********************************************************************
   2148           * @fn      ZDO_CopyMatchInfo()
   2149           *
   2150           * @brief   Called to copy memory used for the end device bind.
   2151           *
   2152           * @param  srcReq - source information
   2153           * @param  dstReq - destination location
   2154           *
   2155           * @return  TRUE if copy was successful.
   2156           */
   2157          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq )
   2158          {
   2159            uint8 allOK = TRUE;
   2160          
   2161            // Copy bind information into the match info structure
   2162            osal_memcpy( (uint8 *)destReq, srcReq, sizeof ( ZDEndDeviceBind_t ) );
   2163          
   2164            // Initialize the destination cluster pointers
   2165            destReq->inClusters = NULL;
   2166            destReq->outClusters = NULL;
   2167          
   2168            // Copy input cluster IDs
   2169            if ( srcReq->numInClusters )
   2170            {
   2171              destReq->inClusters = osal_mem_alloc( (short)(srcReq->numInClusters * sizeof ( uint16 )) );
   2172              if ( destReq->inClusters )
   2173              {
   2174                // Copy the clusters
   2175                osal_memcpy( (uint8*)(destReq->inClusters), (uint8 *)(srcReq->inClusters),
   2176                                (srcReq->numInClusters * sizeof ( uint16 )) );
   2177              }
   2178              else
   2179                allOK = FALSE;
   2180            }
   2181          
   2182            // Copy output cluster IDs
   2183            if ( srcReq->numOutClusters )
   2184            {
   2185              destReq->outClusters = osal_mem_alloc( (short)(srcReq->numOutClusters * sizeof ( uint16 )) );
   2186              if ( destReq->outClusters )
   2187              {
   2188                // Copy the clusters
   2189                osal_memcpy( (uint8 *)(destReq->outClusters), (uint8 *)(srcReq->outClusters),
   2190                                (srcReq->numOutClusters * sizeof ( uint16 )) );
   2191              }
   2192              else
   2193                allOK = FALSE;
   2194            }
   2195          
   2196            if ( !allOK )
   2197            {
   2198              if ( destReq->inClusters != NULL )
   2199                osal_mem_free( destReq->inClusters );
   2200              if ( destReq->outClusters != NULL )
   2201                osal_mem_free( destReq->outClusters );
   2202            }
   2203          
   2204            return ( allOK );
   2205          }
   2206          
   2207          /*********************************************************************
   2208           * @fn      ZDMatchSendState()
   2209           *
   2210           * @brief   State machine for the End device match message algorithm.
   2211           *
   2212           * @param  reason - state of algoritm
   2213           * @param  status - initial message status
   2214           * @param  TransSeq - next transaction sequence number
   2215           *
   2216           * @return  FALSE if error and we are not currently matching, TRUE
   2217           *          if success.
   2218           */
   2219          uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq )
   2220          {
   2221            uint8 *dstIEEEAddr = NULL;
   2222            uint8 dstEP = 0xFF;
   2223            zAddrType_t dstAddr;
   2224            zAddrType_t destinationAddr;
   2225            uint16 msgType;
   2226            uint16 clusterID = 0xFFFF;
   2227            ZDEndDeviceBind_t *ed = NULL;
   2228            uint8 rspStatus = ZDP_SUCCESS;
   2229          
   2230            if ( matchED == NULL )
   2231              return ( FALSE );
   2232          
   2233            // Check sequence number
   2234            if ( reason == ZDMATCH_REASON_BIND_RSP || reason == ZDMATCH_REASON_UNBIND_RSP )
   2235            {
   2236              if ( TransSeq != matchED->transSeq )
   2237                return( FALSE ); // ignore the message
   2238            }
   2239          
   2240            // turn off timer
   2241            APS_SetEndDeviceBindTimeout( 0, ZDO_EndDeviceBindMatchTimeoutCB );
   2242          
   2243            if ( reason == ZDMATCH_REASON_TIMEOUT )
   2244            {
   2245              rspStatus = ZDP_TIMEOUT;    // The process will stop
   2246            }
   2247          
   2248            if ( reason == ZDMATCH_REASON_START || reason == ZDMATCH_REASON_BIND_RSP )
   2249            {
   2250              matchED->sending = ZDMATCH_SENDING_UNBIND;
   2251          
   2252              if ( reason == ZDMATCH_REASON_BIND_RSP && status != ZDP_SUCCESS )
   2253              {
   2254                rspStatus = status;
   2255              }
   2256            }
   2257            else if ( reason == ZDMATCH_REASON_UNBIND_RSP )
   2258            {
   2259              if ( status == ZDP_SUCCESS )
   2260              {
   2261                matchED->sending = ZDMATCH_SENDING_UNBIND;
   2262              }
   2263              else
   2264              {
   2265                matchED->sending = ZDMATCH_SENDING_BIND;
   2266              }
   2267            }
   2268          
   2269            if ( reason != ZDMATCH_REASON_START && matchED->sending == ZDMATCH_SENDING_UNBIND )
   2270            {
   2271              // Move to the next cluster ID
   2272              if ( matchED->ed1numMatched )
   2273                matchED->ed1numMatched--;
   2274              else if ( matchED->ed2numMatched )
   2275                matchED->ed2numMatched--;
   2276            }
   2277          
   2278            // What message do we send now
   2279            if ( matchED->ed1numMatched )
   2280            {
   2281              ed = &(matchED->ed1);
   2282              clusterID = matchED->ed1Matched[matchED->ed1numMatched-1];
   2283              dstIEEEAddr = matchED->ed2.ieeeAddr;
   2284              dstEP = matchED->ed2.endpoint;
   2285            }
   2286            else if ( matchED->ed2numMatched )
   2287            {
   2288              ed = &(matchED->ed2);
   2289              clusterID = matchED->ed2Matched[matchED->ed2numMatched-1];
   2290              dstIEEEAddr = matchED->ed1.ieeeAddr;
   2291              dstEP = matchED->ed1.endpoint;
   2292            }
   2293          
   2294            dstAddr.addrMode = Addr16Bit;
   2295          
   2296            // Send the next message
   2297            if ( rspStatus == ZDP_SUCCESS && ed )
   2298            {
   2299              // Send unbind/bind message to source
   2300              if ( matchED->sending == ZDMATCH_SENDING_UNBIND )
   2301                msgType = Unbind_req;
   2302              else
   2303                msgType = Bind_req;
   2304          
   2305              dstAddr.addr.shortAddr = ed->srcAddr;
   2306          
   2307              // Save off the transaction sequence number
   2308              matchED->transSeq = ZDP_TransID;
   2309          
   2310              destinationAddr.addrMode = Addr64Bit;
   2311              osal_cpyExtAddr( destinationAddr.addr.extAddr, dstIEEEAddr );
   2312          
   2313              ZDP_BindUnbindReq( msgType, &dstAddr, ed->ieeeAddr, ed->endpoint, clusterID,
   2314                  &destinationAddr, dstEP, ed->SecurityUse );
   2315          
   2316              // Set timeout for response
   2317              APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2318            }
   2319            else
   2320            {
   2321              // Send the response messages to requesting devices
   2322              // send response to first requester
   2323              dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   2324              ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, rspStatus, matchED->ed1.SecurityUse );
   2325          
   2326              // send response to second requester
   2327              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   2328              {
   2329                dstAddr.addr.shortAddr = matchED->ed2.srcAddr;
   2330                ZDP_EndDeviceBindRsp( matchED->ed2.TransSeq, &dstAddr, rspStatus, matchED->ed2.SecurityUse );
   2331              }
   2332          
   2333              // Process ended - release memory used
   2334              ZDO_RemoveMatchMemory();
   2335            }
   2336          
   2337            return ( TRUE );
   2338          }
   2339          
   2340          /*********************************************************************
   2341           * @fn      ZDO_EndDeviceBindMatchTimeoutCB()
   2342           *
   2343           * @brief   End device bind timeout.
   2344           *
   2345           * @param  none
   2346           *
   2347           * @return  none
   2348           */
   2349          static void ZDO_EndDeviceBindMatchTimeoutCB( void )
   2350          {
   2351            ZDMatchSendState( ZDMATCH_REASON_TIMEOUT, ZDP_TIMEOUT, 0 );
   2352          }
   2353          
   2354          /*********************************************************************
   2355           * ZDO MESSAGE PARSING API FUNCTIONS
   2356           */
   2357          
   2358          /*********************************************************************
   2359           * @fn          ZDO_ParseEndDeviceBindReq
   2360           *
   2361           * @brief       This function parses the End_Device_Bind_req message.
   2362           *
   2363           *     NOTE:  The clusters lists in bindReq are allocated in this
   2364           *            function and must be freed by that calling function.
   2365           *
   2366           * @param       inMsg  - incoming message (request)
   2367           * @param       bindReq - pointer to place to parse message to
   2368           *
   2369           * @return      none
   2370           */
   2371          void ZDO_ParseEndDeviceBindReq( zdoIncomingMsg_t *inMsg, ZDEndDeviceBind_t *bindReq )
   2372          {
   2373            uint8 *msg;
   2374          
   2375            // Parse the message
   2376            bindReq->TransSeq = inMsg->TransSeq;
   2377            bindReq->srcAddr = inMsg->srcAddr.addr.shortAddr;
   2378            bindReq->SecurityUse = inMsg->SecurityUse;
   2379            msg = inMsg->asdu;
   2380          
   2381            bindReq->localCoordinator = BUILD_UINT16( msg[0], msg[1] );
   2382            msg += 2;
   2383          
   2384            osal_cpyExtAddr( bindReq->ieeeAddr, msg );
   2385            msg += Z_EXTADDR_LEN;
   2386          
   2387            bindReq->endpoint = *msg++;
   2388            bindReq->profileID = BUILD_UINT16( msg[0], msg[1] );
   2389            msg += 2;
   2390          
   2391            bindReq->inClusters = NULL;
   2392            bindReq->outClusters = NULL;
   2393          
   2394            if ((bindReq->numInClusters = *msg++) &&
   2395                (bindReq->inClusters = (uint16*)osal_mem_alloc( (bindReq->numInClusters * sizeof( uint16 )))))
   2396            {
   2397              msg = ZDO_ConvertOTAClusters( bindReq->numInClusters, msg, bindReq->inClusters );
   2398            }
   2399            else
   2400            {
   2401              bindReq->numInClusters = 0;
   2402            }
   2403          
   2404            if ((bindReq->numOutClusters = *msg++) &&
   2405                (bindReq->outClusters = (uint16*)osal_mem_alloc((bindReq->numOutClusters * sizeof(uint16)))))
   2406            {
   2407              msg = ZDO_ConvertOTAClusters( bindReq->numOutClusters, msg, bindReq->outClusters );
   2408            }
   2409            else
   2410            {
   2411              bindReq->numOutClusters = 0;
   2412            }
   2413          }
   2414          
   2415          /*********************************************************************
   2416           * @fn          ZDO_ParseBindUnbindReq
   2417           *
   2418           * @brief       This function parses the Bind_req or Unbind_req message.
   2419           *
   2420           * @param       inMsg  - incoming message (request)
   2421           * @param       pReq - place to put parsed information
   2422           *
   2423           * @return      none
   2424           */
   2425          void ZDO_ParseBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
   2426          {
   2427            uint8 *msg;
   2428          
   2429            msg = inMsg->asdu;
   2430            osal_cpyExtAddr( pReq->srcAddress, msg );
   2431            msg += Z_EXTADDR_LEN;
   2432            pReq->srcEndpoint = *msg++;
   2433            pReq->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2434            msg += 2;
   2435            pReq->dstAddress.addrMode = *msg++;
   2436            if ( pReq->dstAddress.addrMode == Addr64Bit )
   2437            {
   2438              osal_cpyExtAddr( pReq->dstAddress.addr.extAddr, msg );
   2439              msg += Z_EXTADDR_LEN;
   2440              pReq->dstEndpoint = *msg;
   2441            }
   2442            else
   2443            {
   2444              // copy group address
   2445              pReq->dstAddress.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2446            }
   2447          }
   2448          
   2449          /*********************************************************************
   2450           * @fn      ZDO_ParseAddrRsp
   2451           *
   2452           * @brief   Turns the inMsg (incoming message) into the out parsed
   2453           *          structure.
   2454           *
   2455           * @param   inMsg - incoming message
   2456           *
   2457           * @return  pointer to parsed structures.  This structure was
   2458           *          allocated using osal_mem_alloc, so it must be freed
   2459           *          by the calling function [osal_mem_free()].
   2460           */
   2461          ZDO_NwkIEEEAddrResp_t *ZDO_ParseAddrRsp( zdoIncomingMsg_t *inMsg )
   2462          {
   2463            ZDO_NwkIEEEAddrResp_t *rsp;
   2464            uint8 *msg;
   2465            byte cnt = 0;
   2466          
   2467            // Calculate the number of items in the list
   2468            if ( inMsg->asduLen > (1 + Z_EXTADDR_LEN + 2) )
   2469              cnt = inMsg->asdu[1 + Z_EXTADDR_LEN + 2];
   2470            else
   2471              cnt = 0;
   2472          
   2473            // Make buffer
   2474            rsp = (ZDO_NwkIEEEAddrResp_t *)osal_mem_alloc( sizeof(ZDO_NwkIEEEAddrResp_t) + (cnt * sizeof ( uint16 )) );
   2475          
   2476            if ( rsp )
   2477            {
   2478              msg = inMsg->asdu;
   2479          
   2480              rsp->status = *msg++;
   2481              if ( rsp->status == ZDO_SUCCESS )
   2482              {
   2483                osal_cpyExtAddr( rsp->extAddr, msg );
   2484                msg += Z_EXTADDR_LEN;
   2485                rsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2486          
   2487                msg += 2;
   2488                rsp->numAssocDevs = 0;
   2489          
   2490                // StartIndex field is only present if NumAssocDev field is non-zero.
   2491                if ( cnt > 0 )
   2492                {
   2493                  uint16 *pList = &(rsp->devList[0]);
   2494                  byte n = cnt;
   2495          
   2496                  rsp->numAssocDevs = *msg++;
   2497                  rsp->startIndex = *msg++;
   2498          
   2499                  while ( n != 0 )
   2500                  {
   2501                    *pList++ = BUILD_UINT16( msg[0], msg[1] );
   2502                    msg += sizeof( uint16 );
   2503                    n--;
   2504                  }
   2505                }
   2506              }
   2507            }
   2508            return ( rsp );
   2509          }
   2510          
   2511          /*********************************************************************
   2512           * @fn          ZDO_ParseNodeDescRsp
   2513           *
   2514           * @brief       This function parses the Node_Desc_rsp message.
   2515           *
   2516           * @param       inMsg - incoming message
   2517           * @param       pNDRsp - place to parse the message into
   2518           *
   2519           * @return      none
   2520           */
   2521          void ZDO_ParseNodeDescRsp( zdoIncomingMsg_t *inMsg, ZDO_NodeDescRsp_t *pNDRsp )
   2522          {
   2523            uint8 *msg;
   2524          
   2525            msg = inMsg->asdu;
   2526          
   2527            pNDRsp->status = *msg++;
   2528            pNDRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2529          
   2530            if ( pNDRsp->status == ZDP_SUCCESS )
   2531            {
   2532              msg += 2;
   2533              pNDRsp->nodeDesc.LogicalType = *msg & 0x07;
   2534          
   2535              pNDRsp->nodeDesc.ComplexDescAvail = ( *msg & 0x08 ) >> 3;
   2536              pNDRsp->nodeDesc.UserDescAvail = ( *msg & 0x10 ) >> 4;
   2537          
   2538              msg++;  // Reserved bits.
   2539              pNDRsp->nodeDesc.FrequencyBand = (*msg >> 3) & 0x1f;
   2540              pNDRsp->nodeDesc.APSFlags = *msg++ & 0x07;
   2541              pNDRsp->nodeDesc.CapabilityFlags = *msg++;
   2542              pNDRsp->nodeDesc.ManufacturerCode[0] = *msg++;
   2543              pNDRsp->nodeDesc.ManufacturerCode[1] = *msg++;
   2544              pNDRsp->nodeDesc.MaxBufferSize = *msg++;
   2545              pNDRsp->nodeDesc.MaxInTransferSize[0] = *msg++;
   2546              pNDRsp->nodeDesc.MaxInTransferSize[1] = *msg++;
   2547              pNDRsp->nodeDesc.ServerMask = BUILD_UINT16( msg[0], msg[1] );
   2548              msg += 2;
   2549              pNDRsp->nodeDesc.MaxOutTransferSize[0] = *msg++;
   2550              pNDRsp->nodeDesc.MaxOutTransferSize[1] = *msg++;
   2551              pNDRsp->nodeDesc.DescriptorCapability = *msg;
   2552            }
   2553          }
   2554          
   2555          /*********************************************************************
   2556           * @fn          ZDO_ParesPowerDescRsp
   2557           *
   2558           * @brief       This function parses the Power_Desc_rsp message.
   2559           *
   2560           * @param       inMsg  - incoming message
   2561           * @param       pNPRsp - place to parse the message into
   2562           *
   2563           * @return      none
   2564           */
   2565          void ZDO_ParsePowerDescRsp( zdoIncomingMsg_t *inMsg, ZDO_PowerRsp_t *pNPRsp )
   2566          {
   2567            uint8 *msg;
   2568          
   2569            msg = inMsg->asdu;
   2570            pNPRsp->status = *msg++;
   2571            pNPRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2572          
   2573            if ( pNPRsp->status == ZDP_SUCCESS )
   2574            {
   2575              msg += 2;
   2576              pNPRsp->pwrDesc.AvailablePowerSources = *msg >> 4;
   2577              pNPRsp->pwrDesc.PowerMode = *msg++ & 0x0F;
   2578              pNPRsp->pwrDesc.CurrentPowerSourceLevel = *msg >> 4;
   2579              pNPRsp->pwrDesc.CurrentPowerSource = *msg++ & 0x0F;
   2580            }
   2581          }
   2582          
   2583          /*********************************************************************
   2584           * @fn          ZDO_ParseSimpleDescRsp
   2585           *
   2586           * @brief       This function parse the Simple_Desc_rsp message.
   2587           *
   2588           *   NOTE: The pAppInClusterList and pAppOutClusterList fields
   2589           *         in the SimpleDescriptionFormat_t structure are allocated
   2590           *         and the calling function needs to free [osal_msg_free()]
   2591           *         these buffers.
   2592           *
   2593           * @param       inMsg  - incoming message
   2594           * @param       pSimpleDescRsp - place to parse the message into
   2595           *
   2596           * @return      none
   2597           */
   2598          void ZDO_ParseSimpleDescRsp( zdoIncomingMsg_t *inMsg, ZDO_SimpleDescRsp_t *pSimpleDescRsp )
   2599          {
   2600            uint8 *msg;
   2601          
   2602            msg = inMsg->asdu;
   2603            pSimpleDescRsp->status = *msg++;
   2604            pSimpleDescRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2605            msg += sizeof ( uint16 );
   2606            msg++; // Skip past the length field.
   2607          
   2608            if ( pSimpleDescRsp->status == ZDP_SUCCESS )
   2609            {
   2610              ZDO_ParseSimpleDescBuf( msg, &(pSimpleDescRsp->simpleDesc) );
   2611            }
   2612          }
   2613          
   2614          /*********************************************************************
   2615           * @fn          ZDO_ParseEPListRsp
   2616           *
   2617           * @brief       This parse the Active_EP_rsp or Match_Desc_rsp message.
   2618           *
   2619           * @param       inMsg  - incoming message
   2620           *
   2621           * @return      none
   2622           */
   2623          ZDO_ActiveEndpointRsp_t *ZDO_ParseEPListRsp( zdoIncomingMsg_t *inMsg )
   2624          {
   2625            ZDO_ActiveEndpointRsp_t *pRsp;
   2626            uint8 *msg;
   2627            uint8 Status;
   2628            uint8 cnt;
   2629          
   2630            msg = inMsg->asdu;
   2631            Status = *msg++;
   2632            cnt = msg[2];
   2633          
   2634            pRsp = (ZDO_ActiveEndpointRsp_t *)osal_mem_alloc( sizeof(  ZDO_ActiveEndpointRsp_t ) + cnt );
   2635            if ( pRsp )
   2636            {
   2637              pRsp->status = Status;
   2638              pRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2639              msg += sizeof( uint16 );
   2640              pRsp->cnt = cnt;
   2641              msg++; // pass cnt
   2642              osal_memcpy( pRsp->epList, msg, cnt );
   2643            }
   2644          
   2645            return ( pRsp );
   2646          }
   2647          
   2648          /*********************************************************************
   2649           * @fn          ZDO_ParseServerDiscRsp
   2650           *
   2651           * @brief       Parse the Server_Discovery_rsp message.
   2652           *
   2653           * @param       inMsg - incoming message.
   2654           * @param       pRsp - place to put the parsed information.
   2655           *
   2656           * @return      none
   2657           */
   2658          void ZDO_ParseServerDiscRsp( zdoIncomingMsg_t *inMsg, ZDO_ServerDiscRsp_t *pRsp )
   2659          {
   2660            pRsp->status = inMsg->asdu[0];
   2661            pRsp->serverMask = BUILD_UINT16( inMsg->asdu[1], inMsg->asdu[2] );
   2662          }
   2663          
   2664          /*********************************************************************
   2665           * @fn          ZDO_ParseMgmtLqiRsp
   2666           *
   2667           * @brief       This function parses the incoming Management
   2668           *              LQI response
   2669           *
   2670           * @param       inMsg - incoming message
   2671           *
   2672           * @return      a pointer to parsed response structure (NULL if not allocated).
   2673           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2674           *          by the calling function [osal_mem_free()].
   2675           */
   2676          ZDO_MgmtLqiRsp_t *ZDO_ParseMgmtLqiRsp( zdoIncomingMsg_t *inMsg )
   2677          {
   2678            ZDO_MgmtLqiRsp_t *pRsp;
   2679            uint8 status;
   2680            uint8 startIndex = 0;
   2681            uint8 neighborLqiCount = 0;
   2682            uint8 neighborLqiEntries = 0;
   2683            uint8 *msg;
   2684          
   2685            msg = inMsg->asdu;
   2686          
   2687            status = *msg++;
   2688            if ( status == ZSuccess )
   2689            {
   2690              neighborLqiEntries = *msg++;
   2691              startIndex = *msg++;
   2692              neighborLqiCount = *msg++;
   2693            }
   2694          
   2695            // Allocate a buffer big enough to handle the list.
   2696            pRsp = (ZDO_MgmtLqiRsp_t *)osal_mem_alloc(
   2697                      sizeof( ZDO_MgmtLqiRsp_t ) + (neighborLqiCount * sizeof( neighborLqiItem_t )) );
   2698            if ( pRsp )
   2699            {
   2700              uint8 x;
   2701              neighborLqiItem_t *pList = pRsp->list;
   2702              pRsp->status = status;
   2703              pRsp->neighborLqiEntries = neighborLqiEntries;
   2704              pRsp->startIndex = startIndex;
   2705              pRsp->neighborLqiCount = neighborLqiCount;
   2706          
   2707              for ( x = 0; x < neighborLqiCount; x++ )
   2708              {
   2709                osal_cpyExtAddr(pList->extPANId, msg);   //Copy extended PAN ID
   2710                msg += Z_EXTADDR_LEN;
   2711          
   2712                msg += Z_EXTADDR_LEN;  // Throwing away IEEE.
   2713                pList->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2714                msg += 2 + 1 + 1 + 1;      // Skip DeviceType, RxOnIdle, Rlationship, PermitJoining and Depth
   2715                pList->rxLqi = *msg++;
   2716                pList->txQuality = 0;  // This is not specified OTA by ZigBee 1.1.
   2717                pList++;
   2718              }
   2719            }
   2720          
   2721            return ( pRsp );
   2722          }
   2723          
   2724          /*********************************************************************
   2725           * @fn          ZDO_ParseMgmNwkDiscRsp
   2726           *
   2727           * @brief       This function parses the incoming Management
   2728           *              Network Discover response.
   2729           *
   2730           * @param       inMsg - incoming message
   2731           *
   2732           * @return      pointer to parsed response.  This structure was
   2733           *          allocated using osal_mem_alloc, so it must be freed
   2734           *          by the calling function [osal_mem_free()].
   2735           */
   2736          ZDO_MgmNwkDiscRsp_t *ZDO_ParseMgmNwkDiscRsp( zdoIncomingMsg_t *inMsg )
   2737          {
   2738            ZDO_MgmNwkDiscRsp_t *pRsp;
   2739            uint8 status;
   2740            uint8 networkCount = 0;
   2741            uint8 startIndex = 0;
   2742            uint8 networkListCount = 0;
   2743            uint8 *msg;
   2744          
   2745            msg = inMsg->asdu;
   2746            status = *msg++;
   2747          
   2748            if ( status == ZSuccess )
   2749            {
   2750              networkCount = *msg++;
   2751              startIndex = *msg++;
   2752              networkListCount = *msg++;
   2753            }
   2754          
   2755            // Allocate a buffer big enough to handle the list.
   2756            pRsp = (ZDO_MgmNwkDiscRsp_t *)osal_mem_alloc( sizeof( ZDO_MgmNwkDiscRsp_t )
   2757                                            + (networkListCount * sizeof( mgmtNwkDiscItem_t )) );
   2758            if ( pRsp )
   2759            {
   2760              uint8 x;
   2761              mgmtNwkDiscItem_t *pList;
   2762          
   2763              pRsp->status = status;
   2764              pRsp->networkCount = networkCount;
   2765              pRsp->startIndex = startIndex;
   2766              pRsp->networkListCount = networkListCount;
   2767              pList = pRsp->list;
   2768          
   2769              for ( x = 0; x < networkListCount; x++ )
   2770              {
   2771                osal_cpyExtAddr(pList->extendedPANID, msg);   //Copy extended PAN ID
   2772                pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2773                msg += Z_EXTADDR_LEN;
   2774          
   2775                pList->logicalChannel = *msg++;
   2776                pList->stackProfile = (*msg) & 0x0F;
   2777                pList->version = (*msg++ >> 4) & 0x0F;
   2778                pList->beaconOrder = (*msg) & 0x0F;
   2779                pList->superFrameOrder = (*msg++ >> 4) & 0x0F;
   2780                pList->permitJoining = *msg++;
   2781                pList++;
   2782              }
   2783            }
   2784          
   2785            return ( pRsp );
   2786          }
   2787          
   2788          /*********************************************************************
   2789           * @fn          ZDO_ParseMgmtRtgRsp
   2790           *
   2791           * @brief       This function parses the incoming Management
   2792           *              Routing response.
   2793           *
   2794           * @param       inMsg - incoming message
   2795           *
   2796           * @return      a pointer to parsed response structure (NULL if not allocated).
   2797           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2798           *          by the calling function [osal_mem_free()].
   2799           */
   2800          ZDO_MgmtRtgRsp_t *ZDO_ParseMgmtRtgRsp( zdoIncomingMsg_t *inMsg )
   2801          {
   2802            ZDO_MgmtRtgRsp_t *pRsp;
   2803            uint8 status;
   2804            uint8 rtgCount = 0;
   2805            uint8 startIndex = 0;
   2806            uint8 rtgListCount = 0;
   2807            uint8 *msg;
   2808          
   2809            msg = inMsg->asdu;
   2810          
   2811            status = *msg++;
   2812            if ( status == ZSuccess )
   2813            {
   2814              rtgCount = *msg++;
   2815              startIndex = *msg++;
   2816              rtgListCount = *msg++;
   2817            }
   2818          
   2819            // Allocate a buffer big enough to handle the list
   2820            pRsp = (ZDO_MgmtRtgRsp_t *)osal_mem_alloc(
   2821                    sizeof( ZDO_MgmtRtgRsp_t ) + (rtgListCount * sizeof( rtgItem_t )) );
   2822            if ( pRsp )
   2823            {
   2824              uint8 x;
   2825              rtgItem_t *pList = pRsp->list;
   2826              pRsp->status = status;
   2827              pRsp->rtgCount = rtgCount;
   2828              pRsp->startIndex = startIndex;
   2829              pRsp->rtgListCount = rtgListCount;
   2830          
   2831              for ( x = 0; x < rtgListCount; x++ )
   2832              {
   2833                pList->dstAddress = BUILD_UINT16( msg[0], msg[1] );
   2834                msg += 2;
   2835                pList->status = *msg++;
   2836                pList->nextHopAddress = BUILD_UINT16( msg[0], msg[1] );
   2837                msg += 2;
   2838                pList++;
   2839              }
   2840            }
   2841          
   2842            return ( pRsp );
   2843          }
   2844          
   2845          /*********************************************************************
   2846           * @fn          ZDO_ParseMgmtBindRsp
   2847           *
   2848           * @brief       This function parses the incoming Management
   2849           *              Binding response.
   2850           *
   2851           * @param       inMsg - pointer to message to parse
   2852           *
   2853           * @return      a pointer to parsed response structure (NULL if not allocated).
   2854           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2855           *          by the calling function [osal_mem_free()].
   2856           */
   2857          ZDO_MgmtBindRsp_t *ZDO_ParseMgmtBindRsp( zdoIncomingMsg_t *inMsg )
   2858          {
   2859            ZDO_MgmtBindRsp_t *pRsp;
   2860            uint8 status;
   2861            uint8 bindingCount = 0;
   2862            uint8 startIndex = 0;
   2863            uint8 bindingListCount = 0;
   2864            uint8 *msg;
   2865          
   2866            msg = inMsg->asdu;
   2867          
   2868            status = *msg++;
   2869            if ( status == ZSuccess )
   2870            {
   2871              bindingCount = *msg++;
   2872              startIndex = *msg++;
   2873              bindingListCount = *msg++;
   2874            }
   2875          
   2876            // Allocate a buffer big enough to handle the list
   2877            pRsp = (ZDO_MgmtBindRsp_t *)osal_mem_alloc(
   2878                    (sizeof ( ZDO_MgmtBindRsp_t ) + (bindingListCount * sizeof( apsBindingItem_t ))) );
   2879            if ( pRsp )
   2880            {
   2881              uint8 x;
   2882              apsBindingItem_t *pList = pRsp->list;
   2883              pRsp->status = status;
   2884              pRsp->bindingCount = bindingCount;
   2885              pRsp->startIndex = startIndex;
   2886              pRsp->bindingListCount = bindingListCount;
   2887          
   2888              for ( x = 0; x < bindingListCount; x++ )
   2889              {
   2890                osal_cpyExtAddr( pList->srcAddr, msg );
   2891                msg += Z_EXTADDR_LEN;
   2892                pList->srcEP = *msg++;
   2893          
   2894                // Get the Cluster ID
   2895          
   2896                pList->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2897                msg += 2;
   2898                pList->dstAddr.addrMode = *msg++;
   2899                if ( pList->dstAddr.addrMode == Addr64Bit )
   2900                {
   2901                  osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2902                  msg += Z_EXTADDR_LEN;
   2903                  pList->dstEP = *msg++;
   2904                }
   2905                else
   2906                {
   2907                  pList->dstAddr.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2908                  msg += 2;
   2909                }
   2910          
   2911                pList++;
   2912              }
   2913            }
   2914          
   2915            return ( pRsp );
   2916          }
   2917          
   2918          /*********************************************************************
   2919           * @fn          ZDO_ParseUserDescRsp
   2920           *
   2921           * @brief       This function parses the incoming User
   2922           *              Descriptor Response.
   2923           *
   2924           * @param       inMsg - incoming response message
   2925           *
   2926           * @return      a pointer to parsed response structure (NULL if not allocated).
   2927           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2928           *          by the calling function [osal_mem_free()].
   2929           */
   2930          ZDO_UserDescRsp_t *ZDO_ParseUserDescRsp( zdoIncomingMsg_t *inMsg )
   2931          {
   2932            ZDO_UserDescRsp_t *pRsp;
   2933            uint8 *msg;
   2934            uint8 descLen = 0;
   2935          
   2936            msg = inMsg->asdu;
   2937          
   2938            if ( msg[0] == ZSuccess )
   2939              descLen = msg[3];
   2940          
   2941            pRsp = (ZDO_UserDescRsp_t *)osal_mem_alloc( sizeof ( ZDO_UserDescRsp_t ) + descLen );
   2942            if ( pRsp )
   2943            {
   2944              pRsp->status = msg[0];
   2945              pRsp->nwkAddr = BUILD_UINT16( msg[1], msg[2] );
   2946              pRsp->length = descLen;
   2947              if ( descLen )
   2948                osal_memcpy( pRsp->desc, &msg[4], descLen );
   2949            }
   2950          
   2951            return ( pRsp );
   2952          }
   2953          
   2954          /*********************************************************************
   2955           * @fn          ZDO_ParseSimpleDescBuf
   2956           *
   2957           * @brief       Parse a byte sequence representation of a Simple Descriptor.
   2958           *
   2959           * @param       buf  - pointer to a byte array representing a Simple Desc.
   2960           * @param       desc - SimpleDescriptionFormat_t *
   2961           *
   2962           *              This routine allocates storage for the cluster IDs because
   2963           *              they are 16-bit and need to be aligned to be properly processed.
   2964           *              This routine returns non-zero if an allocation fails.
   2965           *
   2966           *              NOTE: This means that the caller or user of the input structure
   2967           *                    is responsible for freeing the memory
   2968           *
   2969           * @return      0: success
   2970           *              1: failure due to malloc failure.
   2971           */
   2972          uint8 ZDO_ParseSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   2973          {
   2974            uint8 num, i;
   2975          
   2976            desc->EndPoint = *buf++;
   2977            desc->AppProfId = BUILD_UINT16( buf[0], buf[1] );
   2978            buf += 2;
   2979            desc->AppDeviceId = BUILD_UINT16( buf[0], buf[1] );
   2980            buf += 2;
   2981            desc->AppDevVer = *buf >> 4;
   2982          
   2983            desc->Reserved = 0;
   2984            buf++;
   2985          
   2986            // move in input cluster list (if any). allocate aligned memory.
   2987            num = desc->AppNumInClusters = *buf++;
   2988            if ( num )
   2989            {
   2990              if (!(desc->pAppInClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   2991              {
   2992                // malloc failed. we're done.
   2993                return 1;
   2994              }
   2995              for (i=0; i<num; ++i)
   2996              {
   2997                desc->pAppInClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   2998                buf += 2;
   2999              }
   3000            }
   3001          
   3002            // move in output cluster list (if any). allocate aligned memory.
   3003            num = desc->AppNumOutClusters = *buf++;
   3004            if (num)
   3005            {
   3006              if (!(desc->pAppOutClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   3007              {
   3008                // malloc failed. free input cluster list memory if there is any
   3009                if ( desc->pAppInClusterList != NULL )
   3010                {
   3011                  osal_mem_free(desc->pAppInClusterList);
   3012                }
   3013                return 1;
   3014              }
   3015              for (i=0; i<num; ++i)
   3016              {
   3017                desc->pAppOutClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   3018                buf += 2;
   3019              }
   3020            }
   3021            return 0;
   3022          }
   3023          
   3024          /*********************************************************************
   3025           * @fn          ZDO_ParseDeviceAnnce
   3026           *
   3027           * @brief       Parse a Device Announce message.
   3028           *
   3029           * @param       inMsg - Incoming message
   3030           * @param       pAnnce - place to put the parsed information
   3031           *
   3032           * @return      none
   3033           */
   3034          void ZDO_ParseDeviceAnnce( zdoIncomingMsg_t *inMsg, ZDO_DeviceAnnce_t *pAnnce )
   3035          {
   3036            uint8 *msg;
   3037          
   3038            // Parse incoming message
   3039            msg = inMsg->asdu;
   3040            pAnnce->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   3041            msg += 2;
   3042            osal_cpyExtAddr( pAnnce->extAddr, msg );
   3043            msg += Z_EXTADDR_LEN;
   3044            pAnnce->capabilities = *msg;
   3045          }
   3046          
   3047          /*********************************************************************
   3048           * @fn          ZDO_ParseMgmtNwkUpdateNotify
   3049           *
   3050           * @brief       This function handles parsing of the incoming Management
   3051           *              Network Update notify.
   3052           *
   3053           * @param       inMsg - incoming message (request)
   3054           *
   3055           * @return      a pointer to parsed response structure (NULL if not allocated).
   3056           *          This structure was allocated using osal_mem_alloc, so it must be freed
   3057           *          by the calling function [osal_mem_free()].
   3058           */
   3059          ZDO_MgmtNwkUpdateNotify_t *ZDO_ParseMgmtNwkUpdateNotify( zdoIncomingMsg_t *inMsg )
   3060          {
   3061            uint8 status;
   3062            uint32 scannedChannels = 0;
   3063            uint16 totalTransmissions = 0;
   3064            uint16 transmissionFailures = 0;
   3065            uint8 listCount = 0;
   3066            uint8 *msg = inMsg->asdu;
   3067            ZDO_MgmtNwkUpdateNotify_t *pRsp;
   3068          
   3069            status = *msg++;
   3070            if ( status == ZSuccess )
   3071            {
   3072              scannedChannels = osal_build_uint32( msg, 4 );
   3073              msg += 4;
   3074              totalTransmissions = BUILD_UINT16( msg[0], msg[1] );
   3075              msg += 2;
   3076              transmissionFailures = BUILD_UINT16( msg[0], msg[1] );
   3077              msg += 2;
   3078              listCount = *msg++;
   3079            }
   3080          
   3081            pRsp = (ZDO_MgmtNwkUpdateNotify_t *)osal_mem_alloc( sizeof ( ZDO_MgmtNwkUpdateNotify_t ) + listCount );
   3082          
   3083            if ( pRsp )
   3084            {
   3085              pRsp->status = status;
   3086              pRsp->scannedChannels = scannedChannels;
   3087              pRsp->totalTransmissions = totalTransmissions;
   3088              pRsp->transmissionFailures = transmissionFailures;
   3089              pRsp->listCount = listCount;
   3090          
   3091              // Allocate a buffer big enough to handle the list.
   3092              if ( listCount > 0 )
   3093                osal_memcpy( pRsp->energyValues, msg, listCount );
   3094            }
   3095          
   3096            return ( pRsp );
   3097          }
   3098          
   3099          /*********************************************************************
   3100           * @fn          ZDO_ParseMgmtNwkUpdateReq
   3101           *
   3102           * @brief       This function handles parsing the incoming Management
   3103           *              Network Update request and starts the request (if needed).
   3104           *
   3105           * @param       inMsg - incoming message (request)
   3106           * @param       pReq - pointer to place to parse message to
   3107           *
   3108           * @return      none
   3109           */
   3110          void ZDO_ParseMgmtNwkUpdateReq( zdoIncomingMsg_t *inMsg, ZDO_MgmtNwkUpdateReq_t *pReq )
   3111          {
   3112            uint8 *msg = inMsg->asdu;
   3113          
   3114            pReq->channelMask = osal_build_uint32( msg, 4 );
   3115            msg += 4;
   3116            pReq->scanDuration = *msg++;
   3117          
   3118            if ( pReq->scanDuration <= 0x05 )
   3119            {
   3120              // Request is to scan over channelMask
   3121              pReq->scanCount = *msg;
   3122            }
   3123            else if ( ( pReq->scanDuration == 0xFE ) || ( pReq->scanDuration == 0xFF ) )
   3124            {
   3125              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   3126              pReq->nwkUpdateId = *msg++;
   3127          
   3128              if ( pReq->scanDuration == 0xFF )
   3129              {
   3130                pReq->nwkManagerAddr = BUILD_UINT16( msg[0], msg[1] );
   3131              }
   3132            }
   3133          }
   3134          
   3135          /*********************************************************************
   3136          *********************************************************************/
   3137          
   3138          

Errors: 25
Warnings: 2
