###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:01 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mac\low_level\srf04\single_chip\mac_mcu.c       #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mac\low_level\srf04\single_chip\mac_mcu.c -D    #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -lC                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ -lA C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\ #
#                          Projects\zstack\Samples\mynetApp\CC2530DB\Coordina #
#                          torEB\List\ --diag_suppress Pe001,Pa010 -o         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\mac_mcu.lst                                     #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\mac_mcu.r51                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2010-01-08 14:36:19 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21466 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  extern uint8 macChipVersion;
                             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\mac\low_level\srf04\single_chip\mac_mcu.h",193  Warning[Pe012]: 
          parsing restarts here after previous syntax error
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                           Defines
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          #if !defined (OSC32K_CRYSTAL_INSTALLED) || (defined (OSC32K_CRYSTAL_INSTALLED) && (OSC32K_CRYSTAL_INSTALLED == TRUE))
     71          #define T2CNF_BASE_VALUE    (RUN | SYNC)
     72          #else
     73          #define T2CNF_BASE_VALUE     RUN
     74          #endif
     75          
     76          /* for optimized indexing of uint32's */
     77          #if HAL_MCU_LITTLE_ENDIAN()
     78          #define UINT32_NDX0   0
     79          #define UINT32_NDX1   1
     80          #define UINT32_NDX2   2
     81          #define UINT32_NDX3   3
     82          #else
     83          #define UINT32_NDX0   3
     84          #define UINT32_NDX1   2
     85          #define UINT32_NDX2   1
     86          #define UINT32_NDX3   0
     87          #endif
     88          
     89          /* ------------------------------------------------------------------------------------------------
     90           *                                        Local Variables
     91           * ------------------------------------------------------------------------------------------------
     92           */
     93          uint8       macChipVersion = 0;
     94          static int8 maxRssi;
     95          
     96          
     97          /*
     98           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
     99           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
    100           *  needs to be accounted for in this variable.
    101           */
    102          static uint32 accumulatedOverflowCount = 0;
    103          
    104          /* Function pointer for the random seed callback */
    105          static macRNGFcn_t pRandomSeedCB = NULL;
    106          /* ------------------------------------------------------------------------------------------------
    107           *                                       Local Prototypes
    108           * ------------------------------------------------------------------------------------------------
    109           */
    110          static void mcuRecordMaxRssiIsr(void);
    111          static uint32 macMcuOverflowGetCompare(void);
    112          
    113          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
    114          
    115          /**************************************************************************************************
    116           * @fn          MAC_SetRandomSeedCB
    117           *
    118           * @brief       Set the function pointer for the random seed callback.
    119           *
    120           * @param       pCBFcn - function pointer of the random seed callback
    121           *
    122           * @return      none
    123           **************************************************************************************************
    124           */
    125          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
    126          {
    127            pRandomSeedCB = pCBFcn;
    128          }
    129          
    130          /**************************************************************************************************
    131           * @fn          macMcuInit
    132           *
    133           * @brief       Initialize the MCU.
    134           *
    135           * @param       none
    136           *
    137           * @return      none
    138           **************************************************************************************************
    139           */
    140          MAC_INTERNAL_API void macMcuInit(void)
    141          {
    142            halIntState_t  s;
    143          
    144            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    145             * too many false frames are received if the reset value is used. Make it more likely to detect
    146             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    147             * above the correlation threshold, and make sync word detection less likely by raising the
    148             * correlation threshold.
    149             */
    150            MDMCTRL1 = CORR_THR;
    151          
    152            /* tuning adjustments for optimal radio performance; details available in datasheet */
    153            RXCTRL = 0x3F;
    154          
    155            /* Raises the CCA threshold from about -108dBm to about -80 dBm input level.
    156             */
    157            CCACTRL0 = CCA_THR;
    158          
    159            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    160             * details available in datasheet.
    161             */
    162            MDMCTRL0 = 0x85;
    163          
    164            /* Adjust current in synthesizer; details available in datasheet. */
    165            FSCTRL = 0x5A;
    166          
    167            /* Adjust current in VCO; details available in datasheet. */
    168            FSCAL1 = 0x00;
    169          
    170            /* Adjust target value for AGC control loop; details available in datasheet. */
    171            AGCCTRL1 = 0x15;
    172          
    173            /* Disable source address matching an autopend for now */
    174            SRCMATCH = 0;
    175          
    176            /* Tune ADC performance, details available in datasheet. */
    177            ADCTEST0 = 0x10;
    178            ADCTEST1 = 0x0E;
    179            ADCTEST2 = 0x03;
    180          
    181            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    182             * Reduces spurious emissions close to signal.
    183             */
    184            TXFILTCFG = TXFILTCFG_RESET_VALUE;
    185          
    186            /* disable the CSPT register compare function */
    187            CSPT = 0xFF;
    188          
    189            /* enable general RF interrupts */
    190            IEN2 |= RFIE;
    191          
    192            /* enable general REERR interrupts */
    193            IEN0 |= RFERRIE;
    194          
    195            /* set RF interrupts one notch above lowest priority (four levels available) */
    196            IP0 |=  IP_RFERR_RF_DMA_BV;
    197            IP1 &= ~IP_RFERR_RF_DMA_BV;
    198          
    199            /* read chip version */
    200            macChipVersion = CHVER;
    201          
    202            /*-------------------------------------------------------------------------------
    203             *  Initialize MAC timer.
    204             */
    205          
    206            /* set timer rollover */
    207            HAL_ENTER_CRITICAL_SECTION(s);
    208            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
    209            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
    210            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
    211            HAL_EXIT_CRITICAL_SECTION(s);
    212          
    213            /* start timer */
    214            MAC_RADIO_TIMER_WAKE_UP();
    215          
    216            /* Enable latch mode */
    217            T2CTRL |= LATCH_MODE;
    218          
    219            /* enable timer interrupts */
    220            T2IE = 1;
    221          
    222           /*----------------------------------------------------------------------------------------------
    223            *  Initialize random seed value.
    224            */
    225          
    226            /*
    227             *  Set radio for infinite reception.  Once radio reaches this state,
    228             *  it will stay in receive mode regardless RF activity.
    229             */
    230            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
    231          
    232            /* turn on the receiver */
    233            macRxOn();
    234          
    235            /*
    236             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    237             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    238             */
    239            while (!(RSSISTAT & 0x01));
    240          
    241            /* put 16 random bits into the seed value */
    242            {
    243              uint16 rndSeed;
    244              uint8  i;
    245          
    246              rndSeed = 0;
    247          
    248              for(i=0; i<16; i++)
    249              {
    250                /* use most random bit of analog to digital receive conversion to populate the random seed */
    251                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
    252              }
    253          
    254              /*
    255               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    256               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    257               *  be zero or 0x0380.  The following check makes sure this does not happen.
    258               */
    259              if (rndSeed == 0x0000 || rndSeed == 0x0380)
    260              {
    261                rndSeed = 0xBABE; /* completely arbitrary "random" value */
    262              }
    263          
    264              /*
    265               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    266               *  of RNDL to RNDH before writing new the value to RNDL.
    267               */
    268              RNDL = rndSeed & 0xFF;
    269              RNDL = rndSeed >> 8;
    270            }
    271            
    272            /* Read 16*8 random bits and store them in flash for future use in random
    273               key generation for CBKE key establishment */
    274            if( pRandomSeedCB )
    275            {
    276              uint8 randomSeed[MAC_RANDOM_SEED_LEN];
    277              uint8 i,j;
    278              
    279              for(i = 0; i < 16; i++)
    280              {
    281                uint8 rndByte = 0;
    282                for(j = 0; j < 8; j++)
    283                {
    284                  /* use most random bit of analog to digital receive conversion to 
    285                     populate the random seed */
    286                  rndByte = (rndByte << 1) | (RFRND & 0x01);
    287                }
    288                randomSeed[i] = rndByte;
    289                
    290              }
    291              pRandomSeedCB( randomSeed ); 
    292            }
    293              
    294            /* turn off the receiver */
    295            macRxOff();
    296          
    297            /* take receiver out of infinite reception mode; set back to normal operation */
    298            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
    299          
    300            /* Turn on autoack */
    301            MAC_RADIO_TURN_ON_AUTO_ACK();
    302          
    303            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    304            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
    305            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
    306          }
    307          
    308          
    309          /**************************************************************************************************
    310           * @fn          macMcuRandomByte
    311           *
    312           * @brief       Returns a random byte using a special hardware feature that generates new
    313           *              random values based on the truly random seed set earlier.
    314           *
    315           * @param       none
    316           *
    317           * @return      a random byte
    318           **************************************************************************************************
    319           */
    320          MAC_INTERNAL_API uint8 macMcuRandomByte(void)
    321          {
    322            /* clock the random generator to get a new random value */
    323            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
    324          
    325            /* return new randomized value from hardware */
    326            return(RNDH);
    327          }
    328          
    329          
    330          /**************************************************************************************************
    331           * @fn          macMcuRandomWord
    332           *
    333           * @brief       Returns a random word using a special hardware feature that generates new
    334           *              random values based on the truly random seed set earlier.
    335           *
    336           * @param       none
    337           *
    338           * @return      a random word
    339           **************************************************************************************************
    340           */
    341          MAC_INTERNAL_API uint16 macMcuRandomWord(void)
    342          {
    343            uint16 random_word;
    344          
    345            /* clock the random generator to get a new random value */
    346            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
    347          
    348            /* read random word */
    349            random_word  = (RNDH << 8);
    350            random_word +=  RNDL;
    351          
    352            /* return new randomized value from hardware */
    353            return(random_word);
    354          }
    355          
    356          
    357          /**************************************************************************************************
    358           * @fn          macMcuTimerForceDelay
    359           *
    360           * @brief       Delay the timer by the requested number of ticks.
    361           *
    362           * @param       none
    363           *
    364           * @return      none
    365           **************************************************************************************************
    366           */
    367          MAC_INTERNAL_API void macMcuTimerForceDelay(uint16 x)
    368          {
    369            halIntState_t  s;
    370          
    371            HAL_ENTER_CRITICAL_SECTION(s);
    372            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    373            T2M0 = (x) & 0xFF;
    374            T2M1 = (x) >> 8;
    375            HAL_EXIT_CRITICAL_SECTION(s);
    376          }
    377          
    378          /**************************************************************************************************
    379           * @fn          macMcuTimerCapture
    380           *
    381           * @brief       Returns the last timer capture.  This capture should have occurred at the
    382           *              receive time of the last frame (the last time SFD transitioned to active).
    383           *
    384           * @param       none
    385           *
    386           * @return      last capture of hardware timer (full 16-bit value)
    387           **************************************************************************************************
    388           */
    389          MAC_INTERNAL_API uint16 macMcuTimerCapture(void)
    390          {
    391            uint16         timerCapture;
    392            halIntState_t  s;
    393          
    394            HAL_ENTER_CRITICAL_SECTION(s);
    395            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
    396            timerCapture = T2M1 << 8;
    397            timerCapture |= T2M0;
    398            HAL_EXIT_CRITICAL_SECTION(s);
    399          
    400            return (timerCapture);
    401          }
    402          
    403          
    404          /**************************************************************************************************
    405           * @fn          macMcuOverflowCount
    406           *
    407           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    408           *              The overflow count actually is 24 bits of information.
    409           *
    410           * @param       none
    411           *
    412           * @return      value of overflow counter
    413           **************************************************************************************************
    414           */
    415          MAC_INTERNAL_API uint32 macMcuOverflowCount(void)
    416          {
    417            uint32         overflowCount;
    418            halIntState_t  s;
    419          
    420            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    421          
    422            HAL_ENTER_CRITICAL_SECTION(s);
    423          
    424            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    425            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    426          
    427            /* Latch the entire T2MOVFx first by reading T2M0. */
    428            T2M0;
    429            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
    430            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    431            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
    432            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
    433            HAL_EXIT_CRITICAL_SECTION(s);
    434          
    435            return (overflowCount);
    436          }
    437          
    438          
    439          /**************************************************************************************************
    440           * @fn          macMcuOverflowCapture
    441           *
    442           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    443           *              captures the overflow counter when the regular hardware timer is captured.
    444           *
    445           * @param       none
    446           *
    447           * @return      last capture of overflow count
    448           **************************************************************************************************
    449           */
    450          MAC_INTERNAL_API uint32 macMcuOverflowCapture(void)
    451          {
    452            uint32         overflowCapture;
    453            halIntState_t  s;
    454          
    455            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    456            HAL_ENTER_CRITICAL_SECTION(s);
    457            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
    458            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
    459            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
    460            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
    461            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
    462            HAL_EXIT_CRITICAL_SECTION(s);
    463          
    464            return (overflowCapture);
    465          }
    466          
    467          
    468          /**************************************************************************************************
    469           * @fn          macMcuOverflowSetCount
    470           *
    471           * @brief       Sets the value of the hardware overflow counter.
    472           *
    473           * @param       count - new overflow count value
    474           *
    475           * @return      none
    476           **************************************************************************************************
    477           */
    478          MAC_INTERNAL_API void macMcuOverflowSetCount(uint32 count)
    479          {
    480            halIntState_t  s;
    481          
    482            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
    483          
    484            /* save the current overflow count */
    485            accumulatedOverflowCount += macMcuOverflowCount();
    486          
    487            /* deduct the initial count */
    488            accumulatedOverflowCount -= count;
    489          
    490            HAL_ENTER_CRITICAL_SECTION(s);
    491            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    492          
    493            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    494            /* T2OF2 must be written last */
    495            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
    496            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
    497            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
    498            HAL_EXIT_CRITICAL_SECTION(s);
    499          }
    500          
    501          
    502          /**************************************************************************************************
    503           * @fn          macMcuOverflowSetCompare
    504           *
    505           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    506           *              count equals this compare value.
    507           *
    508           * @param       count - overflow count compare value
    509           *
    510           * @return      none
    511           **************************************************************************************************
    512           */
    513          MAC_INTERNAL_API void macMcuOverflowSetCompare(uint32 count)
    514          {
    515            halIntState_t  s;
    516            uint8 enableCompareInt = 0;
    517          
    518            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
    519          
    520            HAL_ENTER_CRITICAL_SECTION(s);
    521          
    522            /*  Disable overflow compare interrupts. */
    523            if (T2IRQM & TIMER2_OVF_COMPARE1M)
    524            {
    525              enableCompareInt = 1;
    526              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
    527            }
    528          
    529            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    530          
    531            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    532            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
    533            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
    534            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
    535          
    536            /*
    537             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    538             *  in case a false match was generated as the multi-byte compare value was written.
    539             */
    540            T2IRQF &= ~TIMER2_OVF_COMPARE1F;
    541          
    542            /* re-enable overflow compare interrupts if they were previously enabled */
    543            if (enableCompareInt)
    544            {
    545              T2IRQM |= TIMER2_OVF_COMPARE1M;
    546            }
    547          
    548            HAL_EXIT_CRITICAL_SECTION(s);
    549          }
    550          
    551          
    552          /**************************************************************************************************
    553           * @fn          macMcuOverflowGetCompare
    554           *
    555           * @brief       Get overflow count compare value.
    556           *
    557           * @param       none
    558           *
    559           * @return      overflow count compare value
    560           **************************************************************************************************
    561           */
    562          MAC_INTERNAL_API uint32 macMcuOverflowGetCompare(void)
    563          {
    564            halIntState_t  s;
    565            uint32         compare;
    566          
    567            HAL_ENTER_CRITICAL_SECTION(s);
    568          
    569            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    570          
    571            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    572            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
    573            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
    574            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
    575            ((uint8 *)&compare)[UINT32_NDX3] = 0;
    576          
    577            HAL_EXIT_CRITICAL_SECTION(s);
    578          
    579            return(compare);
    580          }
    581          
    582          
    583          /**************************************************************************************************
    584           * @fn          macMcuTimer2Isr
    585           *
    586           * @brief       Interrupt service routine for timer2, the MAC timer.
    587           *
    588           * @param       none
    589           *
    590           * @return      none
    591           **************************************************************************************************
    592           */
    593          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
    594          {
    595            uint8 t2irqm = T2IRQM;
    596            uint8 t2irqf = T2IRQF;
    597          
    598            /*------------------------------------------------------------------------------------------------
    599             *  Overflow compare interrupt - triggers when then overflow counter is
    600             *  equal to the overflow compare register.
    601             */
    602            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
    603            {
    604          
    605              /* call function for dealing with the timer compare interrupt */
    606              macBackoffTimerCompareIsr();
    607          
    608              /* clear overflow compare interrupt flag */
    609              T2IRQF &= ~TIMER2_OVF_COMPARE1F;
    610            }
    611          
    612            /*------------------------------------------------------------------------------------------------
    613             *  Overflow interrupt - triggers when the hardware timer rolls over.
    614             */
    615            else if ((t2irqf & TIMER2_PERF) & t2irqm)
    616            {
    617              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    618              mcuRecordMaxRssiIsr();
    619          
    620              /* clear the interrupt flag */
    621              T2IRQF &= ~TIMER2_PERF;
    622            }
    623          }
    624          
    625          
    626          /**************************************************************************************************
    627           * @fn          macMcuTimer2OverflowWorkaround
    628           *
    629           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    630           *              the comparator. The interrupt is only generated when the current count is equal to
    631           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    632           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    633           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    634           *              comparator.
    635           *
    636           * @param       none
    637           *
    638           * @return      none
    639           **************************************************************************************************
    640           */
    641          void macMcuTimer2OverflowWorkaround(void)
    642          {
    643            if (T2IRQM & TIMER2_OVF_COMPARE1F)
    644            {
    645              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    646              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
    647              {
    648                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
    649                {
    650                  /* Set the flag to trigger the timer compare interrupt */
    651                  macBackoffTimerCompareIsr();
    652                  T2IRQF &= ~TIMER2_OVF_COMPARE1F;
    653                }
    654              }
    655            }
    656          }
    657          
    658          
    659          /**************************************************************************************************
    660           * @fn          macMcuPrecisionCount
    661           *
    662           * @brief       This function is used by higher layer to read a free running counter driven by
    663           *              MAC timer.
    664           *
    665           * @param       none
    666           *
    667           * @return      overflowCount
    668           **************************************************************************************************
    669           */
    670          uint16 macMcuPrecisionCount(void)
    671          {
    672            uint16         overflowCount;
    673            halIntState_t  s;
    674          
    675            HAL_ENTER_CRITICAL_SECTION(s);
    676          
    677            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    678            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    679          
    680            /* Latch the entire T2MOVFx first by reading T2M0.
    681             * T2M0 and T2MOVF2 are discarded.
    682             */
    683            T2M0;
    684            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
    685            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    686            HAL_EXIT_CRITICAL_SECTION(s);
    687          
    688            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode.
    689             * It's okay to let it overflow since only LSBs are used.
    690             */
    691            overflowCount += (uint16)accumulatedOverflowCount;
    692          
    693            return(overflowCount);
    694          }
    695          
    696          
    697          /**************************************************************************************************
    698           * @fn          macMcuRfIsr
    699           *
    700           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    701           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    702           *
    703           * @param       none
    704           *
    705           * @return      none
    706           **************************************************************************************************
    707           */
    708          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
    709          {
    710            uint8 rfim;
    711          
    712            rfim = RFIRQM1;
    713          
    714            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    715             *  to allow the interrupts to be nested.
    716             */
    717            S1CON = 0x00;
    718          
    719            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
    720            {
    721              /*
    722               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    723               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    724               *  long critical sections.
    725               */
    726              /* clear flag */
    727              RFIRQF1 = ~IRQ_CSP_MANINT;
    728              macCspTxIntIsr();
    729            }
    730            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
    731            {
    732              /* clear flag */
    733              RFIRQF1 = ~IRQ_CSP_STOP;
    734              macCspTxStopIsr();
    735            }
    736            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
    737            {
    738              /* disable interrupt - set up is for "one shot" operation */
    739              RFIRQM1 &= ~IM_TXACKDONE;
    740              macRxAckTxDoneCallback();
    741            }
    742          
    743            rfim = RFIRQM0;
    744          
    745            /* process RFIRQF0 next */
    746            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
    747            {
    748              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    749              do
    750              {
    751                macRxThresholdIsr();
    752                RFIRQF0 = ~IRQ_FIFOP;
    753              } while (FSMSTAT1 & FIFOP);
    754            }
    755          }
    756          
    757          
    758          /**************************************************************************************************
    759           * @fn          macMcuRfErrIsr
    760           *
    761           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    762           *              overflow condition is handled.
    763           *
    764           * @param       none
    765           *
    766           * @return      none
    767           **************************************************************************************************
    768           */
    769          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
    770          {
    771            uint8 rferrm = RFERRM;
    772          
    773            if ((RFERRF & RFERR_RXOVERF) & rferrm)
    774            {
    775              RFERRF &= ~RFERR_RXOVERF;
    776              macRxFifoOverflowIsr();
    777            }
    778          }
    779          
    780          
    781          /**************************************************************************************************
    782           * @fn          macMcuRecordMaxRssiStart
    783           *
    784           * @brief       Starts recording of the maximum received RSSI value.
    785           *
    786           * @param       none
    787           *
    788           * @return      none
    789           **************************************************************************************************
    790           */
    791          MAC_INTERNAL_API void macMcuRecordMaxRssiStart(void)
    792          {
    793            /* start maximum recorded value at the lowest possible value */
    794            maxRssi = -128;
    795          
    796            /* enable timer overflow interrupt */
    797            T2IRQM |= TIMER2_PERM;
    798          }
    799          
    800          
    801          /**************************************************************************************************
    802           * @fn          macMcuRecordMaxRssiStop
    803           *
    804           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    805           *              received since starting the recording.
    806           *
    807           * @param       none
    808           *
    809           * @return      maximum received RSSI value
    810           **************************************************************************************************
    811           */
    812          MAC_INTERNAL_API int8 macMcuRecordMaxRssiStop(void)
    813          {
    814            /* disable timer overflow interrupt */
    815            T2IRQM &= ~TIMER2_PERM;
    816          
    817            return(maxRssi);
    818          }
    819          
    820          
    821          /*=================================================================================================
    822           * @fn          macMcuRecordMaxRssiIsr
    823           *
    824           * @brief       Interrupt service routine called during recording of max RSSI value.
    825           *
    826           * @param       none
    827           *
    828           * @return      none
    829           *=================================================================================================
    830           */
    831          static void mcuRecordMaxRssiIsr(void)
    832          {
    833            int8 rssi;
    834          
    835            /* read latest RSSI value */
    836            rssi = RSSI;
    837          
    838            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    839            if (rssi > maxRssi)
    840            {
    841              maxRssi = rssi;
    842            }
    843          }
    844          
    845          
    846          /**************************************************************************************************
    847           *                                  Compile Time Integrity Checks
    848           **************************************************************************************************
    849           */
    850          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
    851          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
    852          #endif
    853          
    854          /**************************************************************************************************
    855          */

Errors: 24
Warnings: 2
