###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:01 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mt\MT_AF.c                                      #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mt\MT_AF.c -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proj #
#                          ects\zstack\Samples\mynetApp\CC2530DB\CoordinatorE #
#                          B\List\ -lA C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\Coor #
#                          dinatorEB\List\ --diag_suppress Pe001,Pa010 -o     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\MT_AF.lst                                       #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\MT_AF.r51                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\mt\MT_AF.c
      1          /**************************************************************************************************
      2            Filename:       MT_AF.c
      3            Revised:        $Date: 2010-01-08 16:52:37 -0800 (Fri, 08 Jan 2010) $
      4            Revision:       $Revision: 21471 $
      5          
      6          
      7            Description:    MonitorTest functions for the AF layer.
      8          
      9          
     10            Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          
     40          **************************************************************************************************/
     41          
     42          /***************************************************************************************************
     43           * INCLUDES
     44           ***************************************************************************************************/
     45          #include "ZComDef.h"
     46          #include "OSAL.h"
     47          #include "MT.h"
     48          #include "MT_AF.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  typedef void (*halUARTCBack_t) (uint8 port, uint8 event);
                                                          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",119  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    halUARTCBack_t      callBackFunc;
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",141  Error[Pe020]: 
          identifier "halUARTCBack_t" is undefined
     49          #include "MT_ZDO.h"
     50          #include "nwk.h"
     51          #include "OnBoard.h"
     52          #include "MT_UART.h"
     53          
     54          #if defined INTER_PAN
     55          #include "stub_aps.h"
     56          #endif
     57          
     58          /***************************************************************************************************
     59           * GLOBAL VARIABLES
     60           ***************************************************************************************************/
     61          
     62          #if defined ( MT_AF_CB_FUNC )
     63          uint16 _afCallbackSub;
     64          #endif
     65          
     66          /***************************************************************************************************
     67           * LOCAL FUNCTIONS
     68           ***************************************************************************************************/
     69          void MT_AfRegister(uint8 *pBuf);
     70          void MT_AfDataRequest(uint8 *pBuf);
     71          
     72          #if defined ( ZIGBEE_SOURCE_ROUTING )
     73          void MT_AfDataRequestSrcRtg(uint8 *pBuf);
     74          #endif
     75          
     76          #if defined INTER_PAN
     77          static void MT_AfInterPanCtl(uint8 *pBuf);
     78          #endif
     79          
     80          /***************************************************************************************************
     81           * @fn      MT_afCommandProcessing
     82           *
     83           * @brief   Process all the AF commands that are issued by test tool
     84           *
     85           * @param   pBuf - pointer to the received buffer
     86           *
     87           * @return  status
     88           ***************************************************************************************************/
     89          uint8 MT_AfCommandProcessing(uint8 *pBuf)
     90          {
     91            uint8 status = MT_RPC_SUCCESS;
     92          
     93            switch (pBuf[MT_RPC_POS_CMD1])
     94            {
     95              case MT_AF_REGISTER:
     96                MT_AfRegister(pBuf);
     97                break;
     98          
     99              case MT_AF_DATA_REQUEST:
    100              case MT_AF_DATA_REQUEST_EXT:
    101                MT_AfDataRequest(pBuf);
    102                break;
    103                
    104          #if defined ( ZIGBEE_SOURCE_ROUTING )
    105              case MT_AF_DATA_REQUEST_SRCRTG:
    106                MT_AfDataRequestSrcRtg(pBuf);
    107                break;
    108          #endif
    109                
    110          #if defined INTER_PAN
    111              case MT_AF_INTER_PAN_CTL:
    112                MT_AfInterPanCtl(pBuf);
    113                break; 
    114          #endif
    115                
    116              default:
    117                status = MT_RPC_ERR_COMMAND_ID;
    118                break;
    119            }
    120          
    121            return status;
    122          }
    123          
    124          /***************************************************************************************************
    125           * @fn      MT_AfRegister
    126           *
    127           * @brief   Process AF Register command
    128           *
    129           * @param   pBuf - pointer to the received buffer
    130           *
    131           * @return  none
    132           ***************************************************************************************************/
    133          void MT_AfRegister(uint8 *pBuf)
    134          {
    135            uint8 cmdId;
    136            uint8 retValue = ZMemError;
    137            endPointDesc_t *epDesc;
    138          
    139            /* parse header */
    140            cmdId = pBuf[MT_RPC_POS_CMD1];
    141            pBuf += MT_RPC_FRAME_HDR_SZ;
    142          
    143            epDesc = (endPointDesc_t *)osal_mem_alloc(sizeof(endPointDesc_t));
    144            if ( epDesc )
    145            {
    146              epDesc->task_id = &MT_TaskID;
    147              retValue = MT_BuildEndpointDesc( pBuf, epDesc );
    148              if ( retValue == ZSuccess )
    149              {
    150                retValue = afRegister( epDesc );
    151              }
    152          
    153              if ( retValue != ZSuccess )
    154              {
    155                osal_mem_free( epDesc );
    156              }
    157            }
    158          
    159            /* Build and send back the response */
    160            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_AF), cmdId, 1, &retValue);
    161          }
    162          
    163          /***************************************************************************************************
    164           * @fn      MT_AfDataRequest
    165           *
    166           * @brief   Process AF Register command
    167           *
    168           * @param   pBuf - pointer to the received buffer
    169           *
    170           * @return  none
    171           ***************************************************************************************************/
    172          void MT_AfDataRequest(uint8 *pBuf)
    173          {
    174            uint8 cmd0, cmd1, tempLen = 0;
    175            uint8 retValue = ZFailure;
    176            endPointDesc_t *epDesc;
    177            byte transId;
    178            afAddrType_t dstAddr;
    179            cId_t cId;
    180            byte txOpts, radius, srcEP;
    181          
    182            /* Parse header */
    183            cmd0 = pBuf[MT_RPC_POS_CMD0];
    184            cmd1 = pBuf[MT_RPC_POS_CMD1];
    185            pBuf += MT_RPC_FRAME_HDR_SZ;
    186          
    187            if (cmd1 == MT_AF_DATA_REQUEST_EXT)
    188            {
    189              dstAddr.addrMode = (afAddrMode_t)*pBuf++;
    190          
    191              if (dstAddr.addrMode == afAddr64Bit)
    192              {
    193                (void)osal_memcpy(dstAddr.addr.extAddr, pBuf, Z_EXTADDR_LEN);
    194              }
    195              else
    196              {
    197                dstAddr.addr.shortAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
    198              }
    199              pBuf += Z_EXTADDR_LEN;
    200          
    201              dstAddr.endPoint = *pBuf++;
    202              dstAddr.panId = BUILD_UINT16(pBuf[0], pBuf[1]);
    203              pBuf += 2;
    204            }
    205            else
    206            {
    207              /* Destination address */
    208              dstAddr.addrMode = afAddr16Bit;
    209              dstAddr.addr.shortAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
    210              pBuf += 2;
    211          
    212              /* Destination endpoint */
    213              dstAddr.endPoint = *pBuf++;
    214              dstAddr.panId = 0;
    215            }
    216          
    217            /* Source endpoint */
    218            srcEP = *pBuf++;
    219            epDesc = afFindEndPointDesc( srcEP );
    220          
    221            /* ClusterId */
    222            cId = BUILD_UINT16(pBuf[0], pBuf[1]);
    223            pBuf +=2;
    224          
    225            /* TransId */
    226            transId = *pBuf++;
    227          
    228            /* TxOption */
    229            txOpts = *pBuf++;
    230          
    231            /* Radius */
    232            radius = *pBuf++;
    233          
    234            /* Length */
    235            tempLen = *pBuf++;
    236          
    237            if ( epDesc == NULL )
    238            {
    239              retValue = afStatus_INVALID_PARAMETER;
    240            }
    241            else
    242            {
    243              retValue = AF_DataRequest( &dstAddr, epDesc, cId, tempLen, pBuf, &transId, txOpts, radius );
    244            }
    245          
    246            if (MT_RPC_CMD_SREQ == (cmd0 & MT_RPC_CMD_TYPE_MASK))
    247            {
    248              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_AF), cmd1, 1, &retValue);
    249            }
    250          }
    251          
    252          
    253          #if defined ( ZIGBEE_SOURCE_ROUTING )
    254          
    255          /***************************************************************************************************
    256           * @fn      MT_AfDataRequestSrcRtg
    257           *
    258           * @brief   Process AF Register command
    259           *
    260           * @param   pBuf - pointer to the received buffer
    261           *
    262           * @return  none
    263           ***************************************************************************************************/
    264          void MT_AfDataRequestSrcRtg(uint8 *pBuf)
    265          {
    266            uint8 cmdId, dataLen = 0;
    267            uint8 retValue = ZFailure;
    268            endPointDesc_t *epDesc;
    269            byte transId;
    270            afAddrType_t dstAddr;
    271            cId_t cId;
    272            byte txOpts, radius, srcEP, relayCnt;
    273            uint16 *pRelayList;
    274            uint8 i;
    275          
    276            /* parse header */
    277            cmdId = pBuf[MT_RPC_POS_CMD1];
    278            pBuf += MT_RPC_FRAME_HDR_SZ;
    279          
    280            /* Destination address */
    281            /* Initialize the panID field to zero to avoid inter-pan */
    282            osal_memset( &dstAddr, 0, sizeof(afAddrType_t) ); 
    283            dstAddr.addrMode = afAddr16Bit;
    284            dstAddr.addr.shortAddr = BUILD_UINT16(pBuf[0], pBuf[1]);
    285            pBuf += 2;
    286          
    287            /* Destination endpoint */
    288            dstAddr.endPoint = *pBuf++;
    289          
    290            /* Source endpoint */
    291            srcEP = *pBuf++;
    292            epDesc = afFindEndPointDesc( srcEP );
    293          
    294            /* ClusterId */
    295            cId = BUILD_UINT16(pBuf[0], pBuf[1]);
    296            pBuf +=2;
    297          
    298            /* TransId */
    299            transId = *pBuf++;
    300          
    301            /* TxOption */
    302            txOpts = *pBuf++;
    303          
    304            /* Radius */
    305            radius = *pBuf++;
    306            
    307            /* Source route relay count */
    308            relayCnt = *pBuf++;
    309            
    310            /* Convert the source route relay list */
    311            if( (pRelayList = osal_mem_alloc( relayCnt * sizeof( uint16 ))) != NULL )
    312            {
    313              for( i = 0; i < relayCnt; i++ )
    314              {
    315                pRelayList[i]  = BUILD_UINT16( pBuf[0], pBuf[1] );
    316                pBuf += 2;
    317              }
    318            
    319              /* Data payload Length */
    320              dataLen = *pBuf++;
    321          
    322              if ( epDesc == NULL )
    323              {
    324                retValue = afStatus_INVALID_PARAMETER;
    325              }
    326              else
    327              {
    328                retValue = AF_DataRequestSrcRtg( &dstAddr, epDesc, cId, dataLen, pBuf, 
    329                                               &transId, txOpts, radius, relayCnt, pRelayList );
    330              }
    331              
    332              /* Free the memory allocated */
    333              osal_mem_free( pRelayList );
    334            }
    335            else
    336            {
    337              retValue = afStatus_MEM_FAIL;
    338            }
    339              
    340          
    341            /* Build and send back the response */
    342            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_AF), cmdId, 1, &retValue);
    343          }
    344          #endif
    345          
    346          #if defined INTER_PAN
    347          /***************************************************************************************************
    348           * @fn      MT_AfInterPanCtl
    349           *
    350           * @brief   Process the AF Inter Pan control command.
    351           *
    352           * @param   pBuf - pointer to the received buffer
    353           *
    354           * @return  none
    355           ***************************************************************************************************/
    356          static void MT_AfInterPanCtl(uint8 *pBuf)
    357          {
    358            uint8 cmd, rtrn;
    359            uint16 panId;
    360            endPointDesc_t *pEP;
    361            
    362            cmd = pBuf[MT_RPC_POS_CMD1];
    363            pBuf += MT_RPC_FRAME_HDR_SZ;
    364          
    365            switch (*pBuf++)  // Inter-pan request parameter.
    366            {
    367            case InterPanClr:
    368              rtrn = StubAPS_SetIntraPanChannel();           // Switch channel back to the NIB channel.
    369              break;
    370          
    371            case InterPanSet:
    372              rtrn = StubAPS_SetInterPanChannel(*pBuf);      // Set channel for inter-pan communication.
    373              break;
    374          
    375            case InterPanReg:
    376              if ((pEP = afFindEndPointDesc(*pBuf)))
    377              {
    378                StubAPS_RegisterApp(pEP);
    379                rtrn = SUCCESS;
    380              }
    381              else
    382              {
    383                rtrn = FAILURE;
    384              }
    385              break;
    386          
    387            case InterPanChk:
    388              panId = BUILD_UINT16(pBuf[0], pBuf[1]);
    389              rtrn = (StubAPS_InterPan(panId, pBuf[2])) ? ZSuccess : ZFailure;
    390              break;
    391          
    392            default:
    393              rtrn = afStatus_INVALID_PARAMETER;
    394              break;
    395            }
    396          
    397            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_AF), cmd, 1, &rtrn);
    398          }
    399          #endif
    400          
    401          /***************************************************************************************************
    402           * @fn      MT_AfDataConfirm
    403           *
    404           * @brief   Process
    405           *
    406           * @param   pBuf - pointer to the received buffer
    407           *
    408           * @return  none
    409           ***************************************************************************************************/
    410          void MT_AfDataConfirm(afDataConfirm_t *pMsg)
    411          {
    412            uint8 retArray[3];
    413          
    414            retArray[0] = pMsg->hdr.status;
    415            retArray[1] = pMsg->endpoint;
    416            retArray[2] = pMsg->transID;
    417          
    418            /* Build and send back the response */
    419            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_AF), MT_AF_DATA_CONFIRM, 3, retArray);
    420          }
    421          
    422          /***************************************************************************************************
    423           * @fn          MT_AfIncomingMsg
    424           *
    425           * @brief       Process the callback subscription for AF Incoming data.
    426           *
    427           * @param       pkt - Incoming AF data.
    428           *
    429           * @return      none
    430           ***************************************************************************************************/
    431          void MT_AfIncomingMsg(afIncomingMSGPacket_t *pMsg)
    432          {
    433            uint8 dataLen = pMsg->cmd.DataLength;  /* Length of the data section in the response packet */
    434            uint8 respLen = 17 + dataLen;          /* Length of the whole response packet */
    435            uint8 cmd = MT_AF_INCOMING_MSG;
    436            uint8 *pRsp, *tempPtr;
    437          
    438          #if defined INTER_PAN
    439            if (StubAPS_InterPan(pMsg->srcAddr.panId, pMsg->srcAddr.endPoint))
    440            {
    441              cmd = MT_AF_INCOMING_MSG_EXT;
    442            }
    443            else
    444          #endif
    445            if (pMsg->srcAddr.addrMode == afAddr64Bit)
    446            {
    447              cmd = MT_AF_INCOMING_MSG_EXT;
    448            }
    449          
    450            if (cmd == MT_AF_INCOMING_MSG_EXT)
    451            {
    452              respLen += 9;
    453            }
    454          
    455            // Attempt to allocate memory for the response packet.
    456            if ((pRsp = osal_mem_alloc(respLen)) == NULL)
    457            {
    458              return;
    459            }
    460            tempPtr = pRsp;
    461          
    462            /* Fill in the data */
    463          
    464            /* Group ID */
    465            *tempPtr++ = LO_UINT16(pMsg->groupId);
    466            *tempPtr++ = HI_UINT16(pMsg->groupId);
    467          
    468            /* Cluster ID */
    469            *tempPtr++ = LO_UINT16(pMsg->clusterId);
    470            *tempPtr++ = HI_UINT16(pMsg->clusterId);
    471          
    472            if (cmd == MT_AF_INCOMING_MSG_EXT)
    473            {
    474              *tempPtr++ = pMsg->srcAddr.addrMode;
    475          
    476              if (pMsg->srcAddr.addrMode == afAddr64Bit)
    477              {
    478                (void)osal_memcpy(tempPtr, pMsg->srcAddr.addr.extAddr, Z_EXTADDR_LEN);
    479              }
    480              else
    481              {
    482                tempPtr[0] = LO_UINT16(pMsg->srcAddr.addr.shortAddr);
    483                tempPtr[1] = HI_UINT16(pMsg->srcAddr.addr.shortAddr);
    484              }
    485              tempPtr += Z_EXTADDR_LEN;
    486          
    487              *tempPtr++ = pMsg->srcAddr.endPoint;
    488          #if defined INTER_PAN
    489              *tempPtr++ = LO_UINT16(pMsg->srcAddr.panId);
    490              *tempPtr++ = HI_UINT16(pMsg->srcAddr.panId);
    491          #else
    492              *tempPtr++ = 0;
    493              *tempPtr++ = 0;
    494          #endif
    495            }
    496            else
    497            {
    498              /* Source Address */
    499              *tempPtr++ = LO_UINT16(pMsg->srcAddr.addr.shortAddr);
    500              *tempPtr++ = HI_UINT16(pMsg->srcAddr.addr.shortAddr);
    501          
    502              /* Source EP */
    503              *tempPtr++ = pMsg->srcAddr.endPoint;
    504            }
    505          
    506            /* Destination EP */
    507            *tempPtr++ = pMsg->endPoint;
    508          
    509            /* WasBroadCast */
    510            *tempPtr++ = pMsg->wasBroadcast;
    511          
    512            /* LinkQuality */
    513            *tempPtr++ = pMsg->LinkQuality;
    514          
    515            /* SecurityUse */
    516            *tempPtr++ = pMsg->SecurityUse;
    517          
    518            /* Timestamp */
    519            *tempPtr++ = BREAK_UINT32(pMsg->timestamp, 0);
    520            *tempPtr++ = BREAK_UINT32(pMsg->timestamp, 1);
    521            *tempPtr++ = BREAK_UINT32(pMsg->timestamp, 2);
    522            *tempPtr++ = BREAK_UINT32(pMsg->timestamp, 3);
    523          
    524            /* Transmit Sequence Number */
    525            *tempPtr++ = pMsg->cmd.TransSeqNumber;
    526          
    527            /* Data Length */
    528            *tempPtr++ = dataLen;
    529          
    530            /* Data */
    531            if (dataLen)
    532            {
    533              osal_memcpy(tempPtr, pMsg->cmd.Data, dataLen);
    534            }
    535          
    536            /* Build and send back the response */
    537            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_AF), cmd, respLen, pRsp);
    538          
    539            /* Free memory */
    540            osal_mem_free(pRsp);
    541          }
    542          
    543          /***************************************************************************************************
    544          ***************************************************************************************************/

Errors: 25
Warnings: 2
