###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:00 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDApp.c                               #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\stack\zdo\ZDApp.c -D ZTOOL_P1 -D MT_TASK -D     #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proj #
#                          ects\zstack\Samples\mynetApp\CC2530DB\CoordinatorE #
#                          B\List\ -lA C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\Coor #
#                          dinatorEB\List\ --diag_suppress Pe001,Pa010 -o     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ZDApp.lst                                       #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ZDApp.r51                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\stack\zdo\ZDApp.c
      1          /**************************************************************************************************
      2            Filename:       ZDApp.c
      3            Revised:        $Date: 2010-01-04 12:16:55 -0800 (Mon, 04 Jan 2010) $
      4            Revision:       $Revision: 21428 $
      5          
      6            Description:    This file contains the interface to the Zigbee Device Application. This is the
      7                            Application part that the use can change. This also contains the Task functions.
      8          
      9          
     10            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com. 
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "ZMac.h"
     46          #include "OSAL.h"
     47          #include "OSAL_Tasks.h"
     48          #include "OSAL_PwrMgr.h"
     49          #include "OSAL_Nv.h"
     50          #include "AF.h"
     51          #include "APSMEDE.h"
     52          #include "NLMEDE.h"
     53          #include "AddrMgr.h"
     54          #include "ZDProfile.h"
     55          #include "ZDObject.h"
     56          #include "ZDConfig.h"
     57          #include "ZDSecMgr.h"
     58          #include "ZDApp.h"
     59          #include "DebugTrace.h"
     60          #include "nwk_util.h"
     61          #include "OnBoard.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  typedef void (*halUARTCBack_t) (uint8 port, uint8 event);
                                                          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",119  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    halUARTCBack_t      callBackFunc;
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_uart.h",141  Error[Pe020]: 
          identifier "halUARTCBack_t" is undefined
     62          #include "ZGlobals.h"
     63          #include "ZDNwkMgr.h"
     64          #include "rtg.h"
     65          
     66          #include "ssp.h"
     67          
     68          /* HAL */
     69          #include "hal_led.h"
     70          #include "hal_lcd.h"
     71          #include "hal_key.h"
     72          
     73          #if defined( MT_MAC_FUNC ) || defined( MT_MAC_CB_FUNC )
     74            #error "ERROR! MT_MAC functionalities should be disabled on ZDO devices"
     75          #endif
     76          /*********************************************************************
     77           * MACROS
     78           */
     79          
     80          /*********************************************************************
     81           * CONSTANTS
     82           */
     83          #if !defined( NWK_START_DELAY )
     84            #define NWK_START_DELAY             100   // in milliseconds
     85          #endif
     86          
     87          #if !defined( EXTENDED_JOINING_RANDOM_MASK )
     88            #define EXTENDED_JOINING_RANDOM_MASK 0x007F
     89          #endif
     90          
     91          #if !defined( BEACON_REQUEST_DELAY )
     92            #define BEACON_REQUEST_DELAY        100   // in milliseconds
     93          #endif
     94          
     95          #if !defined( BEACON_REQ_DELAY_MASK )
     96            #define BEACON_REQ_DELAY_MASK       0x007F
     97          #endif
     98          
     99          #define MAX_RESUME_RETRY            3
    100          
    101          #define MAX_DEVICE_UNAUTH_TIMEOUT   5000  // 5 seconds
    102          
    103          // Beacon Order Settings (see NLMEDE.h)
    104          #define DEFAULT_BEACON_ORDER        BEACON_ORDER_NO_BEACONS
    105          #define DEFAULT_SUPERFRAME_ORDER    DEFAULT_BEACON_ORDER
    106          
    107          #if !defined( MAX_NWK_FRAMECOUNTER_CHANGES )
    108            // The number of times the frame counter can change before
    109            // saving to NV
    110            #define MAX_NWK_FRAMECOUNTER_CHANGES    1000
    111          #endif
    112          
    113          // Leave control bits
    114          #define ZDAPP_LEAVE_CTRL_INIT 0
    115          #define ZDAPP_LEAVE_CTRL_SET  1
    116          #define ZDAPP_LEAVE_CTRL_RA   2
    117          
    118          // Standard time to update NWK NV data
    119          #define ZDAPP_UPDATE_NWK_NV_TIME 700
    120          
    121          // Address Manager Stub Implementation
    122          #define ZDApp_NwkWriteNVRequest AddrMgrWriteNVRequest
    123          
    124          // Size of the ZDO callback function table zdoCBFunc[]
    125          #define MAX_ZDO_CB_FUNC 1
    126          
    127          
    128          /*********************************************************************
    129           * GLOBAL VARIABLES
    130           */
    131          
    132          #if defined( LCD_SUPPORTED )
    133            uint8 MatchRsps = 0;
    134          #endif
    135          
    136          uint8 zdoDiscCounter = 1;
    137          
    138          zAddrType_t ZDAppNwkAddr;
    139          
    140          uint8 zdappMgmtNwkDiscRspTransSeq;
    141          uint8 zdappMgmtNwkDiscReqInProgress = FALSE;
    142          zAddrType_t zdappMgmtNwkDiscRspAddr;
    143          uint8 zdappMgmtNwkDiscStartIndex;
    144          uint8 zdappMgmtSavedNwkState;
    145          
    146          uint16 nwkFrameCounterChanges = 0;
    147          uint8 continueJoining = TRUE;
    148          
    149          uint8  _tmpRejoinState;
    150          
    151          // The extended PanID used in ZDO layer for rejoin.
    152          uint8 ZDO_UseExtendedPANID[Z_EXTADDR_LEN];
    153          
    154          pfnZdoCb zdoCBFunc[MAX_ZDO_CB_FUNC];
    155          
    156          /*********************************************************************
    157           * EXTERNAL VARIABLES
    158           */
    159          
    160          /*********************************************************************
    161           * EXTERNAL FUNCTIONS
    162           */
    163          
    164          /*********************************************************************
    165           * LOCAL FUNCTIONS
    166           */
    167          
    168          void ZDApp_NetworkStartEvt( void );
    169          void ZDApp_DeviceAuthEvt( void );
    170          void ZDApp_SaveNetworkStateEvt( void );
    171          
    172          uint8 ZDApp_ReadNetworkRestoreState( void );
    173          uint8 ZDApp_RestoreNetworkState( void );
    174          void ZDAppDetermineDeviceType( void );
    175          void ZDApp_InitUserDesc( void );
    176          void ZDAppCheckForHoldKey( void );
    177          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr );
    178          void ZDApp_ProcessNetworkJoin( void );
    179          void ZDApp_SetCoordAddress( uint8 endPoint, uint8 dstEP );
    180          void ZDApp_SaveNwkKey( void );
    181          uint8 ZDApp_RestoreNwkKey( void );
    182            
    183          void ZDApp_SecInit( uint8 state );
    184          UINT16 ZDApp_ProcessSecEvent( uint8 task_id, UINT16 events );
    185          void ZDApp_ProcessSecMsg( osal_event_hdr_t *msgPtr );
    186          
    187          void ZDApp_SendMsg( uint8 taskID, uint8 cmd, uint8 len, uint8 *buf );
    188          
    189          void ZDApp_ResetTimerStart( uint16 delay );
    190          void ZDApp_ResetTimerCancel( void );
    191          void ZDApp_LeaveCtrlInit( void );
    192          void ZDApp_LeaveCtrlSet( uint8 ra );
    193          uint8 ZDApp_LeaveCtrlBypass( void );
    194          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay );
    195          void ZDApp_LeaveReset( uint8 ra );
    196          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
    197                                  uint8 removeChildren );
    198          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm );
    199          void ZDApp_ProcessMsgCBs( zdoIncomingMsg_t *inMsg );
    200          void ZDApp_RegisterCBs( void );
    201          
    202          /*********************************************************************
    203           * LOCAL VARIABLES
    204           */
    205          
    206          uint8 ZDAppTaskID;
    207          uint8 nwkStatus;
    208          endPointDesc_t *ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)NULL;
    209          uint8 ZDApp_LeaveCtrl;
    210          
    211          #if defined( HOLD_AUTO_START )
    212            devStates_t devState = DEV_HOLD;
    213          #else
    214            devStates_t devState = DEV_INIT;
    215          #endif
    216          
    217          #if ( ZG_BUILD_RTRONLY_TYPE ) || ( ZG_BUILD_ENDDEVICE_TYPE )
    218            devStartModes_t devStartMode = MODE_JOIN;     // Assume joining
    219            //devStartModes_t devStartMode = MODE_RESUME; // if already "directly joined"
    220                                  // to parent. Set to make the device do an Orphan scan.
    221          #else
    222            // Set the default to coodinator
    223            devStartModes_t devStartMode = MODE_HARD;
    224          #endif
    225          
    226          uint8 retryCnt;
    227          
    228          endPointDesc_t ZDApp_epDesc =
    229          {
    230            ZDO_EP,
    231            &ZDAppTaskID,
    232            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for ZDO
    233            (afNetworkLatencyReq_t)0            // No Network Latency req
    234          };
    235          
    236          uint16 ZDApp_SavedPollRate = POLL_RATE;
    237          
    238          /*********************************************************************
    239           * @fn      ZDApp_Init
    240           *
    241           * @brief   ZDApp Initialization function.
    242           *
    243           * @param   task_id - ZDApp Task ID
    244           *
    245           * @return  None
    246           */
    247          void ZDApp_Init( uint8 task_id )
    248          {
    249            // Save the task ID
    250            ZDAppTaskID = task_id;
    251          
    252            // Initialize the ZDO global device short address storage
    253            ZDAppNwkAddr.addrMode = Addr16Bit;
    254            ZDAppNwkAddr.addr.shortAddr = INVALID_NODE_ADDR;
    255            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
    256          
    257            // Check for manual "Hold Auto Start"
    258            ZDAppCheckForHoldKey();
    259          
    260            // Initialize ZDO items and setup the device - type of device to create.
    261            ZDO_Init();
    262          
    263            // Register the endpoint description with the AF
    264            // This task doesn't have a Simple description, but we still need
    265            // to register the endpoint.
    266            afRegister( (endPointDesc_t *)&ZDApp_epDesc );
    267          
    268          #if defined( ZDO_USERDESC_RESPONSE )
    269            ZDApp_InitUserDesc();
    270          #endif // ZDO_USERDESC_RESPONSE
    271          
    272            // Start the device?
    273            if ( devState != DEV_HOLD )
    274            {
    275              ZDOInitDevice( 0 );
    276            }
    277            else
    278            {
    279              // Blink LED to indicate HOLD_START
    280              HalLedBlink ( HAL_LED_4, 0, 50, 500 );
    281            }
    282            
    283            ZDApp_RegisterCBs();
    284          } /* ZDApp_Init() */
    285          
    286          /*********************************************************************
    287           * @fn          ZDApp_SecInit
    288           *
    289           * @brief       ZDApp initialize security.
    290           *
    291           * @param       state - device initialization state
    292           *
    293           * @return      none
    294           */
    295          void ZDApp_SecInit( uint8 state )
    296          {  
    297            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    298            {
    299              // Set the Trust Center bit
    300              ZDO_Config_Node_Descriptor.ServerMask |= PRIM_TRUST_CENTER;
    301            }
    302          
    303            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
    304            {
    305              ZDO_Config_Node_Descriptor.CapabilityFlags |= CAPINFO_SECURITY_CAPABLE;
    306            }
    307              
    308            // Initialize ZigBee Device Security Manager
    309            ZDSecMgrInit(state);
    310          
    311            if ( ZG_SECURE_ENABLED )
    312            {
    313              if ( state != ZDO_INITDEV_RESTORED_NETWORK_STATE )
    314              {
    315                nwkFrameCounter = 0;
    316            
    317                if( _NIB.nwkKeyLoaded == FALSE )
    318                {
    319                  if ( ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE          ) ||
    320                       ( ( zgSecurityMode == ZG_SECURITY_RESIDENTIAL ) && zgPreConfigKeys )    )
    321                  {
    322                      SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0);
    323                      SSP_SwitchNwkKey( 0 );
    324                  }
    325                }
    326              }
    327            }    
    328          }
    329          
    330          /*********************************************************************
    331           * @fn      ZDApp_event_loop()
    332           *
    333           * @brief   Main event loop for Zigbee device objects task. This function
    334           *          should be called at periodic intervals.
    335           *
    336           * @param   task_id - Task ID
    337           * @param   events  - Bitmap of events
    338           *
    339           * @return  none
    340           */
    341          UINT16 ZDApp_event_loop( uint8 task_id, UINT16 events )
    342          {
    343            uint8 *msg_ptr;
    344          
    345            if ( events & SYS_EVENT_MSG )
    346            {
    347              while ( (msg_ptr = osal_msg_receive( ZDAppTaskID )) )
    348              {
    349                ZDApp_ProcessOSALMsg( (osal_event_hdr_t *)msg_ptr );
    350          
    351                // Release the memory
    352                osal_msg_deallocate( msg_ptr );
    353              }
    354          
    355              // Return unprocessed events
    356              return (events ^ SYS_EVENT_MSG);
    357            }
    358          
    359            if ( events & ZDO_NETWORK_INIT )
    360            {
    361              // Initialize apps and start the network
    362              devState = DEV_INIT;
    363              
    364              ZDO_StartDevice( (uint8)ZDO_Config_Node_Descriptor.LogicalType, devStartMode,
    365                               DEFAULT_BEACON_ORDER, DEFAULT_SUPERFRAME_ORDER );
    366          
    367              // Return unprocessed events
    368              return (events ^ ZDO_NETWORK_INIT);
    369            }
    370          
    371            if ( ZSTACK_ROUTER_BUILD )
    372            {
    373              if ( events & ZDO_NETWORK_START )
    374              {
    375                ZDApp_NetworkStartEvt();
    376            
    377                // Return unprocessed events
    378                return (events ^ ZDO_NETWORK_START);
    379              }
    380          
    381              if ( events & ZDO_ROUTER_START )
    382              {
    383                if ( nwkStatus == ZSuccess )
    384                {
    385                  if ( devState == DEV_END_DEVICE )
    386                    devState = DEV_ROUTER;
    387            
    388                  osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
    389                }
    390                else
    391                {
    392                  // remain as end device!!
    393                }
    394                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    395            
    396                // Return unprocessed events
    397                return (events ^ ZDO_ROUTER_START);
    398              }
    399            }
    400            
    401            if ( events & ZDO_STATE_CHANGE_EVT )
    402            {
    403              ZDO_UpdateNwkStatus( devState );
    404              
    405              // At start up, do one MTO route discovery if the device is a concentrator
    406              if ( zgConcentratorEnable == TRUE ) 
    407              {
    408                // Start next event
    409                osal_start_timerEx( NWK_TaskID, NWK_MTO_RTG_REQ_EVT, 100 );
    410              }
    411              
    412              // Return unprocessed events
    413              return (events ^ ZDO_STATE_CHANGE_EVT);
    414            }
    415          
    416            if ( events & ZDO_COMMAND_CNF )
    417            {
    418              // User defined logic
    419          
    420              // Return unprocessed events
    421              return (events ^ ZDO_COMMAND_CNF);
    422            }
    423            
    424            if ( events & ZDO_NWK_UPDATE_NV )
    425            {
    426              ZDApp_SaveNetworkStateEvt();
    427          
    428              // Return unprocessed events
    429              return (events ^ ZDO_NWK_UPDATE_NV);
    430            }
    431          
    432            if ( events & ZDO_DEVICE_RESET )
    433            {
    434              // The device has been in the UNAUTH state, so reset
    435              // Note: there will be no return from this call
    436              SystemReset();
    437            }
    438          
    439            if ( ZG_SECURE_ENABLED )
    440            {
    441              return ( ZDApp_ProcessSecEvent( task_id, events ) );
    442            }
    443            else
    444            {
    445              // Discard or make more handlers
    446              return 0;
    447            }
    448          }
    449          
    450          /*********************************************************************
    451           * @fn      ZDApp_ProcessSecEvent()
    452           *
    453           * @brief   Process incoming security events.
    454           *
    455           * @param   task_id - Task ID
    456           * @param   events  - Bitmap of events
    457           *
    458           * @return  none
    459           */
    460          UINT16 ZDApp_ProcessSecEvent( uint8 task_id, UINT16 events )
    461          {
    462            (void)task_id;  // Intentionally unreferenced parameter
    463            
    464            if ( ZSTACK_ROUTER_BUILD )
    465            {
    466              if ( events & ZDO_NEW_DEVICE )
    467              {
    468                // process the new device event
    469                if ( ZDSecMgrNewDeviceEvent() == TRUE )
    470                {
    471                  osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 1000 );
    472                }
    473          
    474                // Return unprocessed events
    475                return (events ^ ZDO_NEW_DEVICE);
    476              }
    477            }
    478          
    479            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH) 
    480                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
    481            {
    482              if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    483              { 
    484                if ( events & ZDO_SECMGR_EVENT )
    485                {
    486                  ZDSecMgrEvent();
    487          
    488                  // Return unprocessed events
    489                  return (events ^ ZDO_SECMGR_EVENT);
    490                }
    491              }
    492            }
    493            
    494            if ( events & ZDO_DEVICE_AUTH )
    495            {
    496              ZDApp_DeviceAuthEvt();
    497          
    498              // Return unprocessed events
    499              return (events ^ ZDO_DEVICE_AUTH);
    500            }
    501          
    502            if ( events & ZDO_FRAMECOUNTER_CHANGE )
    503            {
    504              if ( nwkFrameCounterChanges++ > MAX_NWK_FRAMECOUNTER_CHANGES )
    505                ZDApp_SaveNwkKey();
    506          
    507              // Return unprocessed events
    508              return (events ^ ZDO_FRAMECOUNTER_CHANGE);
    509            }
    510            
    511            // Discard or make more handlers
    512            return 0;
    513          }
    514          
    515          /*********************************************************************
    516           * Application Functions
    517           */
    518          
    519          /*********************************************************************
    520           * @fn      ZDOInitDevice
    521           *
    522           * @brief   Start the device in the network.  This function will read
    523           *   ZCD_NV_STARTUP_OPTION (NV item) to determine whether or not to
    524           *   restore the network state of the device.
    525           *
    526           * @param   startDelay - timeDelay to start device (in milliseconds).
    527           *      There is a jitter added to this delay:
    528           *              ((NWK_START_DELAY + startDelay)
    529           *              + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK))
    530           *
    531           * NOTE:    If the application would like to force a "new" join, the
    532           *          application should set the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    533           *          bit in the ZCD_NV_STARTUP_OPTION NV item before calling
    534           *          this function. "new" join means to not restore the network
    535           *          state of the device. Use zgWriteStartupOptions() to set these
    536           *          options.
    537           *
    538           * @return
    539           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    540           *          restored.
    541           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was initialized.
    542           *          This could mean that ZCD_NV_STARTUP_OPTION said to not restore, or
    543           *          it could mean that there was no network state to restore.
    544           *    ZDO_INITDEV_LEAVE_NOT_STARTED - Before the reset, a network leave was issued
    545           *          with the rejoin option set to TRUE.  So, the device was not
    546           *          started in the network (one time only).  The next time this
    547           *          function is called it will start.
    548           */
    549          uint8 ZDOInitDevice( uint16 startDelay )
    550          {
    551            uint8 networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    552            uint16 extendedDelay = 0;
    553          
    554            if ( devState == DEV_HOLD )
    555            {    
    556              // Initialize the RAM items table, in case an NV item has been updated.
    557              zgInitItems( FALSE );
    558            }
    559          
    560            ZDConfig_InitDescriptors();
    561            //devtag.071807.todo - fix this temporary solution
    562            _NIB.CapabilityInfo = ZDO_Config_Node_Descriptor.CapabilityFlags;
    563            
    564            devState = DEV_INIT;    // Remove the Hold state
    565          
    566            // Initialize leave control logic
    567            ZDApp_LeaveCtrlInit();
    568          
    569            // Check leave control reset settings
    570            ZDApp_LeaveCtrlStartup( &devState, &startDelay );
    571          
    572            // Leave may make the hold state come back
    573            if ( devState == DEV_HOLD )
    574            {
    575              // Set the NV startup option to force a "new" join.
    576              zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
    577          
    578              // Notify the applications 
    579              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    580              
    581              return ( ZDO_INITDEV_LEAVE_NOT_STARTED );   // Don't join - (one time).
    582            }
    583          
    584          #if defined ( NV_RESTORE )
    585            // Get Keypad directly to see if a reset nv is needed.
    586            // Hold down the SW_BYPASS_NV key (defined in OnBoard.h)
    587            // while booting to skip past NV Restore.
    588            if ( HalKeyRead() == SW_BYPASS_NV )
    589              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    590            else
    591            {
    592              // Determine if NV should be restored
    593              networkStateNV = ZDApp_ReadNetworkRestoreState();
    594            }
    595          
    596            if ( networkStateNV == ZDO_INITDEV_RESTORED_NETWORK_STATE )
    597            {
    598              networkStateNV = ZDApp_RestoreNetworkState();
    599            }
    600            else
    601            {
    602              // Wipe out the network state in NV
    603              NLME_InitNV();
    604              NLME_SetDefaultNV();
    605            }
    606          #endif
    607          
    608            if ( networkStateNV == ZDO_INITDEV_NEW_NETWORK_STATE )
    609            {
    610              ZDAppDetermineDeviceType();
    611          
    612              // Only delay if joining network - not restoring network state
    613              extendedDelay = (uint16)((NWK_START_DELAY + startDelay)
    614                        + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK));
    615            }
    616          
    617            // Initialize the security for type of device
    618            ZDApp_SecInit( networkStateNV );
    619            
    620            // Trigger the network start
    621            ZDApp_NetworkInit( extendedDelay );
    622          
    623            // set broadcast address mask to support broadcast filtering
    624            NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
    625            
    626            return ( networkStateNV );
    627          }
    628          
    629          /*********************************************************************
    630           * @fn      ZDApp_ReadNetworkRestoreState
    631           *
    632           * @brief   Read the ZCD_NV_STARTUP_OPTION NV Item to state whether
    633           *          or not to restore the network state.
    634           *          If the read value has the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    635           *          bit set return the ZDO_INITDEV_NEW_NETWORK_STATE.
    636           *
    637           * @param   none
    638           *
    639           * @return  ZDO_INITDEV_NEW_NETWORK_STATE
    640           *          or ZDO_INITDEV_RESTORED_NETWORK_STATE based on whether or
    641           *          not ZCD_STARTOPT_DEFAULT_NETWORK_STATE bit is set in
    642           *          ZCD_NV_STARTUP_OPTION
    643           */
    644          uint8 ZDApp_ReadNetworkRestoreState( void )
    645          {
    646            uint8 networkStateNV = ZDO_INITDEV_RESTORED_NETWORK_STATE;
    647          
    648            // Look for the New Network State option.
    649            if ( zgReadStartupOptions() & ZCD_STARTOPT_DEFAULT_NETWORK_STATE )
    650            {
    651              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    652            }
    653          
    654            return ( networkStateNV );
    655          }
    656          
    657          /*********************************************************************
    658           * @fn      ZDAppDetermineDeviceType()
    659           *
    660           * @brief   Determines the type of device to start. 
    661           *
    662           *          Looks at zgDeviceLogicalType and determines what type of
    663           *          device to start.  The types are:
    664           *            ZG_DEVICETYPE_COORDINATOR
    665           *            ZG_DEVICETYPE_ROUTER
    666           *            ZG_DEVICETYPE_ENDDEVICE
    667           *
    668           * @param   none
    669           *
    670           * @return  none
    671           */
    672          void ZDAppDetermineDeviceType( void )
    673          {
    674            if ( zgDeviceLogicalType == ZG_DEVICETYPE_COORDINATOR )
    675            {
    676              devStartMode = MODE_HARD;     // Start as a coordinator
    677              ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
    678            }
    679            else
    680            {
    681              if ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER  )
    682                ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_ROUTER;
    683              else if ( zgDeviceLogicalType == ZG_DEVICETYPE_ENDDEVICE )
    684                ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
    685              
    686              // If AIB_apsUseExtendedPANID is set to a non-zero value by commissioning
    687              // The device shall do rejoin the network. Otherwise, do normal join
    688              if ( nwk_ExtPANIDValid( AIB_apsUseExtendedPANID ) == false )
    689              {
    690                devStartMode = MODE_JOIN;     // Assume joining
    691              }
    692              else
    693              {
    694                devStartMode = MODE_REJOIN;  
    695              }
    696            }
    697          }
    698          
    699          /*********************************************************************
    700           * @fn      ZDApp_NetworkStartEvt()
    701           *
    702           * @brief   Process the Network Start Event
    703           *
    704           * @param   none
    705           *
    706           * @return  none
    707           */
    708          void ZDApp_NetworkStartEvt( void )
    709          {
    710            if ( nwkStatus == ZSuccess )
    711            {
    712              // Successfully started a ZigBee network
    713              if ( devState == DEV_COORD_STARTING )
    714              {
    715                devState = DEV_ZB_COORD;
    716              }
    717          
    718              osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
    719              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    720            }
    721            else
    722            {
    723              // Try again with a higher energy threshold !!
    724              if ( ( NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT ) < 0xff )
    725              {
    726                NLME_SetEnergyThreshold( (uint8)(NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT) );
    727                osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
    728              }
    729              else
    730              {
    731                // Failed to start network. Enter a dormant state (until user intervenes)
    732                devState = DEV_INIT;
    733                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    734              }
    735            }
    736          }
    737          
    738          /*********************************************************************
    739           * @fn      ZDApp_DeviceAuthEvt()
    740           *
    741           * @brief   Process the Device Authentic Event
    742           *
    743           * @param   none
    744           *
    745           * @return  none
    746           */
    747          void ZDApp_DeviceAuthEvt( void )
    748          {
    749            // received authentication from trust center
    750            if ( devState == DEV_END_DEVICE_UNAUTH )
    751            {
    752              // Stop the reset timer so it doesn't reset
    753              ZDApp_ResetTimerCancel();
    754          
    755              devState = DEV_END_DEVICE;
    756              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    757          
    758              // Set the Power Manager Device
    759          #if defined ( POWER_SAVING )
    760              osal_pwrmgr_device( PWRMGR_BATTERY );
    761          #endif
    762          
    763              if ( ZSTACK_ROUTER_BUILD )
    764              {
    765                if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
    766                {
    767                  // NOTE: first two parameters are not used, see NLMEDE.h for details
    768                  NLME_StartRouterRequest( 0, 0, false );
    769                }
    770              }
    771          
    772              // Notify to save info into NV
    773              ZDApp_NVUpdate();
    774          
    775              // Save off the security
    776              ZDApp_SaveNwkKey();
    777          
    778              ZDApp_AnnounceNewAddress();
    779              
    780              if ( (ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE) == 0 )
    781              {
    782                NLME_SetPollRate( ZDApp_SavedPollRate );
    783              }
    784            }
    785            else
    786            {
    787              ZDApp_NVUpdate();
    788            }
    789          }
    790          
    791          /*********************************************************************
    792           * @fn      ZDApp_SaveNetworkStateEvt()
    793           *
    794           * @brief   Process the Save the Network State Event
    795           *
    796           * @param   none
    797           *
    798           * @return  none
    799           */
    800          void ZDApp_SaveNetworkStateEvt( void )
    801          {
    802          #if defined ( NV_RESTORE )
    803           #if defined ( NV_TURN_OFF_RADIO )
    804            // Turn off the radio's receiver during an NV update
    805            uint8 RxOnIdle;
    806            uint8 x = false;
    807            ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
    808            ZMacSetReq( ZMacRxOnIdle, &x );
    809           #endif
    810          
    811            // Update the Network State in NV
    812            NLME_UpdateNV( NWK_NV_NIB_ENABLE        |
    813                           NWK_NV_DEVICELIST_ENABLE |
    814                           NWK_NV_BINDING_ENABLE    |
    815                           NWK_NV_ADDRMGR_ENABLE );
    816          
    817            // Reset the NV startup option to resume from NV by
    818            // clearing the "New" join option.
    819            zgWriteStartupOptions( FALSE, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
    820          
    821           #if defined ( NV_TURN_OFF_RADIO )
    822            ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
    823           #endif
    824          #endif  // NV_RESTORE
    825          }
    826          
    827          /*********************************************************************
    828           * @fn      ZDApp_RestoreNetworkState()
    829           *
    830           * @brief   This function will restore the network state of the
    831           *          device if the network state is stored in NV.
    832           *
    833           * @param   none
    834           *
    835           * @return
    836           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    837           *          restored.
    838           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was not used.
    839           *          This could mean that zgStartupOption said to not restore, or
    840           *          it could mean that there was no network state to restore.
    841           *
    842           */
    843          uint8 ZDApp_RestoreNetworkState( void )
    844          {
    845            uint8 nvStat;
    846            nwkActiveKeyItems keyItems;
    847          
    848            // Initialize NWK NV items
    849            nvStat = NLME_InitNV();
    850          
    851            if ( nvStat != NV_OPER_FAILED )
    852            {
    853              if ( NLME_RestoreFromNV() )
    854              {
    855                // Are we a coordinator
    856                ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
    857                if ( ZDAppNwkAddr.addr.shortAddr == 0 )
    858                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
    859                devStartMode = MODE_RESUME;
    860                osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
    861              }
    862              else
    863                nvStat = NV_ITEM_UNINIT;
    864          
    865              if ( ZG_SECURE_ENABLED )
    866              {
    867                nwkFrameCounterChanges = 0;
    868                osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
    869                osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
    870          
    871                if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    872                {
    873                  ZDApp_RestoreNwkKey();
    874                }
    875              }
    876          
    877              // The default for RxOnWhenIdle is true for Routers and false for end devices
    878              // [setup in the NLME_RestoreFromNV()].  Change it here if you want something
    879              // other than default.
    880            }
    881          
    882            if ( nvStat == ZSUCCESS )
    883              return ( ZDO_INITDEV_RESTORED_NETWORK_STATE );
    884            else
    885              return ( ZDO_INITDEV_NEW_NETWORK_STATE );
    886          }
    887          
    888          /*********************************************************************
    889           * @fn      ZDApp_InitUserDesc()
    890           *
    891           * @brief   Initialize the User Descriptor, the descriptor is read from NV
    892           *          when needed.  If you want to initialize the User descriptor to
    893           *          something other than all zero, do it here.
    894           *
    895           * @param   none
    896           *
    897           * @return  none
    898           */
    899          void ZDApp_InitUserDesc( void )
    900          {
    901            UserDescriptorFormat_t ZDO_DefaultUserDescriptor;
    902          
    903            // Initialize the User Descriptor, the descriptor is read from NV
    904            // when needed.  If you want to initialize the User descriptor to something
    905            // other than all zero, do it here.
    906            osal_memset( &ZDO_DefaultUserDescriptor, 0, sizeof( UserDescriptorFormat_t ) );
    907            if ( ZSUCCESS == osal_nv_item_init( ZCD_NV_USERDESC,
    908                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
    909            {
    910              if ( ZSUCCESS == osal_nv_read( ZCD_NV_USERDESC, 0,
    911                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
    912              {
    913                if ( ZDO_DefaultUserDescriptor.len != 0 )
    914                {
    915                  ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
    916                }
    917              }
    918            }
    919          }
    920          
    921          /*********************************************************************
    922           * @fn      ZDAppCheckForHoldKey()
    923           *
    924           * @brief   Check for key to set the device into Hold Auto Start
    925           *
    926           * @param   none
    927           *
    928           * @return  none
    929           */
    930          void ZDAppCheckForHoldKey( void )
    931          {
    932          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    933            // Get Keypad directly to see if a HOLD_START is needed.
    934            // Hold down the SW_BYPASS_START key (see OnBoard.h)
    935            // while booting to avoid starting up the device.
    936            if ( HalKeyRead () == SW_BYPASS_START)
    937            {
    938              // Change the device state to HOLD on start up
    939              devState = DEV_HOLD;
    940            }
    941          #endif // HAL_KEY
    942          }
    943          
    944          /*********************************************************************
    945           * @fn      ZDApp_ProcessOSALMsg()
    946           *
    947           * @brief   Process the incoming task message.
    948           *
    949           * @param   msgPtr - message to process
    950           *
    951           * @return  none
    952           */
    953          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr )
    954          {
    955            // Data Confirmation message fields
    956            uint8 sentEP;       // This should always be 0
    957            uint8 sentStatus;
    958            afDataConfirm_t *afDataConfirm;
    959            uint8 tmp;
    960          
    961            switch ( msgPtr->event )
    962            {
    963              // Incoming ZDO Message
    964              case AF_INCOMING_MSG_CMD:
    965                ZDP_IncomingData( (afIncomingMSGPacket_t *)msgPtr );
    966                break;
    967                
    968              case ZDO_CB_MSG:
    969                ZDApp_ProcessMsgCBs( (zdoIncomingMsg_t *)msgPtr );
    970                break;
    971          
    972              case AF_DATA_CONFIRM_CMD:
    973                // This message is received as a confirmation of a data packet sent.
    974                // The status is of ZStatus_t type [defined in NLMEDE.h]
    975                // The message fields are defined in AF.h
    976                afDataConfirm = (afDataConfirm_t *)msgPtr;
    977                sentEP = afDataConfirm->endpoint;
    978                sentStatus = afDataConfirm->hdr.status;
    979          
    980                // Action taken when confirmation is received.
    981          #if defined ( ZIGBEE_FREQ_AGILITY )
    982                if ( pZDNwkMgr_ProcessDataConfirm )
    983                  pZDNwkMgr_ProcessDataConfirm( afDataConfirm );
    984          #endif
    985                (void)sentEP;
    986                (void)sentStatus;
    987                break;
    988          
    989              case ZDO_NWK_DISC_CNF:
    990                if (devState != DEV_NWK_DISC)
    991                  break;
    992                
    993                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
    994                {
    995                  if ( (((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->hdr.status == ZDO_SUCCESS) && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
    996                  {
    997                    if ( devStartMode == MODE_JOIN )
    998                    {
    999                      devState = DEV_NWK_JOINING;
   1000            
   1001                      ZDApp_NodeProfileSync((ZDO_NetworkDiscoveryCfm_t *)msgPtr);
   1002            
   1003                      if ( NLME_JoinRequest( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->extendedPANID,
   1004                           BUILD_UINT16( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdLSB, ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdMSB ),
   1005                           ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->logicalChannel,
   1006                           ZDO_Config_Node_Descriptor.CapabilityFlags ) != ZSuccess )
   1007                      {
   1008                        ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1009                            + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1010                      }
   1011                    }
   1012                    else if ( devStartMode == MODE_REJOIN )
   1013                    {
   1014                      devState = DEV_NWK_REJOIN;
   1015          
   1016                      // Before trying to do rejoin, check if the device has a valid short address
   1017                      // If not, generate a random short address for itself
   1018                      if ( _NIB.nwkDevAddress == INVALID_NODE_ADDR )
   1019                      {
   1020                        _NIB.nwkDevAddress = osal_rand();
   1021                        ZMacSetReq( ZMacShortAddress, (byte*)&_NIB.nwkDevAddress );
   1022                      }
   1023          
   1024                      if ( ZG_SECURE_ENABLED )
   1025                      {
   1026                        ZDApp_RestoreNwkKey();
   1027                      }
   1028                      
   1029                      // Check if the device has a valid PanID, if not, set it to the discovered Pan
   1030                      if ( _NIB.nwkPanId == INVALID_PAN_ID )
   1031                      {
   1032                        _NIB.nwkPanId = BUILD_UINT16( ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdLSB, ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->panIdMSB );
   1033                        ZMacSetReq( ZMacPanId, (byte*)&(_NIB.nwkPanId) );
   1034                      }
   1035          
   1036                      tmp = true;
   1037                      ZMacSetReq( ZMacRxOnIdle, &tmp ); // Set receiver always on during rejoin 
   1038                      if ( NLME_ReJoinRequest( ZDO_UseExtendedPANID, ((ZDO_NetworkDiscoveryCfm_t *)msgPtr)->logicalChannel) != ZSuccess )
   1039                      {
   1040                        ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1041                            + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1042                      }
   1043                    }
   1044            
   1045                    if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   1046                    {
   1047                      // The receiver is on, turn network layer polling off.
   1048                      NLME_SetPollRate( 0 );
   1049                      NLME_SetQueuedPollRate( 0 );
   1050                      NLME_SetResponseRate( 0 );
   1051                    }
   1052                    else
   1053                    {
   1054                      if ( (ZG_SECURE_ENABLED) && (devStartMode == MODE_JOIN) )
   1055                      {
   1056                        ZDApp_SavedPollRate = zgPollRate;
   1057                        NLME_SetPollRate( zgRejoinPollRate );
   1058                      }
   1059                    }
   1060                  }
   1061                  else
   1062                  {
   1063                    if ( continueJoining )
   1064                    {
   1065              #if defined ( MANAGED_SCAN )
   1066                      ZDApp_NetworkInit( MANAGEDSCAN_DELAY_BETWEEN_SCANS );
   1067              #else
   1068                      zdoDiscCounter++;
   1069                      ZDApp_NetworkInit( (uint16)(BEACON_REQUEST_DELAY
   1070                            + ((uint16)(osal_rand()& BEACON_REQ_DELAY_MASK))) );
   1071              #endif
   1072                    }
   1073                  }
   1074                }
   1075                break;
   1076          
   1077              case ZDO_NWK_JOIN_IND:
   1078                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1079                {
   1080                  ZDApp_ProcessNetworkJoin();
   1081                }
   1082                break;
   1083          
   1084              case ZDO_NWK_JOIN_REQ:
   1085                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1086                {
   1087                  retryCnt = 0;
   1088                  devStartMode = MODE_RESUME;
   1089                  _tmpRejoinState = true;
   1090                  osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
   1091                  zgDefaultStartingScanDuration = BEACON_ORDER_60_MSEC;
   1092                  ZDApp_NetworkInit( 0 );
   1093                }
   1094                break;
   1095          
   1096              default:
   1097                if ( ZG_SECURE_ENABLED )
   1098                  ZDApp_ProcessSecMsg( msgPtr );
   1099                break;
   1100            }
   1101          
   1102          }
   1103          
   1104          /*********************************************************************
   1105           * @fn      ZDApp_ProcessMsgCBs()
   1106           *
   1107           * @brief   Process response messages
   1108           *
   1109           * @param   none
   1110           *
   1111           * @return  none
   1112           */
   1113          void ZDApp_ProcessMsgCBs( zdoIncomingMsg_t *inMsg )
   1114          {
   1115            switch ( inMsg->clusterID )
   1116            {
   1117          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1118              case NWK_addr_rsp:
   1119              case IEEE_addr_rsp:
   1120                {
   1121                  ZDO_NwkIEEEAddrResp_t *pAddrRsp;
   1122                  pAddrRsp = ZDO_ParseAddrRsp( inMsg );
   1123                  if ( pAddrRsp )
   1124                  {
   1125                    if ( pAddrRsp->status == ZSuccess )
   1126                    {
   1127                      ZDO_UpdateAddrManager( pAddrRsp->nwkAddr, pAddrRsp->extAddr );
   1128                    }
   1129                    osal_mem_free( pAddrRsp );
   1130                  }
   1131                }
   1132                break;
   1133          #endif
   1134                
   1135          #if defined ( REFLECTOR )
   1136              case Bind_req:
   1137              case Unbind_req:
   1138                {
   1139                  ZDO_BindUnbindReq_t bindReq;
   1140                  ZDO_ParseBindUnbindReq( inMsg, &bindReq );
   1141                  ZDO_ProcessBindUnbindReq( inMsg, &bindReq );
   1142                }
   1143                break;
   1144          #endif      
   1145          
   1146          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1147              case Bind_rsp:
   1148              case Unbind_rsp:
   1149                if (ZG_DEVICE_COORDINATOR_TYPE && matchED)
   1150                {
   1151                  ZDMatchSendState(
   1152                       (uint8)((inMsg->clusterID == Bind_rsp) ? ZDMATCH_REASON_BIND_RSP : ZDMATCH_REASON_UNBIND_RSP),
   1153                       ZDO_ParseBindRsp(inMsg), inMsg->TransSeq );
   1154                }
   1155                break;
   1156                
   1157              case End_Device_Bind_req:
   1158                if (ZG_DEVICE_COORDINATOR_TYPE)
   1159                {
   1160                  ZDEndDeviceBind_t bindReq;
   1161                  ZDO_ParseEndDeviceBindReq( inMsg, &bindReq );
   1162                  ZDO_MatchEndDeviceBind( &bindReq );
   1163                  
   1164                  // Freeing the cluster lists - if allocated.
   1165                  if ( bindReq.numInClusters )
   1166                    osal_mem_free( bindReq.inClusters );
   1167                  if ( bindReq.numOutClusters )
   1168                    osal_mem_free( bindReq.outClusters );
   1169                }
   1170                break;
   1171          #endif
   1172            }
   1173          }
   1174          
   1175          /*********************************************************************
   1176           * @fn      ZDApp_RegisterCBs()
   1177           *
   1178           * @brief   Process response messages
   1179           *
   1180           * @param   none
   1181           *
   1182           * @return  none
   1183           */
   1184          void ZDApp_RegisterCBs( void )
   1185          {
   1186          #if defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1187            ZDO_RegisterForZDOMsg( ZDAppTaskID, IEEE_addr_rsp );
   1188          #endif
   1189          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( REFLECTOR )
   1190            ZDO_RegisterForZDOMsg( ZDAppTaskID, NWK_addr_rsp );
   1191          #endif  
   1192          #if ZG_BUILD_COORDINATOR_TYPE
   1193            ZDO_RegisterForZDOMsg( ZDAppTaskID, Bind_rsp );
   1194            ZDO_RegisterForZDOMsg( ZDAppTaskID, Unbind_rsp );
   1195            ZDO_RegisterForZDOMsg( ZDAppTaskID, End_Device_Bind_req );
   1196          #endif
   1197          #if defined ( REFLECTOR )
   1198            ZDO_RegisterForZDOMsg( ZDAppTaskID, Bind_req );
   1199            ZDO_RegisterForZDOMsg( ZDAppTaskID, Unbind_req );
   1200          #endif  
   1201          }
   1202          
   1203          /*********************************************************************
   1204           * @fn      ZDApp_ProcessSecMsg()
   1205           *
   1206           * @brief   Process the incoming security message.
   1207           *
   1208           * @param   msgPtr - message to process
   1209           *
   1210           * @return  none
   1211           */
   1212          void ZDApp_ProcessSecMsg( osal_event_hdr_t *msgPtr )
   1213          {
   1214            switch ( msgPtr->event )
   1215            {
   1216              case ZDO_ESTABLISH_KEY_CFM:
   1217                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1218                {
   1219                  ZDSecMgrEstablishKeyCfm( (ZDO_EstablishKeyCfm_t*)msgPtr );
   1220                }
   1221                break;
   1222          
   1223              case ZDO_ESTABLISH_KEY_IND:
   1224                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1225                {
   1226                  if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1227                  {
   1228                    ZDSecMgrEstablishKeyInd( (ZDO_EstablishKeyInd_t*)msgPtr );
   1229                  }
   1230                }
   1231                break;
   1232          
   1233              case ZDO_TRANSPORT_KEY_IND:
   1234                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1235                {
   1236                  ZDSecMgrTransportKeyInd( (ZDO_TransportKeyInd_t*)msgPtr );
   1237                }
   1238                break;
   1239          
   1240              case ZDO_UPDATE_DEVICE_IND:
   1241                if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1242                {
   1243                  ZDSecMgrUpdateDeviceInd( (ZDO_UpdateDeviceInd_t*)msgPtr );
   1244                }
   1245                break;
   1246          
   1247              case ZDO_REMOVE_DEVICE_IND:
   1248                if ( ZG_BUILD_RTRONLY_TYPE && ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER ) )
   1249                {
   1250                  ZDSecMgrRemoveDeviceInd( (ZDO_RemoveDeviceInd_t*)msgPtr );
   1251                }
   1252                break;
   1253          
   1254              case ZDO_REQUEST_KEY_IND:
   1255                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1256                {
   1257                  if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1258                  {
   1259                    ZDSecMgrRequestKeyInd( (ZDO_RequestKeyInd_t*)msgPtr );
   1260                  }
   1261                }
   1262                break;
   1263          
   1264              case ZDO_SWITCH_KEY_IND:
   1265                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1266                {
   1267                  ZDSecMgrSwitchKeyInd( (ZDO_SwitchKeyInd_t*)msgPtr );
   1268                }
   1269                break;
   1270              
   1271              case ZDO_AUTHENTICATE_IND:
   1272                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1273                {
   1274                  ZDSecMgrAuthenticateInd( (ZDO_AuthenticateInd_t*)msgPtr );
   1275                }
   1276                break;
   1277          
   1278              case ZDO_AUTHENTICATE_CFM:
   1279                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1280                {
   1281                  ZDSecMgrAuthenticateCfm( (ZDO_AuthenticateCfm_t*)msgPtr );
   1282                }
   1283                break;
   1284          
   1285              default:
   1286                // Unsupported messages
   1287                break;
   1288            }
   1289          }
   1290          
   1291          /*********************************************************************
   1292           * @fn      ZDApp_ProcessNetworkJoin()
   1293           *
   1294           * @brief
   1295           *
   1296           *   Save off the Network key information.
   1297           *
   1298           * @param   none
   1299           *
   1300           * @return  none
   1301           */
   1302          void ZDApp_ProcessNetworkJoin( void )
   1303          {
   1304            if ( (devState == DEV_NWK_JOINING) ||
   1305                ((devState == DEV_NWK_ORPHAN)  &&
   1306                 (ZDO_Config_Node_Descriptor.LogicalType == NODETYPE_ROUTER)) )
   1307            {
   1308              // Result of a Join attempt by this device.
   1309              if ( nwkStatus == ZSuccess )
   1310              {
   1311                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   1312          
   1313          #if defined ( POWER_SAVING )
   1314                osal_pwrmgr_device( PWRMGR_BATTERY );
   1315          #endif
   1316          
   1317                if ( ZG_SECURE_ENABLED && ( ZDApp_RestoreNwkKey() == false ) )
   1318                {
   1319                  // wait for auth from trust center!!
   1320                  devState = DEV_END_DEVICE_UNAUTH;
   1321          
   1322                  // Start the reset timer for MAX UNAUTH time
   1323                  ZDApp_ResetTimerStart( 10000 );//MAX_DEVICE_UNAUTH_TIMEOUT );
   1324                }
   1325                else
   1326                {
   1327                  if ( ZSTACK_ROUTER_BUILD )
   1328                  {
   1329                    if ( devState == DEV_NWK_ORPHAN 
   1330                      && ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1331                    {
   1332                      // Change NIB state to router for restore
   1333                      _NIB.nwkState = NWK_ROUTER;
   1334                    }
   1335                  }
   1336                          
   1337                  if ( devState == DEV_NWK_JOINING )
   1338                  {
   1339                    ZDApp_AnnounceNewAddress();
   1340                  }
   1341                  
   1342                  devState = DEV_END_DEVICE;
   1343                  if ( ZSTACK_ROUTER_BUILD )
   1344                  {
   1345                    // NOTE: first two parameters are not used, see NLMEDE.h for details
   1346                    if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1347                    {
   1348                      NLME_StartRouterRequest( 0, 0, false );
   1349                    }
   1350                  }
   1351                }
   1352              }
   1353              else
   1354              {
   1355                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   1356                {
   1357                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   1358                    devStartMode = MODE_JOIN;
   1359                  else
   1360                  {
   1361                    devStartMode = MODE_REJOIN;
   1362                    _tmpRejoinState = true;
   1363                  }
   1364                }
   1365          
   1366                if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   1367                     (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   1368                {
   1369                  uint16 addr = INVALID_NODE_ADDR;
   1370                  // Invalidate nwk addr so end device does not use in its data reqs.
   1371                  _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   1372                  ZMacSetReq( ZMacShortAddress, (uint8 *)&addr );
   1373                }
   1374          
   1375                // Clear the neighbor Table and network discovery tables.
   1376                nwkNeighborInitTable();
   1377                NLME_NwkDiscTerm();
   1378          
   1379                zdoDiscCounter = 1;
   1380          
   1381          //      ZDApp_NetworkInit( (uint16)
   1382          //                         ((NWK_START_DELAY * (osal_rand() & 0x0F)) +
   1383          //                          (NWK_START_DELAY * 5)) );
   1384                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1385                     + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1386              }
   1387            }
   1388            else if ( devState == DEV_NWK_ORPHAN || devState == DEV_NWK_REJOIN )
   1389            {
   1390              // results of an orphaning attempt by this device
   1391              if (nwkStatus == ZSuccess)
   1392              {
   1393                if ( ZG_SECURE_ENABLED )
   1394                {
   1395                  ZDApp_RestoreNwkKey();
   1396                }
   1397                
   1398                devState = DEV_END_DEVICE;
   1399                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   1400                // setup Power Manager Device
   1401          #if defined ( POWER_SAVING )
   1402                osal_pwrmgr_device( PWRMGR_BATTERY );
   1403          #endif
   1404          
   1405                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   1406                {
   1407                  // The receiver is on, turn network layer polling off.
   1408                  NLME_SetPollRate( 0 );
   1409                  NLME_SetQueuedPollRate( 0 );
   1410                  NLME_SetResponseRate( 0 );
   1411                }
   1412          
   1413                if ( ZSTACK_ROUTER_BUILD )
   1414                {
   1415                  // NOTE: first two parameters are not used, see NLMEDE.h for details
   1416                  if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1417                  {
   1418                    NLME_StartRouterRequest( 0, 0, false );
   1419                  }
   1420                }
   1421                
   1422                ZDApp_AnnounceNewAddress();
   1423              }
   1424              else
   1425              {
   1426                if ( devStartMode == MODE_RESUME )
   1427                {
   1428                  if ( ++retryCnt <= MAX_RESUME_RETRY )
   1429                  {
   1430                    if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   1431                      devStartMode = MODE_JOIN;
   1432                    else
   1433                    {
   1434                      devStartMode = MODE_REJOIN;
   1435                      _tmpRejoinState = true;
   1436                    }
   1437                  }
   1438                  // Do a normal join to the network after certain times of rejoin retries
   1439                  else if( AIB_apsUseInsecureJoin == true )
   1440                  {
   1441                    devStartMode = MODE_JOIN;
   1442                  }
   1443                }
   1444          
   1445                // Clear the neighbor Table and network discovery tables.
   1446                nwkNeighborInitTable();
   1447                NLME_NwkDiscTerm();
   1448          
   1449                // setup a retry for later...
   1450                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1451                     + (osal_rand()& EXTENDED_JOINING_RANDOM_MASK)) );
   1452              }
   1453            }
   1454          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1455            else
   1456            {
   1457              // Assume from address conflict
   1458              if ( _NIB.nwkAddrAlloc == NWK_ADDRESSING_STOCHASTIC )
   1459              {
   1460                // Notify the network
   1461                ZDApp_AnnounceNewAddress();
   1462                
   1463                // Notify apps
   1464                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   1465              }
   1466            }
   1467          #endif
   1468          }
   1469          
   1470          /*********************************************************************
   1471           * @fn      ZDApp_SaveNwkKey()
   1472           *
   1473           * @brief   Save off the Network key information.
   1474           *
   1475           * @param   none
   1476           *
   1477           * @return  none
   1478           */
   1479          void ZDApp_SaveNwkKey( void )
   1480          {
   1481            nwkActiveKeyItems keyItems;
   1482          
   1483            SSP_ReadNwkActiveKey( &keyItems );
   1484            keyItems.frameCounter++;
   1485          
   1486            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1487                          (void *)&keyItems );
   1488          
   1489            nwkFrameCounterChanges = 0;
   1490          }
   1491          
   1492          /*********************************************************************
   1493           * @fn      ZDApp_ResetNwkKey()
   1494           *
   1495           * @brief   Reset the Network key information in NV.
   1496           *
   1497           * @param   none
   1498           *
   1499           * @return  none
   1500           */
   1501          void ZDApp_ResetNwkKey( void )
   1502          {
   1503            nwkActiveKeyItems keyItems;
   1504          
   1505            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   1506            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1507                          (void *)&keyItems );
   1508          }
   1509          
   1510          /*********************************************************************
   1511           * @fn      ZDApp_RestoreNwkKey()
   1512           *
   1513           * @brief
   1514           *
   1515           *   Save off the Network key information.
   1516           *
   1517           * @param   none
   1518           *
   1519           * @return  true if restored from NV, false if not
   1520           */
   1521          uint8 ZDApp_RestoreNwkKey( void )
   1522          {
   1523            nwkActiveKeyItems keyItems;
   1524            uint8 ret = false;
   1525          
   1526            if ( osal_nv_read( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), (void*)&keyItems )
   1527                == ZSUCCESS )
   1528            {
   1529              if ( keyItems.frameCounter > 0 )
   1530              {
   1531                // Restore the key information
   1532                keyItems.frameCounter += MAX_NWK_FRAMECOUNTER_CHANGES;
   1533                nwkFrameCounter = keyItems.frameCounter;
   1534                ret = true;
   1535              }
   1536          
   1537              // Force a save for the first frame counter increment
   1538              nwkFrameCounterChanges = MAX_NWK_FRAMECOUNTER_CHANGES + 1;
   1539            }
   1540            return ( ret );
   1541          }
   1542          
   1543          /*********************************************************************
   1544           * @fn      ZDApp_ResetTimerStart
   1545           *
   1546           * @brief   Start the reset timer.
   1547           *
   1548           * @param   delay - delay time(ms) before reset
   1549           *
   1550           * @return  none
   1551           */
   1552          void ZDApp_ResetTimerStart( uint16 delay )
   1553          {
   1554            // Start the rest timer
   1555            osal_start_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET, delay );
   1556          }
   1557          
   1558          /*********************************************************************
   1559           * @fn      ZDApp_ResetTimerCancel
   1560           *
   1561           * @brief   Cancel the reset timer.
   1562           *
   1563           * @param   none
   1564           *
   1565           * @return  none
   1566           */
   1567          void ZDApp_ResetTimerCancel( void )
   1568          {
   1569            // Cancel the reset timer
   1570            osal_stop_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET );
   1571          }
   1572          
   1573          /*********************************************************************
   1574           * @fn      ZDApp_LeaveCtrlInit
   1575           *
   1576           * @brief   Initialize the leave control logic.
   1577           *
   1578           * @param   none
   1579           *
   1580           * @return  none
   1581           */
   1582          void ZDApp_LeaveCtrlInit( void )
   1583          {
   1584            uint8 status;
   1585          
   1586          
   1587            // Initialize control state
   1588            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   1589          
   1590            status = osal_nv_item_init( ZCD_NV_LEAVE_CTRL,
   1591                                        sizeof(ZDApp_LeaveCtrl),
   1592                                        &ZDApp_LeaveCtrl );
   1593          
   1594            if ( status == ZSUCCESS )
   1595            {
   1596              // Read saved control
   1597              osal_nv_read( ZCD_NV_LEAVE_CTRL,
   1598                            0,
   1599                            sizeof( uint8 ),
   1600                            &ZDApp_LeaveCtrl);
   1601            }
   1602          }
   1603          
   1604          /*********************************************************************
   1605           * @fn      ZDApp_LeaveCtrlSet
   1606           *
   1607           * @brief   Set the leave control logic.
   1608           *
   1609           * @param   ra - reassociate flag
   1610           *
   1611           * @return  none
   1612           */
   1613          void ZDApp_LeaveCtrlSet( uint8 ra )
   1614          {
   1615            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_SET;
   1616          
   1617            if ( ra == TRUE )
   1618            {
   1619              ZDApp_LeaveCtrl |= ZDAPP_LEAVE_CTRL_RA;
   1620            }
   1621          
   1622            // Write the leave control
   1623            osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1624                           0,
   1625                           sizeof( uint8 ),
   1626                           &ZDApp_LeaveCtrl);
   1627          }
   1628          
   1629          /*********************************************************************
   1630           * @fn      ZDApp_LeaveCtrlBypass
   1631           *
   1632           * @brief   Check if NV restore should be skipped during a leave reset.
   1633           *
   1634           * @param   none
   1635           *
   1636           * @return  uint8 - (TRUE bypass:FALSE do not bypass)
   1637           */
   1638          uint8 ZDApp_LeaveCtrlBypass( void )
   1639          {
   1640            uint8 bypass;
   1641          
   1642            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   1643            {
   1644              bypass = TRUE;
   1645            }
   1646            else
   1647            {
   1648              bypass = FALSE;
   1649            }
   1650          
   1651            return bypass;
   1652          }
   1653          
   1654          /*********************************************************************
   1655           * @fn      ZDApp_LeaveCtrlStartup
   1656           *
   1657           * @brief   Check for startup conditions during a leave reset.
   1658           *
   1659           * @param   state      - devState_t determined by leave control logic
   1660           * @param   startDelay - startup delay
   1661           *
   1662           * @return  none
   1663           */
   1664          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay )
   1665          {
   1666            *startDelay = 0;
   1667          
   1668            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   1669            {
   1670              if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_RA )
   1671              {
   1672                *startDelay = 5000;
   1673              }
   1674              else
   1675              {
   1676                *state = DEV_HOLD;
   1677              }
   1678          
   1679              // Set leave control to initialized state
   1680              ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   1681          
   1682              // Write initialized control
   1683              osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1684                            0,
   1685                            sizeof( uint8 ),
   1686                            &ZDApp_LeaveCtrl);
   1687            }
   1688          }
   1689          
   1690          /*********************************************************************
   1691           * @fn      ZDApp_LeaveReset
   1692           *
   1693           * @brief   Setup a device reset due to a leave indication/confirm.
   1694           *
   1695           * @param   ra - reassociate flag
   1696           *
   1697           * @return  none
   1698           */
   1699          void ZDApp_LeaveReset( uint8 ra )
   1700          {
   1701            ZDApp_LeaveCtrlSet( ra );
   1702          
   1703            ZDApp_ResetTimerStart( 5000 );
   1704          }
   1705          
   1706          /*********************************************************************
   1707           * @fn      ZDApp_LeaveUpdate
   1708           *
   1709           * @brief   Update local device data related to leaving device.
   1710           *
   1711           * @param   nwkAddr        - NWK address of leaving device
   1712           * @param   extAddr        - EXT address of leaving device
   1713           * @param   removeChildren - remove children of leaving device
   1714           *
   1715           * @return  none
   1716           */
   1717          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
   1718                                  uint8 removeChildren )
   1719          {
   1720            /*
   1721            AddrMgrEntry_t entry;
   1722            */
   1723            (void)nwkAddr;  // Intentionally unreferenced parameter
   1724          
   1725            // Remove if child
   1726            if ( ZSTACK_ROUTER_BUILD )
   1727            {
   1728              NLME_RemoveChild( extAddr, removeChildren );
   1729            }
   1730          
   1731            /*
   1732            // Set NWK address to invalid
   1733            entry.user    = ADDRMGR_USER_DEFAULT;
   1734            entry.nwkAddr = INVALID_NODE_ADDR;
   1735            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   1736            AddrMgrEntryUpdate( &entry );
   1737          
   1738            // Check
   1739            if ( removeChildren == TRUE )
   1740            {
   1741              // Set index to INVALID_NODE_ADDR to start search
   1742              entry.index = INVALID_NODE_ADDR;
   1743          
   1744              // Get first entry
   1745              AddrMgrEntryGetNext( &entry );
   1746          
   1747              // Remove all descendents
   1748              while ( entry.index != INVALID_NODE_ADDR )
   1749              {
   1750                // Check NWK address allocation algorithm
   1751                if ( RTG_ANCESTOR( entry.nwkAddr, thisAddr ) != 0 )
   1752                {
   1753                  // Set NWK address to invalid
   1754                  entry.nwkAddr = INVALID_NODE_ADDR;
   1755                  AddrMgrEntryUpdate( &entry );
   1756                }
   1757          
   1758                // Get next entry
   1759                AddrMgrEntryGetNext( &entry );
   1760              }
   1761            }
   1762            */
   1763          }
   1764          
   1765          /*********************************************************************
   1766           * CALLBACK FUNCTIONS
   1767           */
   1768          
   1769          
   1770          /*********************************************************************
   1771           * @fn      ZDApp_SendEventMsg()
   1772           *
   1773           * @brief
   1774           *
   1775           *   Sends a Network Join message
   1776           *
   1777           * @param  cmd - command ID
   1778           * @param  len - length (in bytes) of the buf field
   1779           * @param  buf - buffer for the rest of the message.
   1780           *
   1781           * @return  none
   1782           */
   1783          void ZDApp_SendEventMsg( uint8 cmd, uint8 len, uint8 *buf )
   1784          {
   1785            ZDApp_SendMsg( ZDAppTaskID, cmd, len, buf );
   1786          }
   1787          
   1788          /*********************************************************************
   1789           * @fn      ZDApp_SendMsg()
   1790           *
   1791           * @brief   Sends a OSAL message
   1792           *
   1793           * @param  taskID - Where to send the message
   1794           * @param  cmd - command ID
   1795           * @param  len - length (in bytes) of the buf field
   1796           * @param  buf - buffer for the rest of the message.
   1797           *
   1798           * @return  none
   1799           */
   1800          void ZDApp_SendMsg( uint8 taskID, uint8 cmd, uint8 len, uint8 *buf )
   1801          {
   1802            osal_event_hdr_t *msgPtr;
   1803          
   1804            // Send the address to the task
   1805            msgPtr = (osal_event_hdr_t *)osal_msg_allocate( len );
   1806            if ( msgPtr )
   1807            {
   1808              if ( (len > 0) && (buf != NULL) )
   1809                osal_memcpy( msgPtr, buf, len );
   1810          
   1811              msgPtr->event = cmd;
   1812              osal_msg_send( taskID, (uint8 *)msgPtr );
   1813            }
   1814          }
   1815          
   1816          /*********************************************************************
   1817           * Call Back Functions from NWK  - API
   1818           */
   1819          
   1820          /*********************************************************************
   1821           * @fn          ZDO_NetworkDiscoveryConfirmCB
   1822           *
   1823           * @brief       This function returns a choice of PAN to join.
   1824           *
   1825           * @param       ResultCount - Number of routers discovered
   1826           * @param               NetworkList - Pointer to list of network descriptors
   1827           *
   1828           * @return      ZStatus_t
   1829           */
   1830          #define STACK_PROFILE_MAX 2
   1831          ZStatus_t ZDO_NetworkDiscoveryConfirmCB( uint8 ResultCount,
   1832                                                   networkDesc_t *NetworkList )
   1833          {
   1834            networkDesc_t *pNwkDesc = NetworkList;
   1835            ZDO_NetworkDiscoveryCfm_t msg;
   1836            uint8 i = ResultCount;
   1837            uint8 stackProfile;
   1838            uint8 stackProfilePro;
   1839            uint8 selected;
   1840          
   1841          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1842            if ( zdappMgmtNwkDiscReqInProgress )
   1843            {
   1844              zdappMgmtNwkDiscReqInProgress = false;
   1845              ZDO_FinishProcessingMgmtNwkDiscReq( ResultCount, NetworkList );
   1846              return ( ZSuccess );
   1847            }
   1848          #endif
   1849          
   1850            // process discovery results
   1851            stackProfilePro = FALSE;
   1852            selected = FALSE;
   1853          
   1854            for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   1855            {
   1856              pNwkDesc = NetworkList;
   1857              for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   1858              {
   1859                if ( zgConfigPANID != 0xFFFF )
   1860                {
   1861                  // PAN Id is preconfigured. check if it matches
   1862                  if ( pNwkDesc->panId != zgConfigPANID )
   1863                    continue;
   1864                }
   1865                
   1866          
   1867                if ( nwk_ExtPANIDValid( ZDO_UseExtendedPANID) == true ) 
   1868                {
   1869                  // If the extended Pan ID is commissioned to a non zero value
   1870                  // Only join the Pan that has match EPID
   1871                  if ( osal_ExtAddrEqual( ZDO_UseExtendedPANID, pNwkDesc->extendedPANID) == false )
   1872                    continue;
   1873                  
   1874                }
   1875          
   1876          
   1877                  // check that network is allowing joining
   1878                  if ( ZSTACK_ROUTER_BUILD )
   1879                  {
   1880                    if ( stackProfilePro == FALSE )
   1881                    {
   1882                      if ( !pNwkDesc->routerCapacity )
   1883                      {
   1884                        continue;
   1885                      }
   1886                    }
   1887                    else
   1888                    {
   1889                      if ( !pNwkDesc->deviceCapacity )
   1890                      {
   1891                        continue;
   1892                      }
   1893                    }
   1894                  }
   1895                  else if ( ZSTACK_END_DEVICE_BUILD )
   1896                  {
   1897                    if ( !pNwkDesc->deviceCapacity )
   1898                    {
   1899                      continue;
   1900                    }
   1901                  }
   1902          
   1903                  // check version of zigbee protocol
   1904                  if ( pNwkDesc->version != _NIB.nwkProtocolVersion )
   1905                    continue;
   1906          
   1907                  // check version of stack profile
   1908                  if ( pNwkDesc->stackProfile != zgStackProfile  )
   1909                  {
   1910                    if ( ((zgStackProfile == HOME_CONTROLS) && (pNwkDesc->stackProfile == ZIGBEEPRO_PROFILE)) 
   1911                        || ((zgStackProfile == ZIGBEEPRO_PROFILE) && (pNwkDesc->stackProfile == HOME_CONTROLS))  )
   1912                      stackProfilePro = TRUE;
   1913                    
   1914                    if ( stackProfile == 0 )
   1915                    {
   1916                      continue;
   1917                    }
   1918                  }
   1919          
   1920                // check if beacon order is the right value..
   1921                //  if ( pNwkDesc->beaconOrder < ZDO_CONFIG_MAX_BO )
   1922                //    continue;
   1923          
   1924                // choose this pan for joining
   1925                break;
   1926              } 
   1927              if (i < ResultCount)
   1928              {
   1929               selected = TRUE;
   1930                break;
   1931              }
   1932             
   1933              // break if selected or stack profile pro wasn't found
   1934              if ( (selected == TRUE) || (stackProfilePro == FALSE) )
   1935              {
   1936                break;
   1937              }
   1938            }
   1939          
   1940            if ( i == ResultCount )
   1941            {
   1942              msg.hdr.status = ZDO_FAIL;   // couldn't find appropriate PAN to join !
   1943            }
   1944            else
   1945            {
   1946              msg.hdr.status = ZDO_SUCCESS;
   1947              msg.panIdLSB = LO_UINT16( pNwkDesc->panId );
   1948              msg.panIdMSB = HI_UINT16( pNwkDesc->panId );
   1949              msg.logicalChannel = pNwkDesc->logicalChannel;
   1950              msg.version = pNwkDesc->version;
   1951              osal_cpyExtAddr( msg.extendedPANID, pNwkDesc->extendedPANID );
   1952            }
   1953          
   1954            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_DISC_CNF, sizeof(ZDO_NetworkDiscoveryCfm_t), (uint8 *)&msg );
   1955          
   1956            return (ZSuccess);
   1957          }  // ZDO_NetworkDiscoveryConfirmCB
   1958          
   1959          /*********************************************************************
   1960           * @fn          ZDO_NetworkFormationConfirmCB
   1961           *
   1962           * @brief       This function reports the results of the request to
   1963           *              initialize a coordinator in a network.
   1964           *
   1965           * @param       Status - Result of NLME_NetworkFormationRequest()
   1966           *
   1967           * @return      none
   1968           */
   1969          void ZDO_NetworkFormationConfirmCB( ZStatus_t Status )
   1970          {
   1971            nwkStatus = (byte)Status;
   1972          
   1973            if ( Status == ZSUCCESS )
   1974            {
   1975              // LED on shows Coordinator started
   1976              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   1977          
   1978              // LED off forgets HOLD_AUTO_START
   1979              HalLedSet (HAL_LED_4, HAL_LED_MODE_OFF);
   1980          
   1981          #if defined ( ZBIT )
   1982              SIM_SetColor(0xd0ffd0);
   1983          #endif
   1984          
   1985              if ( devState == DEV_HOLD )
   1986              {
   1987                // Began with HOLD_AUTO_START
   1988                devState = DEV_COORD_STARTING;
   1989              }
   1990            }
   1991          #if defined(BLINK_LEDS)
   1992            else
   1993              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   1994          #endif
   1995          
   1996            osal_set_event( ZDAppTaskID, ZDO_NETWORK_START );
   1997          }
   1998          
   1999          /*********************************************************************
   2000           * @fn          ZDO_StartRouterConfirmCB
   2001           *
   2002           * @brief       This function reports the results of the request to
   2003           *              start functioning as a router in a network.
   2004           *
   2005           * @param       Status - Result of NLME_StartRouterRequest()
   2006           *
   2007           * @return      none
   2008           */
   2009          void ZDO_StartRouterConfirmCB( ZStatus_t Status )
   2010          {
   2011            nwkStatus = (byte)Status;
   2012          
   2013            if ( Status == ZSUCCESS )
   2014            {
   2015              // LED on shows Router started
   2016              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   2017              // LED off forgets HOLD_AUTO_START
   2018              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   2019              if ( devState == DEV_HOLD )
   2020              {
   2021                // Began with HOLD_AUTO_START
   2022                devState = DEV_END_DEVICE;
   2023              }
   2024            }
   2025          #if defined(BLINK_LEDS)
   2026            else
   2027              HalLedSet( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   2028          #endif
   2029          
   2030            osal_set_event( ZDAppTaskID, ZDO_ROUTER_START );
   2031          }
   2032          
   2033          /*********************************************************************
   2034           * @fn          ZDO_JoinConfirmCB
   2035           *
   2036           * @brief       This function allows the next hight layer to be notified
   2037           *              of the results of its request to join itself or another
   2038           *              device to a network.
   2039           *
   2040           * @param       Status - Result of NLME_JoinRequest()
   2041           *
   2042           * @return      none
   2043           */
   2044          void ZDO_JoinConfirmCB( uint16 PanId, ZStatus_t Status )
   2045          {
   2046            (void)PanId;  // remove if this parameter is used.
   2047            
   2048            nwkStatus = (byte)Status;
   2049          
   2050            if ( Status == ZSUCCESS )
   2051            {
   2052              // LED on shows device joined
   2053              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   2054              // LED off forgets HOLD_AUTO_START
   2055              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   2056              if ( (devState == DEV_HOLD) )
   2057              {
   2058                // Began with HOLD_AUTO_START
   2059                devState = DEV_NWK_JOINING;
   2060              }
   2061          
   2062              if ( !ZG_SECURE_ENABLED )
   2063              {
   2064                // Notify to save info into NV
   2065                ZDApp_NVUpdate();
   2066              }
   2067            }
   2068            else
   2069            {
   2070          #if defined(BLINK_LEDS)
   2071              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   2072          #endif
   2073            }
   2074          
   2075            // Notify ZDApp
   2076            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_IND, sizeof(osal_event_hdr_t), (byte*)NULL );
   2077          }
   2078          
   2079          /*********************************************************************
   2080           * @fn          ZDO_AddrChangeIndicationCB
   2081           *
   2082           * @brief       This function notifies the application that this
   2083           *              device's address has changed.  Could happen in 
   2084           *              a network with stochastic addressing (PRO).
   2085           *
   2086           * @param       newAddr - the new address
   2087           *
   2088           * @return      none
   2089           */
   2090          void ZDO_AddrChangeIndicationCB( uint16 newAddr )
   2091          {
   2092            (void)newAddr;  // remove if this parameter is used
   2093            
   2094            // Notify to save info into NV
   2095            ZDApp_NVUpdate();
   2096          
   2097            // Notify the applications   
   2098            osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   2099          
   2100            // Send out a device announce
   2101            ZDApp_AnnounceNewAddress();
   2102          }
   2103          
   2104          /*********************************************************************
   2105           * @fn          ZDO_JoinIndicationCB
   2106           *
   2107           * @brief       This function allows the next higher layer of a
   2108           *              coordinator to be notified of a remote join request.
   2109           *
   2110           * @param       ShortAddress - 16-bit address
   2111           * @param       ExtendedAddress - IEEE (64-bit) address
   2112           * @param       CapabilityInformation - Association Capability Information
   2113           * @param       type - of joining - 
   2114           *                          NWK_ASSOC_JOIN
   2115           *                          NWK_ASSOC_REJOIN_UNSECURE
   2116           *                          NWK_ASSOC_REJOIN_SECURE
   2117           *
   2118           * @return      ZStatus_t
   2119           */
   2120          ZStatus_t ZDO_JoinIndicationCB( uint16 ShortAddress, uint8 *ExtendedAddress,
   2121                                          uint8 CapabilityInformation, uint8 type )
   2122          {
   2123            (void)ShortAddress;
   2124            (void)ExtendedAddress;
   2125            (void)CapabilityInformation;
   2126            
   2127              // Notify to save info into NV
   2128              ZDApp_NVUpdate();
   2129            
   2130              // send notification to TC of new device..
   2131              if ( ZG_SECURE_ENABLED )
   2132              {
   2133                if ( type == NWK_ASSOC_JOIN || type == NWK_ASSOC_REJOIN_UNSECURE )
   2134                {
   2135                  osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 600 );
   2136                }
   2137              }
   2138            
   2139              return ( ZSuccess );
   2140          }
   2141          
   2142          /*********************************************************************
   2143           * @fn          ZDO_ConcentratorIndicationCB
   2144           *
   2145           * @brief       This function allows the next higher layer of a
   2146           *              device to be notified of existence of the concentrator.
   2147           *
   2148           * @param       nwkAddr - 16-bit NWK address of the concentrator
   2149           *
   2150           * @return      void 
   2151           */
   2152          void ZDO_ConcentratorIndicationCB( uint16 nwkAddr )
   2153          {
   2154            // Write your code here to do something with the concentrator's
   2155            // address.
   2156            (void)nwkAddr;
   2157          }
   2158          
   2159          /*********************************************************************
   2160           * @fn          ZDO_LeaveCnf
   2161           *
   2162           * @brief       This function allows the next higher layer to be
   2163           *              notified of the results of its request for this or
   2164           *              a child device to leave the network.
   2165           *
   2166           * @param       cnf - NLME_LeaveCnf_t
   2167           *
   2168           * @return      none
   2169           */
   2170          void ZDO_LeaveCnf( NLME_LeaveCnf_t* cnf )
   2171          {
   2172            // Check for this device
   2173            if ( osal_ExtAddrEqual( cnf->extAddr,
   2174                                    NLME_GetExtAddr() ) == TRUE )
   2175            {
   2176              // Prepare to leave with reset
   2177              ZDApp_LeaveReset( cnf->rejoin );
   2178            }
   2179            else if ( ZSTACK_ROUTER_BUILD )
   2180            {
   2181              // Remove device address(optionally descendents) from data
   2182              ZDApp_LeaveUpdate( cnf->dstAddr,
   2183                                 cnf->extAddr,
   2184                                 cnf->removeChildren );
   2185            }
   2186          }
   2187          
   2188          /*********************************************************************
   2189           * @fn          ZDO_LeaveInd
   2190           *
   2191           * @brief       This function allows the next higher layer of a
   2192           *              device to be notified of a remote leave request or
   2193           *              indication.
   2194           *
   2195           * @param       ind - NLME_LeaveInd_t
   2196           *
   2197           * @return      none
   2198           */
   2199          void ZDO_LeaveInd( NLME_LeaveInd_t* ind )
   2200          {
   2201            uint8 leave;
   2202          
   2203          
   2204            // Parent is requesting the leave - NWK layer filters out illegal
   2205            // requests
   2206            if ( ind->request == TRUE )
   2207            {
   2208              // Notify network of leave
   2209              if ( ZSTACK_ROUTER_BUILD )
   2210              {
   2211                NLME_LeaveRsp_t rsp;
   2212                rsp.rejoin         = ind->rejoin;
   2213                rsp.removeChildren = ind->removeChildren;
   2214                NLME_LeaveRsp( &rsp );
   2215              }
   2216          
   2217              // Prepare to leave with reset
   2218              ZDApp_LeaveReset( ind->rejoin );
   2219            }
   2220            else
   2221            {
   2222              leave = FALSE;
   2223          
   2224              // Check if this device needs to leave as a child or descendent
   2225              if ( ind->srcAddr == NLME_GetCoordShortAddr() )
   2226              {
   2227                if ( ( ind->removeChildren == TRUE               ) ||
   2228                     ( ZDO_Config_Node_Descriptor.LogicalType ==
   2229                       NODETYPE_DEVICE                           )    )
   2230                {
   2231                  leave = TRUE;
   2232                }
   2233              }
   2234              else if ( ind->removeChildren == TRUE )
   2235              {
   2236                // Check NWK address allocation algorithm
   2237                //leave = RTG_ANCESTOR(nwkAddr,thisAddr);
   2238              }
   2239          
   2240              if ( leave == TRUE )
   2241              {
   2242                // Prepare to leave with reset
   2243                ZDApp_LeaveReset( ind->rejoin );
   2244              }
   2245              else
   2246              {
   2247                // Remove device address(optionally descendents) from data
   2248                ZDApp_LeaveUpdate( ind->srcAddr,
   2249                                   ind->extAddr,
   2250                                   ind->removeChildren );
   2251              }
   2252            }
   2253          }
   2254          
   2255          /*********************************************************************
   2256           * @fn          ZDO_SyncIndicationCB
   2257           *
   2258           * @brief       This function allows the next higher layer of a
   2259           *              coordinator to be notified of a loss of synchronization
   2260           *                          with the parent/child device.
   2261           *
   2262           * @param       type: 0 - child; 1 - parent
   2263           *
   2264           *
   2265           * @return      none
   2266           */
   2267          void ZDO_SyncIndicationCB( uint8 type, uint16 shortAddr )
   2268          {
   2269            (void)shortAddr;  // Remove this line if this parameter is used.
   2270            
   2271            if ( ZSTACK_END_DEVICE_BUILD
   2272              || (ZSTACK_ROUTER_BUILD && ((_NIB.CapabilityInfo & ZMAC_ASSOC_CAPINFO_FFD_TYPE) == 0)))
   2273            {
   2274              if ( type == 1 )
   2275              {
   2276                // We lost contact with our parent.  Clear the neighbor Table.
   2277                nwkNeighborInitTable();
   2278                
   2279                // Start the rejoin process.
   2280                ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   2281              }
   2282            }
   2283          }
   2284          
   2285          /*********************************************************************
   2286           * @fn          ZDO_ManytoOneFailureIndicationCB
   2287           *
   2288           * @brief       This function allows the next higher layer of a
   2289           *              concentrator to be notified of a many-to-one route 
   2290           *              failure. 
   2291           *
   2292           * @param       none
   2293           *
   2294           *
   2295           * @return      none
   2296           */
   2297          void ZDO_ManytoOneFailureIndicationCB()
   2298          {
   2299            // By default, the concentrator automatically redo many-to-one route 
   2300            // discovery to update all many-to-one routes in the network
   2301            // If you want anything processing other than the default,
   2302            // please replace the following code.
   2303            
   2304            RTG_MTORouteReq();
   2305          }
   2306          
   2307          
   2308          /*********************************************************************
   2309           * @fn          ZDO_PollConfirmCB
   2310           *
   2311           * @brief       This function allows the next higher layer to be
   2312           *              notified of a Poll Confirm.
   2313           *
   2314           * @param       none
   2315           *
   2316           * @return      none
   2317           */
   2318          void ZDO_PollConfirmCB( uint8 status )
   2319          {
   2320            (void)status;  // Remove this line if this parameter is used.
   2321            return;
   2322          }
   2323          
   2324          /******************************************************************************
   2325           * @fn          ZDApp_NwkWriteNVRequest (stubs AddrMgrWriteNVRequest)
   2326           *
   2327           * @brief       Stub routine implemented by NHLE. NHLE should call
   2328           *              <AddrMgrWriteNV> when appropriate.
   2329           *
   2330           * @param       none
   2331           *
   2332           * @return      none
   2333           */
   2334          void ZDApp_NwkWriteNVRequest( void )
   2335          {
   2336          #if defined ( NV_RESTORE )  
   2337            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   2338            {
   2339              // Trigger to save info into NV
   2340              ZDApp_NVUpdate();
   2341            }
   2342          #endif
   2343          }
   2344          
   2345          /*********************************************************************
   2346           * Call Back Functions from Security  - API
   2347           */
   2348          
   2349           /*********************************************************************
   2350           * @fn          ZDO_UpdateDeviceIndication
   2351           *
   2352           * @brief       This function notifies the "Trust Center" of a
   2353           *              network when a device joins or leaves the network.
   2354           *
   2355           * @param       extAddr - pointer to 64 bit address of new device
   2356           * @param       status  - 0 if a new device joined securely
   2357           *                      - 1 if a new device joined un-securely
   2358           *                      - 2 if a device left the network
   2359           *
   2360           * @return      true if newly joined device should be allowed to
   2361           *                                              remain on network
   2362           */
   2363          ZStatus_t ZDO_UpdateDeviceIndication( uint8 *extAddr, uint8 status )
   2364          {
   2365            // can implement a network access policy based on the
   2366            // IEEE address of newly joining devices...
   2367            (void)extAddr;
   2368            (void)status;
   2369            
   2370            return ZSuccess;
   2371          }
   2372          
   2373          /*********************************************************************
   2374           * @fn          ZDApp_InMsgCB
   2375           *
   2376           * @brief       This function is called to pass up any message that is
   2377           *              not yet supported.  This allows for the developer to
   2378           *              support features themselves..
   2379           *
   2380           * @return      none
   2381           */
   2382          void ZDApp_InMsgCB( zdoIncomingMsg_t *inMsg )
   2383          {
   2384            if ( inMsg->clusterID & ZDO_RESPONSE_BIT )
   2385            {
   2386              // Handle the response message
   2387            }
   2388            else
   2389            {
   2390              // Handle the request message by sending a generic "not supported".
   2391              // Device Announce doesn't have a response.
   2392              if ( !(inMsg->wasBroadcast) && inMsg->clusterID != Device_annce )
   2393              {
   2394                ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_NOT_SUPPORTED, 0,
   2395                                (uint16)(inMsg->clusterID | ZDO_RESPONSE_BIT), inMsg->SecurityUse );
   2396              }
   2397            }
   2398          }
   2399          
   2400          
   2401          /*********************************************************************
   2402           * @fn      ZDApp_ChangeMatchDescRespPermission()
   2403           *
   2404           * @brief   Changes the Match Descriptor Response permission.
   2405           *
   2406           * @param   endpoint - endpoint to allow responses
   2407           * @param   action - true to allow responses, false to not
   2408           *
   2409           * @return  none
   2410           */
   2411          void ZDApp_ChangeMatchDescRespPermission( uint8 endpoint, uint8 action )
   2412          {
   2413            // Store the action
   2414            afSetMatch( endpoint, action );
   2415          }
   2416          
   2417          /*********************************************************************
   2418           * @fn      ZDApp_NetworkInit()
   2419           *
   2420           * @brief   Used to start the network joining process
   2421           *
   2422           * @param   delay - mSec delay to wait before starting
   2423           *
   2424           * @return  none
   2425           */
   2426          void ZDApp_NetworkInit( uint16 delay )
   2427          {
   2428            if ( delay )
   2429            {
   2430              // Wait awhile before starting the device
   2431              osal_start_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT, delay );
   2432            }
   2433            else
   2434            {
   2435              osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   2436            }
   2437          }
   2438          
   2439          /*********************************************************************
   2440           * @fn      ZDApp_NwkStateUpdateCB()
   2441           *
   2442           * @brief   This function notifies that this device's network 
   2443           *          state info has been changed.
   2444           *
   2445           * @param   none
   2446           *
   2447           * @return  none
   2448           */
   2449          void ZDApp_NwkStateUpdateCB( void )
   2450          {
   2451            // Notify to save info into NV
   2452            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   2453            {
   2454              // Trigger to save info into NV
   2455              ZDApp_NVUpdate();
   2456            }
   2457          }
   2458          
   2459          /*********************************************************************
   2460           * @fn      ZDApp_NodeProfileSync()
   2461           *
   2462           * @brief   Sync node with stack profile.
   2463           *
   2464           * @param   cfm - ZDO_NetworkDiscoveryCfm_t
   2465           *
   2466           * @return  none
   2467           */
   2468          void ZDApp_NodeProfileSync( ZDO_NetworkDiscoveryCfm_t* cfm )
   2469          {
   2470            networkDesc_t* desc;
   2471            uint16         panID;
   2472          
   2473            if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_DEVICETYPE_FFD  )
   2474            {
   2475              panID = BUILD_UINT16( cfm->panIdLSB, cfm->panIdMSB );
   2476          
   2477              desc = nwk_getNetworkDesc( cfm->extendedPANID, panID, cfm->logicalChannel );
   2478          
   2479              if (desc != NULL)
   2480              {
   2481                if ( desc->stackProfile != zgStackProfile )
   2482                {
   2483                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
   2484                  ZDO_Config_Node_Descriptor.CapabilityFlags = CAPINFO_DEVICETYPE_RFD | CAPINFO_POWER_AC | CAPINFO_RCVR_ON_IDLE;
   2485                  NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
   2486                }
   2487              }
   2488            }
   2489          }
   2490          
   2491          /*********************************************************************
   2492           * @fn      ZDApp_StartJoiningCycle()
   2493           *
   2494           * @brief   Starts the joining cycle of a device.  This will only 
   2495           *          continue an already started (or stopped) joining cycle.
   2496           *
   2497           * @param   none
   2498           *
   2499           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   2500           */
   2501          uint8 ZDApp_StartJoiningCycle( void )
   2502          {
   2503            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   2504            {
   2505              continueJoining = TRUE;
   2506              ZDApp_NetworkInit( 0 );
   2507          
   2508              return ( TRUE );
   2509            }
   2510            else
   2511              return ( FALSE );
   2512          }
   2513          
   2514          /*********************************************************************
   2515           * @fn      ZDApp_StopJoiningCycle()
   2516           *
   2517           * @brief   Stops the joining or rejoining process of a device.
   2518           *
   2519           * @param   none
   2520           *
   2521           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   2522           */
   2523          uint8 ZDApp_StopJoiningCycle( void )
   2524          {
   2525            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   2526            {
   2527              continueJoining = FALSE;
   2528              return ( TRUE );
   2529            }
   2530            else
   2531              return ( FALSE );
   2532          }
   2533          
   2534          /*********************************************************************
   2535           * @fn      ZDApp_AnnounceNewAddress()
   2536           *
   2537           * @brief   Send Device Announce and hold all transmissions for 
   2538           *          new address timeout.
   2539           *
   2540           * @param   none
   2541           *
   2542           * @return  none
   2543           */
   2544          void ZDApp_AnnounceNewAddress( void )
   2545          {
   2546          #if defined ( ZIGBEE_NWK_UNIQUE_ADDR_CHECK )
   2547            // Turn off data request hold
   2548            APSME_HoldDataRequests( 0 );
   2549          #endif
   2550            
   2551            ZDP_DeviceAnnce( NLME_GetShortAddr(), NLME_GetExtAddr(),
   2552                               ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   2553            
   2554          #if defined ( ZIGBEE_NWK_UNIQUE_ADDR_CHECK )
   2555            // Setup the timeout
   2556            APSME_HoldDataRequests( ZDAPP_HOLD_DATA_REQUESTS_TIMEOUT );
   2557          #endif  
   2558          }
   2559          
   2560          /*********************************************************************
   2561           * @fn          ZDApp_NVUpdate
   2562           *
   2563           * @brief       Set the NV Update Timer.
   2564           *
   2565           * @param       none
   2566           *
   2567           * @return      none
   2568           */
   2569          void ZDApp_NVUpdate( void )
   2570          {
   2571          #if defined ( NV_RESTORE )
   2572            osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, ZDAPP_UPDATE_NWK_NV_TIME );
   2573          #endif
   2574          }
   2575          
   2576          /*********************************************************************
   2577           * @fn      ZDApp_CoordStartPANIDConflictCB()
   2578           *
   2579           * @brief   Returns a PAN ID for the network layer to use during
   2580           *          a coordinator start and there is another network with 
   2581           *          the intended PANID.
   2582           *
   2583           * @param   panid - the intended PAN ID
   2584           *
   2585           * @return  PANID to try
   2586           */
   2587          uint16 ZDApp_CoordStartPANIDConflictCB( uint16 panid )
   2588          {
   2589            return ( panid + 1 );
   2590          }
   2591          
   2592          /*********************************************************************
   2593           * @fn          ZDO_SrcRtgIndCB
   2594           *
   2595           * @brief       This function notifies the ZDO available src route record received.
   2596           *
   2597           * @param       srcAddr - source address of the source route
   2598           * @param       relayCnt - number of devices in the relay list
   2599           * @param       relayList - relay list of the source route
   2600           *
   2601           * @return      none
   2602           */
   2603          void ZDO_SrcRtgIndCB (uint16 srcAddr, uint8 relayCnt, uint16* pRelayList )
   2604          {
   2605            zdoSrcRtg_t srcRtg;
   2606            
   2607            srcRtg.srcAddr = srcAddr;
   2608            srcRtg.relayCnt = relayCnt;
   2609            srcRtg.pRelayList = pRelayList;
   2610            
   2611            if( zdoCBFunc[ZDO_SRC_RTG_IND_CBID] != NULL )
   2612            {
   2613              zdoCBFunc[ZDO_SRC_RTG_IND_CBID]( (void*)&srcRtg );
   2614            }
   2615          }
   2616          
   2617          
   2618          /*********************************************************************
   2619           * @fn          ZDO_RegisterForZdoCB
   2620           *
   2621           * @brief       Call this function to register the higher layer (for 
   2622           *              example, the Application layer or MT layer) with ZDO 
   2623           *              callbacks to get notified of some ZDO indication like
   2624           *              existence of a concentrator or receipt of a source 
   2625           *              route record.
   2626           *
   2627           * @param       indID - ZDO Indication ID
   2628           * @param       pFn   - Callback function pointer
   2629           *
   2630           * @return      ZSuccess - successful, ZInvalidParameter if not
   2631           */
   2632          ZStatus_t ZDO_RegisterForZdoCB( uint8 indID, pfnZdoCb pFn )
   2633          {
   2634            // Check the range of the indication ID
   2635            if ( indID < MAX_ZDO_CB_FUNC )
   2636            {
   2637              zdoCBFunc[indID] = pFn;
   2638              return ZSuccess;
   2639            }
   2640            
   2641            return ZInvalidParameter;
   2642          }
   2643          
   2644          /*********************************************************************
   2645          *********************************************************************/

Errors: 25
Warnings: 2
