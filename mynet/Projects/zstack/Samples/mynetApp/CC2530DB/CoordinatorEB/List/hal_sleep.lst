###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:04 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\hal\target\CC2530EB\hal_sleep.c                 #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\hal\target\CC2530EB\hal_sleep.c -D ZTOOL_P1 -D  #
#                          MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D           #
#                          LCD_SUPPORTED=DEBUG -lC C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\CoordinatorEB\List\ -lA                    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ --diag_suppress Pe001,Pa010 -o                 #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\hal_sleep.lst                                   #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\hal_sleep.r51                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2009-10-21 17:53:50 -0700 (Wed, 21 Oct 2009) $
      4            Revision:       $Revision: 20956 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2530.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"
     46          #include "hal_board.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\hal\target\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration
     47          #include "hal_sleep.h"

  extern void halSleep( uint16 osal_timer );
                                           ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\INCLUDE\hal_sleep.h",55  Warning[Pe012]: 
          parsing restarts here after previous syntax error
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Timers.h"
     53          #include "OSAL_Tasks.h"
     54          #include "OSAL_PwrMgr.h"
     55          #include "OnBoard.h"
     56          #include "hal_drivers.h"
     57          #include "hal_assert.h"
     58          #include "mac_mcu.h"
     59          
     60          #ifndef ZG_BUILD_ENDDEVICE_TYPE
     61          # define ZG_BUILD_ENDDEVICE_TYPE FALSE
     62          #endif
     63          
     64          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
     65          #include "nwk_globals.h"
     66          #include "ZGlobals.h"
     67          #endif
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                           Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          /* POWER CONSERVATION DEFINITIONS
     75           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     76           */
     77          #define CC2530_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     78          #define CC2530_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     79          #define CC2530_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     80          #define CC2530_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     81          
     82          /* HAL power management mode is set according to the power management state. The default
     83           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     84           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     85           *   1. turn off the system clock, and
     86           *   2. halt the MCU.
     87           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     88           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     89           */
     90          #define HAL_SLEEP_OFF         CC2530_PM0
     91          #define HAL_SLEEP_TIMER       CC2530_PM2
     92          #define HAL_SLEEP_DEEP        CC2530_PM3
     93          
     94          /* MAX_SLEEP_TIME calculation:
     95           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
     96           *   Round it to 510 seconds or 510000 ms
     97           */
     98          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
     99          
    100          
    101          /* minimum time to sleep, this macro is to:
    102           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
    103           * 2. define minimum safe sleep period
    104           */
    105          #if !defined (PM_MIN_SLEEP_TIME)
    106          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time minimum CAP */
    107          #endif
    108          
    109          /* The PCON instruction must be 4-byte aligned. The following code may cause excessive power
    110           * consumption if not aligned. See linker file ".xcl" for actual placement.
    111           */
    112          #pragma location = "SLEEP_CODE"
    113          void halSetSleepMode(void);
    114          
    115          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    116           * compare takes into account the amount of processing time spent in function halSleep().
    117           * The first value is determined by measuring the number of sleep timer ticks it from
    118           * the beginning of the function to entering sleep mode.  The second value is determined
    119           * by measuring the number of sleep timer ticks from exit of sleep mode to the call to
    120           * osal_adjust_timers().
    121           */
    122          #define HAL_SLEEP_ADJ_TICKS   (7 + 10)
    123          
    124          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    125          /* set CC2530 power mode; always use PM2 */
    126          #define HAL_SLEEP_SET_POWER_MODE(mode)       st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    127                                                           SLEEPCMD |= mode;   /* set mode bits   */    \
    128                                                           while (!(STLOAD & LDRDY));                   \
    129                                                           {                                            \
    130                                                             halSetSleepMode();                         \
    131                                                           }                                            \
    132                                                         )
    133          #else
    134          /* Debug: don't set power mode, just block until sleep timer interrupt */
    135          #define HAL_SLEEP_SET_POWER_MODE(mode)      st( while(halSleepInt == FALSE); \
    136                                                          halSleepInt = FALSE;         \
    137                                                          HAL_DISABLE_INTERRUPTS();    \
    138                                                        )
    139          #endif
    140          
    141          /* sleep and external interrupt port masks */
    142          #define STIE_BV                             BV(5)
    143          #define P0IE_BV                             BV(5)
    144          #define P1IE_BV                             BV(4)
    145          #define P2IE_BV                             BV(1)
    146          
    147          /* sleep timer interrupt control */
    148          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    149          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    150          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(STIF = 0;)            /* clear sleep interrupt flag */
    151          
    152          /* backup interrupt enable registers before sleep */
    153          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    154                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    155                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    156                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    157                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    158                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    159          
    160          /* restore interrupt enable registers before sleep */
    161          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    162                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    163                                                            IEN2 = ien2;)  /* restore IEN2 register */
    164          
    165          /* convert msec to 320 usec units with round */
    166          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    167          
    168          /* for optimized indexing of uint32's */
    169          #if HAL_MCU_LITTLE_ENDIAN()
    170          #define UINT32_NDX0   0
    171          #define UINT32_NDX1   1
    172          #define UINT32_NDX2   2
    173          #define UINT32_NDX3   3
    174          #else
    175          #define UINT32_NDX0   3
    176          #define UINT32_NDX1   2
    177          #define UINT32_NDX2   1
    178          #define UINT32_NDX3   0
    179          #endif
    180          
    181          /* ------------------------------------------------------------------------------------------------
    182           *                                        Local Variables
    183           * ------------------------------------------------------------------------------------------------
    184           */
    185          
    186          /* HAL power management mode is set according to the power management state.
    187           */
    188          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
    189          
    190          /* stores the sleep timer count upon entering sleep */
    191          static uint32 halSleepTimerStart;
    192          
    193          /* stores the accumulated sleep time */
    194          static uint32 halAccumulatedSleepTime;
    195          
    196          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    197          static bool halSleepInt = FALSE;
    198          #endif
    199          
    200          /* ------------------------------------------------------------------------------------------------
    201           *                                      Function Prototypes
    202           * ------------------------------------------------------------------------------------------------
    203           */
    204          
    205          void halSleepSetTimer(uint32 timeout);
    206          uint32 HalTimerElapsed( void );
    207          
    208          /**************************************************************************************************
    209           * @fn          halSleep
    210           *
    211           * @brief       This function put the CC2530 to sleep. The PCON instruction must be 4-byte aligned.
    212           *              The following code may cause excessive power consumption if not aligned. See linker
    213           *              file ".xcl" for actual placement.
    214           *
    215           * input parameters
    216           *
    217           * @param       None.
    218           *
    219           * output parameters
    220           *
    221           * None.
    222           *
    223           * @return      None.
    224           **************************************************************************************************
    225           */
    226          void halSetSleepMode(void)
    227          {
    228            PCON = PCON_IDLE;
    229            HAL_DISABLE_INTERRUPTS();
    230          }
    231          
    232          /**************************************************************************************************
    233           * @fn          halSleep
    234           *
    235           * @brief       This function is called from the OSAL task loop using and existing OSAL
    236           *              interface.  It sets the low power mode of the MAC and the CC2530.
    237           *
    238           * input parameters
    239           *
    240           * @param       osal_timeout - Next OSAL timer timeout.
    241           *
    242           * output parameters
    243           *
    244           * None.
    245           *
    246           * @return      None.
    247           **************************************************************************************************
    248           */
    249          void halSleep( uint16 osal_timeout )
    250          {
    251            uint32        timeout;
    252            uint32        macTimeout = 0;
    253          
    254            halAccumulatedSleepTime = 0;
    255          
    256            /* get next OSAL timer expiration converted to 320 usec units */
    257            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
    258            if (timeout == 0)
    259            {
    260              timeout = MAC_PwrNextTimeout();
    261            }
    262            else
    263            {
    264              /* get next MAC timer expiration */
    265              macTimeout = MAC_PwrNextTimeout();
    266          
    267              /* get lesser of two timeouts */
    268              if ((macTimeout != 0) && (macTimeout < timeout))
    269              {
    270                timeout = macTimeout;
    271              }
    272            }
    273          
    274            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    275             * the device is a stimulated device.
    276             */
    277            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
    278          
    279            /* DEEP sleep can only be entered when zgPollRate == 0.
    280             * This is to eliminate any possibility of entering PM3 between
    281             * two network timers.
    282             */
    283          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
    284            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    285                (timeout == 0 && zgPollRate == 0))
    286          #else
    287            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    288                (timeout == 0))
    289          #endif
    290            {
    291              halIntState_t ien0, ien1, ien2;
    292          
    293              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
    294              HAL_DISABLE_INTERRUPTS();
    295          
    296              /* always use "deep sleep" to turn off radio VREG on CC2530 */
    297              if (MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
    298              {
    299          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    300                /* get peripherals ready for sleep */
    301                HalKeyEnterSleep();
    302          #endif
    303          
    304          #ifdef HAL_SLEEP_DEBUG_LED
    305                HAL_TURN_OFF_LED3();
    306          #else
    307                /* use this to turn LEDs off during sleep */
    308                HalLedEnterSleep();
    309          #endif
    310          
    311                /* enable sleep timer interrupt */
    312                if (timeout != 0)
    313                {
    314                  if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
    315                  {
    316                    timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
    317                    halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
    318                  }
    319                  else
    320                  {
    321                    /* set sleep timer */
    322                    halSleepSetTimer(timeout);
    323                  }
    324          
    325                  /* set up sleep timer interrupt */
    326                  HAL_SLEEP_TIMER_CLEAR_INT();
    327                  HAL_SLEEP_TIMER_ENABLE_INT();
    328                }
    329          
    330          #ifdef HAL_SLEEP_DEBUG_LED
    331                if (halPwrMgtMode == CC2530_PM1)
    332                {
    333                  HAL_TURN_ON_LED1();
    334                }
    335                else
    336                {
    337                  HAL_TURN_OFF_LED1();
    338                }
    339          #endif
    340          
    341                /* save interrupt enable registers and disable all interrupts */
    342                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
    343                HAL_ENABLE_INTERRUPTS();
    344          
    345                /* set CC2530 power mode, interrupt is disabled after this function */
    346                HAL_SLEEP_SET_POWER_MODE(halPwrMgtMode);
    347          
    348                /* the interrupt is disabled - see halSetSleepMode() */
    349          
    350                /* restore interrupt enable registers */
    351                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
    352          
    353                /* disable sleep timer interrupt */
    354                HAL_SLEEP_TIMER_DISABLE_INT();
    355          
    356                /* Calculate timer elasped */
    357                halAccumulatedSleepTime += (HalTimerElapsed() / TICK_COUNT);
    358          
    359          
    360          #ifdef HAL_SLEEP_DEBUG_LED
    361                HAL_TURN_ON_LED3();
    362          #else
    363                /* use this to turn LEDs back on after sleep */
    364                HalLedExitSleep();
    365          #endif
    366          
    367          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    368                /* handle peripherals */
    369                (void)HalKeyExitSleep();
    370          #endif
    371          
    372                /* power on the MAC; blocks until completion */
    373                MAC_PwrOnReq();
    374          
    375                HAL_ENABLE_INTERRUPTS();
    376          
    377                /* For CC2530, T2 interrupt won’t be generated when the current count is greater than
    378                 * the comparator. The interrupt is only generated when the current count is equal to
    379                 * the comparator. When the CC2530 is waking up from sleep, there is a small window
    380                 * that the count may be grater than the comparator, therefore, missing the interrupt.
    381                 * This workaround will call the T2 ISR when the current T2 count is greater than the
    382                 * comparator. The problem only occurs when POWER_SAVING is turned on, i.e. the 32KHz
    383                 * drives the chip in sleep and SYNC start is used.
    384                 */
    385                macMcuTimer2OverflowWorkaround();
    386              }
    387              else
    388              {
    389                HAL_ENABLE_INTERRUPTS();
    390              }
    391            }
    392          }
    393          
    394          /**************************************************************************************************
    395           * @fn          halSleepSetTimer
    396           *
    397           * @brief       This function sets the CC2530 sleep timer compare value.  First it reads and
    398           *              stores the value of the sleep timer; this value is used later to update OSAL
    399           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    400           *              period units and the compare value is set to the timeout.
    401           *
    402           * input parameters
    403           *
    404           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    405           *                        this value.
    406           *
    407           * output parameters
    408           *
    409           * None.
    410           *
    411           * @return      None.
    412           **************************************************************************************************
    413           */
    414          void halSleepSetTimer(uint32 timeout)
    415          {
    416            uint32 ticks;
    417          
    418            /* read the sleep timer; ST0 must be read first */
    419            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
    420            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
    421            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
    422            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
    423          
    424            /* store value for later */
    425            halSleepTimerStart = ticks;
    426          
    427            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    428             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    429             */
    430            ticks += (timeout * 671) / 64;
    431          
    432            /* subtract the processing time spent in function halSleep() */
    433            ticks -= HAL_SLEEP_ADJ_TICKS;
    434          
    435            /* set sleep timer compare; ST0 must be written last */
    436            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
    437            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
    438            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
    439          }
    440          
    441          /**************************************************************************************************
    442           * @fn          TimerElapsed
    443           *
    444           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    445           *
    446           * input parameters
    447           *
    448           * @param       None.
    449           *
    450           * output parameters
    451           *
    452           * None.
    453           *
    454           * @return      Number of timer ticks elapsed during sleep.
    455           **************************************************************************************************
    456           */
    457          uint32 TimerElapsed( void )
    458          {
    459            return ( halAccumulatedSleepTime );
    460          }
    461          
    462          /**************************************************************************************************
    463           * @fn          HalTimerElapsed
    464           *
    465           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.  This function
    466           *              relies on OSAL macro TICK_COUNT to be set to 1; then ticks are calculated in
    467           *              units of msec.
    468           *
    469           * input parameters
    470           *
    471           * @param       None.
    472           *
    473           * output parameters
    474           *
    475           * None.
    476           *
    477           * @return      Number of timer ticks elapsed during sleep.
    478           **************************************************************************************************
    479           */
    480          uint32 HalTimerElapsed( void )
    481          {
    482            uint32 ticks;
    483          
    484            /* read the sleep timer; ST0 must be read first */
    485            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
    486            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
    487            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
    488          
    489            /* set bit 24 to handle wraparound */
    490            ((uint8 *) &ticks)[UINT32_NDX3] = 0x01;
    491          
    492            /* calculate elapsed time */
    493            ticks -= halSleepTimerStart;
    494          
    495            /* add back the processing time spent in function halSleep() */
    496            ticks += HAL_SLEEP_ADJ_TICKS;
    497          
    498            /* mask off excess if no wraparound */
    499            ticks &= 0x00FFFFFF;
    500          
    501            /* Convert elapsed time in milliseconds with round.  1000/32768 = 125/4096 */
    502            return ( ((ticks * 125) + 4095) / 4096 );
    503          }
    504          
    505          /**************************************************************************************************
    506           * @fn          halSleepWait
    507           *
    508           * @brief       Perform a blocking wait.
    509           *
    510           * input parameters
    511           *
    512           * @param       duration - Duration of wait in microseconds.
    513           *
    514           * output parameters
    515           *
    516           * None.
    517           *
    518           * @return      None.
    519           **************************************************************************************************
    520           */
    521          void halSleepWait(uint16 duration)
    522          {
    523            while (duration--)
    524            {
    525              asm("NOP");
    526              asm("NOP");
    527              asm("NOP");
    528              asm("NOP");
    529              asm("NOP");
    530              asm("NOP");
    531              asm("NOP");
    532              asm("NOP");
    533            }
    534          }
    535          
    536          /**************************************************************************************************
    537           * @fn          halRestoreSleepLevel
    538           *
    539           * @brief       Restore the deepest timer sleep level.
    540           *
    541           * input parameters
    542           *
    543           * @param       None
    544           *
    545           * output parameters
    546           *
    547           *              None.
    548           *
    549           * @return      None.
    550           **************************************************************************************************
    551           */
    552          void halRestoreSleepLevel( void )
    553          {
    554            /* Stubs */
    555          }
    556          
    557          /**************************************************************************************************
    558           * @fn          halSleepTimerIsr
    559           *
    560           * @brief       Sleep timer ISR.
    561           *
    562           * input parameters
    563           *
    564           * None.
    565           *
    566           * output parameters
    567           *
    568           * None.
    569           *
    570           * @return      None.
    571           **************************************************************************************************
    572           */
    573          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
    574          {
    575            HAL_SLEEP_TIMER_CLEAR_INT();
    576            CLEAR_SLEEP_MODE();
    577          
    578          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    579            halSleepInt = TRUE;
    580          #endif
    581          }
    582          

Errors: 24
Warnings: 2
