###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Apr/2021  11:31:02 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mac\low_level\srf04\single_chip\mac_csp_tx.c    #
#    Command line       =  -f C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\..\..\..\Tool #
#                          s\CC2530DB\f8wCoord.cfg (-DCPU32MHZ                #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DZDO_COORDINATOR -DRTR_NWK -DBLINK_LEDS) -f     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\Tools\C #
#                          C2530DB\f8wConfig.cfg (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Componen #
#                          ts\mac\low_level\srf04\single_chip\mac_csp_tx.c    #
#                          -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D           #
#                          MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -lC             #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\ -lA C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\ #
#                          Projects\zstack\Samples\mynetApp\CC2530DB\Coordina #
#                          torEB\List\ --diag_suppress Pe001,Pa010 -o         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\ -e --debug --core=plain --dptr=16,1             #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Proje #
#                          cts\zstack\Samples\mynetApp\CC2530DB\ -I           #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\SOURCE\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\ZMAIN\T #
#                          I2530DB\ -I C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\my #
#                          net\Projects\zstack\Samples\mynetApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\MT\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\HAL\TARGET\CC2530EB\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\MCU\CCSOC\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\OSAL\INCLUDE\ -I                         #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\AF\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\ -I     #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SEC\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\ -I   #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\STACK\SYS\ -I C:\Users\25749\OneDrive\×À #
#                          Ãæ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\C #
#                          C2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\ -I    #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\ZMAC\F8W\ -I C:\Users\25749\OneDrive\×ÀÃ #
#                          æ\Zigbee\mynet\Projects\zstack\Samples\mynetApp\CC #
#                          2530DB\..\..\..\..\..\COMPONENTS\ZMAC\ -I          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SADDR\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\SERVICES\SDATA\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\INCLUDE\ -I                          #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\HIGH_LEVEL\ -I                       #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\ -I                  #
#                          C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\..\..\..\..\..\C #
#                          OMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz    #
#    List file          =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Li #
#                          st\mac_csp_tx.lst                                  #
#    Object file        =  C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Projects #
#                          \zstack\Samples\mynetApp\CC2530DB\CoordinatorEB\Ob #
#                          j\mac_csp_tx.r51                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\mac\low_level\srf04\single_chip\mac_csp_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_csp_tx.c
      3            Revised:        $Date: 2009-08-12 14:34:18 -0700 (Wed, 12 Aug 2009) $
      4            Revision:       $Revision: 20549 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                           Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mcu.h"
     48          
     49          /* high-level */
     50          #include "mac_spec.h"
     51          #include "mac_pib.h"
     52          
     53          /* exported low-level */
     54          #include "mac_low_level.h"
     55          
     56          /* low-level specific */
     57          #include "mac_csp_tx.h"

    for (i=0; i<504; i++) asm("NOP");          /* Require 63us delay for all revs */                \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",228  Error[Pe169]: 
          expected a declaration

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe077]: 
          this declaration has no storage class or type specifier

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr CLKCONCMD" (declared at line 200 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    CLKCONCMD = (CLKCONCMD_32MHZ | OSC_32KHZ); /* Select 32MHz XOSC and the source for 32K clock */ \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",229  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    while (CLKCONSTA != (CLKCONCMD_32MHZ | OSC_32KHZ)); /* Wait for the change to be effective */   \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",230  Error[Pe169]: 
          expected a declaration

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe077]: 
          this declaration has no storage class or type specifier

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe147]: 
          declaration is incompatible with
          "unsigned char volatile __sfr SLEEPCMD" (declared at line 190 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench 6.0
          Evaluation\8051\inc\ioCC2530.h")

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    SLEEPCMD |= OSC_PD;                        /* turn off 16MHz RC */                              \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",231  Error[Pe065]: 
          expected a ";"

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe007]: 
          unrecognized token

    PREFETCH_ENABLE();                                             \//´ò¿ªÁËÒ»¸ö¼Ä´æÆ÷£¬»º´æÊ¹ÄÜ£¬¸úCPUµÄÈ¡Ö¸ÁîÓÐ¹Ø
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",234  Error[Pe169]: 
          expected a declaration

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                       ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Warning[Pe012]: 
          parsing restarts here after previous syntax error

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe007]: 
          unrecognized token

    LED1_DDR |= LED1_BV;                                           \//½«P1_0¡¢P1_1¡¢P1_4Èý¸ö¿ÚÅäÖÃÎªÊä³ö
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",237  Error[Pe169]: 
          expected a declaration

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe077]: 
          this declaration has no storage class or type specifier

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P1DIR"
          (declared at line 268 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    LED3_DDR |= LED3_BV;                                           \
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    LED3_DDR |= LED3_BV;                                           \
             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",239  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe077]: 
          this declaration has no storage class or type specifier

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe147]: 
          declaration is incompatible with "unsigned char volatile __sfr P0INP"
          (declared at line 131 of "C:\Program Files (x86)\IAR
          Systems\Embedded Workbench 6.0 Evaluation\8051\inc\ioCC2530.h")

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
    ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Be022]: 
          location address not allowed for initialized variables (writable
          variables without the __no_init attribute)

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
          ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe065]: 
          expected a ";"

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe007]: 
          unrecognized token

    P0INP |= PUSH2_BV;                                             \//½«P0_0ÅäÖÃÎªÈýÌ¬
                                                                   ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\COMPONENTS\HAL\TARGET\CC2530EB\hal_board_cfg.h",242  Error[Pe169]: 
          expected a declaration

  extern uint8 macChipVersion;
                             ^
"C:\Users\25749\OneDrive\×ÀÃæ\Zigbee\mynet\Components\mac\low_level\srf04\single_chip\mac_mcu.h",193  Warning[Pe012]: 
          parsing restarts here after previous syntax error
     58          #include "mac_tx.h"
     59          #include "mac_rx.h"
     60          #include "mac_rx_onoff.h"
     61          
     62          /* target specific */
     63          #include "mac_radio_defs.h"
     64          
     65          /* debug */
     66          #include "mac_assert.h"
     67          
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                   CSP Defines / Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          /* immediate strobe commands */
     74          #define ISSTART     0xE1
     75          #define ISSTOP      0xE2
     76          #define ISCLEAR     0xFF
     77          
     78          /* strobe processor instructions */
     79          #define SKIP(s,c)   (0x00 | (((s) & 0x07) << 4) | ((c) & 0x0F))   /* skip 's' instructions if 'c' is true  */
     80          #define WHILE(c)    SKIP(0,c)              /* pend while 'c' is true (derived instruction)        */
     81          #define WAITW(w)    (0x80 | ((w) & 0x1F))  /* wait for 'w' number of MAC timer overflows          */
     82          #define WEVENT1     (0xB8)                 /* wait for MAC timer compare                          */
     83          #define WAITX       (0xBC)                 /* wait for CSPX number of MAC timer overflows         */
     84          #define LABEL       (0xBB)                 /* set next instruction as start of loop               */
     85          #define RPT(c)      (0xA0 | ((c) & 0x0F))  /* if condition is true jump to last label             */
     86          #define INT         (0xBA)                 /* assert IRQ_CSP_INT interrupt                        */
     87          #define INCY        (0xC1)                 /* increment CSPY                                      */
     88          #define INCMAXY(m)  (0xC8 | ((m) & 0x07))  /* increment CSPY but not above maximum value of 'm'   */
     89          #define DECY        (0xC4)                 /* decrement CSPY                                      */
     90          #define DECZ        (0xC5)                 /* decrement CSPZ                                      */
     91          #define RANDXY      (0xBD)                 /* load the lower CSPY bits of CSPX with random value  */
     92          
     93          /* strobe processor command instructions */
     94          #define SSTOP       (0xD2)    /* stop program execution                                      */
     95          #define SNOP        (0xD0)    /* no operation                                                */
     96          #define STXCAL      (0xDC)    /* enable and calibrate frequency synthesizer for TX           */
     97          #define SRXON       (0xD3)    /* turn on receiver                                            */
     98          #define STXON       (0xD9)    /* transmit after calibration                                  */
     99          #define STXONCCA    (0xDA)    /* transmit after calibration if CCA indicates clear channel   */
    100          #define SRFOFF      (0xDF)    /* turn off RX/TX                                              */
    101          #define SFLUSHRX    (0xDD)    /* flush receive FIFO                                          */
    102          #define SFLUSHTX    (0xDE)    /* flush transmit FIFO                                         */
    103          #define SACK        (0xD6)    /* send ACK frame                                              */
    104          #define SACKPEND    (0xD7)    /* send ACK frame with pending bit set                         */
    105          
    106          /* conditions for use with instructions SKIP and RPT */
    107          #define C_CCA_IS_VALID        0x00
    108          #define C_SFD_IS_ACTIVE       0x01
    109          #define C_CPU_CTRL_IS_ON      0x02
    110          #define C_END_INSTR_MEM       0x03
    111          #define C_CSPX_IS_ZERO        0x04
    112          #define C_CSPY_IS_ZERO        0x05
    113          #define C_CSPZ_IS_ZERO        0x06
    114          
    115          /* negated conditions for use with instructions SKIP and RPT */
    116          #define C_NEGATE(c)   ((c) | 0x08)
    117          #define C_CCA_IS_INVALID      C_NEGATE(C_CCA_IS_VALID)
    118          #define C_SFD_IS_INACTIVE     C_NEGATE(C_SFD_IS_ACTIVE)
    119          #define C_CPU_CTRL_IS_OFF     C_NEGATE(C_CPU_CTRL_IS_ON)
    120          #define C_NOT_END_INSTR_MEM   C_NEGATE(C_END_INSTR_MEM)
    121          #define C_CSPX_IS_NON_ZERO    C_NEGATE(C_CSPX_IS_ZERO)
    122          #define C_CSPY_IS_NON_ZERO    C_NEGATE(C_CSPY_IS_ZERO)
    123          #define C_CSPZ_IS_NON_ZERO    C_NEGATE(C_CSPZ_IS_ZERO)
    124          
    125          
    126          /* ------------------------------------------------------------------------------------------------
    127           *                                         Defines
    128           * ------------------------------------------------------------------------------------------------
    129           */
    130          
    131          /* CSPZ return values from CSP program */
    132          #define CSPZ_CODE_TX_DONE           0
    133          #define CSPZ_CODE_CHANNEL_BUSY      1
    134          #define CSPZ_CODE_TX_ACK_TIME_OUT   2
    135          
    136          
    137          /* ------------------------------------------------------------------------------------------------
    138           *                                     Local Programs
    139           * ------------------------------------------------------------------------------------------------
    140           */
    141          static void  cspPrepForTxProgram(void);
    142          static void  cspWeventSetTriggerNow(void);
    143          static void  cspWeventSetTriggerSymbols(uint8 symbols);
    144          static uint8 cspReadCountSymbols(void);
    145          
    146          
    147          
    148          /* ------------------------------------------------------------------------------------------------
    149           *                                          Macros
    150           * ------------------------------------------------------------------------------------------------
    151           */
    152          #define CSP_STOP_AND_CLEAR_PROGRAM()          st( RFST = ISSTOP; RFST = ISCLEAR; )
    153          #define CSP_START_PROGRAM()                   st( RFST = ISSTART; )
    154          
    155          /*
    156           *  These macros improve readability of using T2CMP in conjunction with WEVENT.
    157           *
    158           *  The timer2 compare, T2CMP, only compares one byte of the 16-bit timer register.
    159           *  It is configurable and has been set to compare against the upper byte of the timer value.
    160           *  The CSP instruction WEVENT waits for the timer value to be greater than or equal
    161           *  the value of T2CMP.
    162           *
    163           *  Reading the timer value is done by reading the low byte first.  This latches the
    164           *  high byte.  A trick with the ternary operator is used by a macro below to force a
    165           *  read of the low byte when returning the value of the high byte.
    166           *
    167           *  CSP_WEVENT_SET_TRIGGER_NOW()      - sets the WEVENT1 trigger point at the current timer count
    168           *  CSP_WEVENT_SET_TRIGGER_SYMBOLS(x) - sets the WEVENT1 trigger point in symbols
    169           *  CSP_WEVENT_READ_COUNT_SYMBOLS()   - reads the current timer count in symbols
    170           */
    171          #define T2THD_TICKS_PER_SYMBOL                (MAC_RADIO_TIMER_TICKS_PER_SYMBOL() >> 8)
    172          
    173          #define CSP_WEVENT_CLEAR_TRIGGER()            st( T2IRQF &= ~TIMER2_COMPARE1F; )
    174          #define CSP_WEVENT_SET_TRIGGER_NOW()          cspWeventSetTriggerNow()
    175          #define CSP_WEVENT_SET_TRIGGER_SYMBOLS(x)     cspWeventSetTriggerSymbols(x)
    176          #define CSP_WEVENT_READ_COUNT_SYMBOLS()       cspReadCountSymbols()
    177          
    178          /*
    179           *  Number of bits used for aligning a slotted transmit to the backoff count (plus
    180           *  derived values).  There are restrictions on this value.  Compile time integrity
    181           *  checks will catch an illegal setting of this value.  A full explanation accompanies
    182           *  this compile time check (see bottom of this file).
    183           */
    184          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS     4
    185          #define SLOTTED_TX_MAX_BACKOFF_COUNTDOWN              (1 << SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS)
    186          #define SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK       (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - 1)
    187          
    188          
    189          /**************************************************************************************************
    190           * @fn          macCspTxReset
    191           *
    192           * @brief       Reset the CSP.  Immediately halts any running program.
    193           *
    194           * @param       none
    195           *
    196           * @return      none
    197           **************************************************************************************************
    198           */
    199          MAC_INTERNAL_API void macCspTxReset(void)
    200          {
    201            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    202            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
    203            CSP_STOP_AND_CLEAR_PROGRAM();
    204          }
    205          
    206          
    207          /*=================================================================================================
    208           * @fn          cspWeventSetTriggerNow
    209           *
    210           * @brief       sets the WEVENT1 trigger point at the current timer count
    211           *
    212           * @param       none
    213           *
    214           * @return      symbols
    215           *=================================================================================================
    216           */
    217          static void cspWeventSetTriggerNow(void)
    218          {
    219            halIntState_t  s;
    220            uint8          temp0, temp1;
    221          
    222            /* Clear the compare interrupt flag for debugging purpose. */
    223            CSP_WEVENT_CLEAR_TRIGGER();
    224          
    225            /* copy current timer count to compare */
    226            HAL_ENTER_CRITICAL_SECTION(s);
    227            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    228            temp0 = T2M0;
    229            temp1 = T2M1;
    230          
    231            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    232             * compare = 0 for both the timer and the overflow counter.
    233             */
    234            if ((macChipVersion <= REV_B) && (temp0 == 0) && (temp1 == 0))
                        ^
Error[Pe020]: identifier "macChipVersion" is undefined
    235            {
    236              temp0++;
    237            }
    238          
    239            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    240            T2M0 = temp0;
    241            T2M1 = temp1;
    242            HAL_EXIT_CRITICAL_SECTION(s);
    243          }
    244          
    245          
    246          /*=================================================================================================
    247           * @fn          cspWeventSetTriggerSymbols
    248           *
    249           * @brief       sets the WEVENT1 trigger point in symbols
    250           *
    251           * @param       symbols
    252           *
    253           * @return      none
    254           *=================================================================================================
    255           */
    256          static void cspWeventSetTriggerSymbols(uint8 symbols)
    257          {
    258            halIntState_t  s;
    259            uint16         cmp;
    260          
    261            MAC_ASSERT(symbols <= MAC_A_UNIT_BACKOFF_PERIOD);
    262          
    263            /* Clear the compare interrupt flag for debugging purpose. */
    264            CSP_WEVENT_CLEAR_TRIGGER();
    265          
    266            HAL_ENTER_CRITICAL_SECTION(s);
    267            MAC_MCU_T2_ACCESS_CMP1_VALUE();
    268            cmp  = (symbols) * MAC_RADIO_TIMER_TICKS_PER_SYMBOL();
    269          
    270            /* MAC timer bug on the cc2530 PG1 made it impossible to use
    271             * compare = 0 for both the timer and the overflow counter.
    272             */
    273            if ((macChipVersion <= REV_B) && (cmp == 0))
                        ^
Error[Pe020]: identifier "macChipVersion" is undefined
    274            {
    275              cmp++;
    276            }
    277            T2M0 = (cmp & 0xFF);
    278            T2M1 = (cmp >> 8);
    279            HAL_EXIT_CRITICAL_SECTION(s);
    280          }
    281          
    282          
    283          /*=================================================================================================
    284           * @fn          cspReadCountSymbols
    285           *
    286           * @brief       reads the current timer count in symbols
    287           *
    288           * @param       none
    289           *
    290           * @return      symbols
    291           *=================================================================================================
    292           */
    293          static uint8 cspReadCountSymbols(void)
    294          {
    295            uint8          countLow, countHigh;
    296            halIntState_t  s;
    297          
    298            HAL_ENTER_CRITICAL_SECTION(s);
    299            MAC_MCU_T2_ACCESS_COUNT_VALUE();
    300            countLow  = T2M0;
    301            countHigh = T2M1;
    302            HAL_EXIT_CRITICAL_SECTION(s);
    303          
    304            return (((countHigh << 8) | countLow) / MAC_RADIO_TIMER_TICKS_PER_SYMBOL());
    305          }
    306          
    307          
    308          /*=================================================================================================
    309           * @fn          cspPrepForTxProgram
    310           *
    311           * @brief       Prepare and initialize for transmit CSP program.
    312           *              Call *before* loading the CSP program!
    313           *
    314           * @param       none
    315           *
    316           * @return      none
    317           *=================================================================================================
    318           */
    319          static void cspPrepForTxProgram(void)
    320          {
    321            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
    322          
    323            /* set CSP EVENT1 to T2 CMP1 */
    324            MAC_MCU_CONFIG_CSP_EVENT1();
    325          
    326            /* set up parameters for CSP transmit program */
    327            CSPZ = CSPZ_CODE_CHANNEL_BUSY;
    328          
    329            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    330            CSP_STOP_AND_CLEAR_PROGRAM();
    331            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
    332            MAC_MCU_CSP_INT_CLEAR_INTERRUPT();
    333          }
    334          
    335          
    336          /**************************************************************************************************
    337           * @fn          macCspTxPrepCsmaUnslotted
    338           *
    339           * @brief       Prepare CSP for "Unslotted CSMA" transmit.  Load CSP program and set CSP parameters.
    340           *
    341           * @param       none
    342           *
    343           * @return      none
    344           **************************************************************************************************
    345           */
    346          MAC_INTERNAL_API void macCspTxPrepCsmaUnslotted(void)
    347          {
    348            cspPrepForTxProgram();
    349          
    350            /*----------------------------------------------------------------------
    351             *  Load CSP program :  Unslotted CSMA transmit
    352             */
    353          
    354            /*
    355             *  Wait for X number of backoffs, then wait for intra-backoff count
    356             *  to reach value set for WEVENT1.
    357             */
    358            RFST = WAITX;
    359            RFST = WEVENT1;
    360          
    361            /* wait for one backoff to guarantee receiver has been on at least that long */
    362            RFST = WAITW(1);
    363            RFST = WEVENT1;
    364          
    365            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    366            RFST = SKIP(1, C_CCA_IS_VALID);
    367            RFST = SSTOP;
    368          
    369            /* CSMA has passed so transmit (actual frame starts one backoff from when strobe is sent) */
    370            RFST = STXON;
    371          
    372            /*
    373             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    374             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    375             *  though, is not certain.  For bulletproof operation, the first step is to wait
    376             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    377             *  for it to go active.
    378             */
    379            RFST = WHILE(C_SFD_IS_ACTIVE);
    380            RFST = WHILE(C_SFD_IS_INACTIVE);
    381          
    382            /*
    383             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    384             *  The ISR for this interrupt records the timestamp (which was just captured
    385             *  when SFD went high).
    386             */
    387            RFST = INT;
    388          
    389            /*
    390             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    391             *  the transmit was successful.
    392             */
    393            RFST = WHILE(C_SFD_IS_ACTIVE);
    394            RFST = DECZ;
    395          
    396            /*
    397             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    398             */
    399            RFST = SSTOP;
    400          }
    401          
    402          
    403          /**************************************************************************************************
    404           * @fn          macCspTxPrepCsmaSlotted
    405           *
    406           * @brief       Prepare CSP for "Slotted CSMA" transmit.  Load CSP program and set CSP parameters.
    407           *
    408           * @param       none
    409           *
    410           * @return      none
    411           **************************************************************************************************
    412           */
    413          MAC_INTERNAL_API void macCspTxPrepCsmaSlotted(void)
    414          {
    415            cspPrepForTxProgram();
    416          
    417            /*----------------------------------------------------------------------
    418             *  Load CSP program :  Slotted CSMA transmit
    419             */
    420          
    421            /* wait for X number of backoffs */
    422            RFST = WAITX;
    423          
    424            /* wait for one backoff to guarantee receiver has been on at least that long */
    425            RFST = WAITW(1);
    426          
    427            /* sample CCA, if it fails exit from here, CSPZ indicates result */
    428            RFST = SKIP(1, C_CCA_IS_VALID);
    429            RFST = SSTOP;
    430          
    431            /* per slotted CSMA-CCA in specification, wait one backoff */
    432            RFST = WAITW(1);
    433          
    434            /* sample CCA again, if it fails exit from here, CSPZ indicates result */
    435            RFST = SKIP(1, C_CCA_IS_VALID);
    436            RFST = SSTOP;
    437          
    438            /* CSMA has passed so transmit */
    439            RFST = STXON;
    440          
    441            /*
    442             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    443             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    444             *  though, is not certain.  For bulletproof operation, the first step is to wait
    445             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    446             *  for it to go active.
    447             */
    448            RFST = WHILE(C_SFD_IS_ACTIVE);
    449            RFST = WHILE(C_SFD_IS_INACTIVE);
    450          
    451            /*
    452             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    453             *  The ISR for this interrupt records the timestamp (which was just captured
    454             *  when SFD went high).
    455             */
    456            RFST = INT;
    457          
    458            /*
    459             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    460             *  the transmit was successful.
    461             */
    462            RFST = WHILE(C_SFD_IS_ACTIVE);
    463            RFST = DECZ;
    464          
    465            /*
    466             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    467             */
    468            RFST = SSTOP;
    469          }
    470          
    471          
    472          /**************************************************************************************************
    473           * @fn          macCspTxGoCsma
    474           *
    475           * @brief       Run previously loaded CSP program for CSMA transmit.  Handles either
    476           *              slotted or unslotted CSMA transmits.  When CSP program has finished,
    477           *              an interrupt occurs and macCspTxStopIsr() is called.  This ISR will in
    478           *              turn call macTxDoneCallback().
    479           *
    480           * @param       none
    481           *
    482           * @return      none
    483           **************************************************************************************************
    484           */
    485          MAC_INTERNAL_API void macCspTxGoCsma(void)
    486          {
    487            /*
    488             *  Set CSPX with the countdown time of the CSMA delay.  Subtract one because there is
    489             *  a built-in one backoff delay in the CSP program to make sure receiver has been 'on'
    490             *  for at least one backoff.  Don't subtract though if CSPX is already zero!
    491             */
    492            CSPX = macTxCsmaBackoffDelay;
    493            if (CSPX != 0)
    494            {
    495              CSPX--;
    496            }
    497          
    498            /*
    499             *  Set WEVENT to trigger at the current value of the timer.  This allows
    500             *  unslotted CSMA to transmit just a little bit sooner.
    501             */
    502            CSP_WEVENT_SET_TRIGGER_NOW();
    503          
    504            /*
    505             *  Enable interrupt that fires when CSP program stops.
    506             *  Also enable interrupt that fires when INT instruction
    507             *  is executed.
    508             */
    509            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    510            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    511          
    512            /*
    513             *  Turn on the receiver if it is not already on.  Receiver must be 'on' for at
    514             *  least one backoff before performing clear channel assessment (CCA).
    515             */
    516            macRxOn();
    517          
    518            /* start the CSP program */
    519            CSP_START_PROGRAM();
    520          }
    521          
    522          
    523          /**************************************************************************************************
    524           * @fn          macCspTxPrepSlotted
    525           *
    526           * @brief       Prepare CSP for "Slotted" (non-CSMA) transmit.
    527           *              Load CSP program and set CSP parameters.
    528           *
    529           * @param       none
    530           *
    531           * @return      none
    532           **************************************************************************************************
    533           */
    534          MAC_INTERNAL_API void macCspTxPrepSlotted(void)
    535          {
    536            cspPrepForTxProgram();
    537          
    538            /*----------------------------------------------------------------------
    539             *  Load CSP program :  Slotted transmit (no CSMA)
    540             */
    541          
    542            /* wait for X number of backoffs */
    543            RFST = WAITX;
    544          
    545            /* just transmit, no CSMA required */
    546            RFST = STXON;
    547          
    548            /*
    549             *  Wait for the start of frame delimiter of the transmitted frame.  If SFD happens to
    550             *  already be active when STXON is strobed, it gets forced low.  How long this takes
    551             *  though, is not certain.  For bulletproof operation, the first step is to wait
    552             *  until SFD is inactive (which should be very fast if even necessary), and then wait
    553             *  for it to go active.
    554             */
    555            RFST = WHILE(C_SFD_IS_ACTIVE);
    556            RFST = WHILE(C_SFD_IS_INACTIVE);
    557          
    558            /*
    559             *  Record the timestamp.  The INT instruction causes an interrupt to fire.
    560             *  The ISR for this interrupt records the timestamp (which was just captured
    561             *  when SFD went high).
    562             */
    563            RFST = INT;
    564          
    565            /*
    566             *  Wait for SFD to go inactive which is the end of transmit.  Decrement CSPZ to indicate
    567             *  the transmit was successful.
    568             */
    569            RFST = WHILE(C_SFD_IS_ACTIVE);
    570            RFST = DECZ;
    571          
    572            /*
    573             * CC2530 requires SSTOP to generate CSP_STOP interrupt.
    574             */
    575            RFST = SSTOP;
    576          
    577          }
    578          
    579          
    580          /**************************************************************************************************
    581           * @fn          macCspTxGoSlotted
    582           *
    583           * @brief       Run previously loaded CSP program for non-CSMA slotted transmit.   When CSP
    584           *              program has finished, an interrupt occurs and macCspTxStopIsr() is called.
    585           *              This ISR will in turn call macTxDoneCallback().
    586           *
    587           * @param       none
    588           *
    589           * @return      none
    590           **************************************************************************************************
    591           */
    592          MAC_INTERNAL_API void macCspTxGoSlotted(void)
    593          {
    594            halIntState_t  s;
    595            uint8 lowByteOfBackoffCount;
    596            uint8 backoffCountdown;
    597          
    598            /*
    599             *  Enable interrupt that fires when CSP program stops.
    600             *  Also enable interrupt that fires when INT instruction
    601             *  is executed.
    602             */
    603            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    604            MAC_MCU_CSP_INT_ENABLE_INTERRUPT();
    605          
    606            /* critical section needed for timer accesses */
    607            HAL_ENTER_CRITICAL_SECTION(s);
    608          
    609            /* store lowest byte of backoff count (same as lowest byte of overflow count) */
    610            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    611          
    612            /* Latch T2MOVFx */
    613            T2M0;
    614            lowByteOfBackoffCount = T2MOVF0;
    615          
    616            /*
    617             *  Compute the number of backoffs until time to strobe transmit.  The strobe should
    618             *  occur one backoff before the SFD pin is expected to go high.  So, the forumla for the
    619             *  countdown value is to determine when the lower bits would rollover and become zero,
    620             *  and then subtract one.
    621             */
    622            backoffCountdown = SLOTTED_TX_MAX_BACKOFF_COUNTDOWN - (lowByteOfBackoffCount & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) - 1;
    623          
    624            /*
    625             *  Store backoff countdown value into CSPX.
    626             *
    627             *  Note: it is OK if this value is zero.  The WAITX instruction at the top of the
    628             *  CSP program will immediately continue if CSPX is zero when executed.  However,
    629             *  if the countdown is zero, it means the transmit function was not called early
    630             *  enough for a properly timed slotted transmit.  The transmit will be late.
    631             */
    632            CSPX = backoffCountdown;
    633          
    634            /* Disable Rx and flush RXFIFO due to chip bug #1546 */
    635            macRxHardDisable();
    636          
    637            /*
    638             *  The receiver will be turned on during CSP execution, guaranteed.
    639             *  Since it is not possible to update C variables within the CSP,
    640             *  the new "on" state of the receiver must be set a little early
    641             *  here before the CSP is started.
    642             */
    643            MAC_RX_WAS_FORCED_ON();
    644          
    645            /* start the CSP program */
    646            CSP_START_PROGRAM();
    647          
    648            /*
    649             *  If the previous stored low byte of the backoff count is no longer equal to
    650             *  the current value, a rollover has occurred.  This means the backoff countdown
    651             *  stored in CSPX may not be correct.
    652             *
    653             *  In this case, the value of CSPX is reloaded to reflect the correct backoff
    654             *  countdown value (this is one less than what was just used as a rollover has
    655             *  occurred).  Since it is certain a rollover *just* occurred, there is no danger
    656             *  of another rollover occurring.  This means the value written to CSPX is guaranteed
    657             *  to be accurate.
    658             *
    659             *  Also, the logic below ensures that the value written to CSPX is at least one.
    660             *  This is needed for correct operation of the WAITX instruction.  As with an
    661             *  initial backoff countdown value of zero, if this case does occur, it means the
    662             *  transmit function was not called early enough for a properly timed slotted transmit.
    663             *  The transmit will be late.
    664             *
    665             *  Finally, worth noting, writes to CSPX may not work if the CSP is executing the WAITX
    666             *  instruction and a timer rollover occurs.  In this case, however, there is no possibility
    667             *  of that happening.  If CSPX is updated here, a rollover has just occurred so a
    668             *  collision is not possible (still within a critical section here too).
    669             */
    670            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
    671          
    672            /* Latch T2MOVFx */
    673            T2M0;
    674            if ((lowByteOfBackoffCount != T2MOVF0) && (backoffCountdown > 1))
    675            {
    676              CSPX = backoffCountdown - 1;
    677            }
    678          
    679            HAL_EXIT_CRITICAL_SECTION(s);
    680          }
    681          
    682          
    683          /**************************************************************************************************
    684           * @fn          macCspForceTxDoneIfPending
    685           *
    686           * @brief       The function clears out any pending TX done logic.  Used by receive logic
    687           *              to make sure its ISR does not prevent transmit from completing in a reasonable
    688           *              amount of time.
    689           *
    690           * @param       none
    691           *
    692           * @return      none
    693           **************************************************************************************************
    694           */
    695          MAC_INTERNAL_API void macCspForceTxDoneIfPending(void)
    696          {
    697            if ((CSPZ == CSPZ_CODE_TX_DONE) &&  MAC_MCU_CSP_STOP_INTERRUPT_IS_ENABLED())
    698            {
    699              MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    700              if (MAC_MCU_CSP_INT_INTERRUPT_IS_ENABLED())
    701              {
    702                macCspTxIntIsr();
    703              }
    704              macTxDoneCallback();
    705            }
    706          }
    707          
    708          
    709          /**************************************************************************************************
    710           * @fn          macCspTxRequestAckTimeoutCallback
    711           *
    712           * @brief       Requests a callback after the ACK timeout period has expired.  At that point,
    713           *              the function macTxAckTimeoutCallback() is called via an interrupt.
    714           *
    715           * @param       none
    716           *
    717           * @return      none
    718           **************************************************************************************************
    719           */
    720          MAC_INTERNAL_API void macCspTxRequestAckTimeoutCallback(void)
    721          {
    722            uint8 startSymbol;
    723            uint8 symbols;
    724            uint8 rollovers;
    725          
    726            MAC_ASSERT(!(RFIRQM1 & IM_CSP_STOP)); /* already an active CSP program */
    727          
    728            /* record current symbol count */
    729            startSymbol = CSP_WEVENT_READ_COUNT_SYMBOLS();
    730          
    731            /* set symbol timeout from PIB */
    732            symbols = macPib.ackWaitDuration;
    733          
    734            /* make sure delay value is not too small for logic to handle */
    735            MAC_ASSERT(symbols > MAC_A_UNIT_BACKOFF_PERIOD);  /* symbols timeout period must be great than a backoff */
    736          
    737            /* subtract out symbols left in current backoff period */
    738            symbols = symbols - (MAC_A_UNIT_BACKOFF_PERIOD - startSymbol);
    739          
    740            /* calculate rollovers needed for remaining symbols */
    741            rollovers = symbols / MAC_A_UNIT_BACKOFF_PERIOD;
    742          
    743            /* calculate symbols that still need counted after last rollover */
    744            symbols = symbols - (rollovers * MAC_A_UNIT_BACKOFF_PERIOD);
    745          
    746            /* add one to rollovers to account for symbols remaining in the current backoff period */
    747            rollovers++;
    748          
    749            /* set up parameters for CSP program */
    750            CSPZ = CSPZ_CODE_TX_ACK_TIME_OUT;
    751            CSPX = rollovers;
    752            CSP_WEVENT_SET_TRIGGER_SYMBOLS(symbols);
    753          
    754            /* clear the currently loaded CSP, this generates a stop interrupt which must be cleared */
    755            CSP_STOP_AND_CLEAR_PROGRAM();
    756            MAC_MCU_CSP_STOP_CLEAR_INTERRUPT();
    757          
    758            /*--------------------------
    759             * load CSP program
    760             */
    761            RFST = WAITX;
    762            RFST = WEVENT1;
    763            RFST = SSTOP;
    764          
    765            /*--------------------------
    766             */
    767          
    768            /* run CSP program */
    769            MAC_MCU_CSP_STOP_ENABLE_INTERRUPT();
    770            CSP_START_PROGRAM();
    771          
    772            /*
    773             *  For bullet proof operation, must account for the boundary condition
    774             *  where a rollover occurs after count was read but before CSP program
    775             *  was started.
    776             *
    777             *  If current symbol count is less that the symbol count recorded at the
    778             *  start of this function, a rollover has occurred.
    779             */
    780            if (CSP_WEVENT_READ_COUNT_SYMBOLS() < startSymbol)
    781            {
    782              /* a rollover has occurred, make sure it was accounted for */
    783              if (CSPX == rollovers)
    784              {
    785                /*
    786                 *  Rollover event missed, manually decrement CSPX to adjust.
    787                 *
    788                 *  Note : there is a very small chance that CSPX does not
    789                 *  get decremented.  This would occur if CSPX were written
    790                 *  at exactly the same time a timer overflow is occurring (which
    791                 *  causes the CSP instruction WAITX to decrement CSPX).  This
    792                 *  would be extremely rare, but if it does happen, the only
    793                 *  consequence is that the ACK timeout period is extended
    794                 *  by one backoff.
    795                 */
    796                CSPX--;
    797              }
    798            }
    799          }
    800          
    801          
    802          /**************************************************************************************************
    803           * @fn          macCspTxCancelAckTimeoutCallback
    804           *
    805           * @brief       Cancels previous request for ACK timeout callback.
    806           *
    807           * @param       none
    808           *
    809           * @return      none
    810           **************************************************************************************************
    811           */
    812          MAC_INTERNAL_API void macCspTxCancelAckTimeoutCallback(void)
    813          {
    814            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    815            CSP_STOP_AND_CLEAR_PROGRAM();
    816          }
    817          
    818          
    819          /**************************************************************************************************
    820           * @fn          macCspTxIntIsr
    821           *
    822           * @brief       Interrupt service routine for handling INT type interrupts from CSP.
    823           *              This interrupt happens when the CSP instruction INT is executed.  It occurs
    824           *              once the SFD signal goes high indicating that transmit has successfully
    825           *              started.  The timer value has been captured at this point and timestamp
    826           *              can be stored.
    827           *
    828           * @param       none
    829           *
    830           * @return      none
    831           **************************************************************************************************
    832           */
    833          MAC_INTERNAL_API void macCspTxIntIsr(void)
    834          {
    835            MAC_MCU_CSP_INT_DISABLE_INTERRUPT();
    836          
    837            /* execute callback function that records transmit timestamp */
    838            macTxTimestampCallback();
    839          }
    840          
    841          
    842          /**************************************************************************************************
    843           * @fn          macCspTxStopIsr
    844           *
    845           * @brief       Interrupt service routine for handling STOP type interrupts from CSP.
    846           *              This interrupt occurs when the CSP program stops by 1) reaching the end of the
    847           *              program, 2) executing SSTOP within the program, 3) executing immediate
    848           *              instruction ISSTOP.
    849           *
    850           *              The value of CSPZ indicates if interrupt is being used for ACK timeout or
    851           *              is the end of a transmit.
    852           *
    853           * @param       none
    854           *
    855           * @return      none
    856           **************************************************************************************************
    857           */
    858          MAC_INTERNAL_API void macCspTxStopIsr(void)
    859          {
    860            MAC_MCU_CSP_STOP_DISABLE_INTERRUPT();
    861          
    862            if (CSPZ == CSPZ_CODE_TX_DONE)
    863            {
    864              macTxDoneCallback();
    865            }
    866            else if (CSPZ == CSPZ_CODE_CHANNEL_BUSY)
    867            {
    868              macTxChannelBusyCallback();
    869            }
    870            else
    871            {
    872              MAC_ASSERT(CSPZ == CSPZ_CODE_TX_ACK_TIME_OUT); /* unexpected CSPZ value */
    873              macTxAckNotReceivedCallback();
    874            }
    875          }
    876          
    877          
    878          
    879          /**************************************************************************************************
    880           *                                  Compile Time Integrity Checks
    881           **************************************************************************************************
    882           */
    883          
    884          #if ((CSPZ_CODE_TX_DONE != 0) || (CSPZ_CODE_CHANNEL_BUSY != 1))
    885          #error "ERROR!  The CSPZ return values are very specific and tied into the actual CSP program."
    886          #endif
    887          
    888          #if (MAC_TX_TYPE_SLOTTED_CSMA != 0)
    889          #error "WARNING!  This define value changed.  It was selected for optimum performance."
    890          #endif
    891          
    892          #if (T2THD_TICKS_PER_SYMBOL == 0)
    893          #error "ERROR!  Timer compare will not work on high byte.  Clock speed is probably too slow."
    894          #endif
    895          
    896          #define BACKOFFS_PER_BASE_SUPERFRAME  (MAC_A_BASE_SLOT_DURATION * MAC_A_NUM_SUPERFRAME_SLOTS)
    897          #if (((BACKOFFS_PER_BASE_SUPERFRAME - 1) & SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK) != SLOTTED_TX_BACKOFF_COUNT_ALIGN_BIT_MASK)
    898          #error "ERROR!  The specified bit mask for backoff alignment of slotted transmit does not rollover 'cleanly'."
    899          /*
    900           *  In other words, the backoff count for the number of superframe rolls over before the
    901           *  specified number of bits rollover.  For example, if backoff count for a superframe
    902           *  rolls over at 48, the binary number immediately before a rollover is 00101111.
    903           *  In this case four bits would work as an alignment mask.  Five would not work though as
    904           *  the lower five bits would go from 01111 to 00000 (instead of the value 10000 which
    905           *  would be expected) because it a new superframe is starting.
    906           */
    907          #endif
    908          #if (SLOTTED_TX_MAX_BACKOFF_COUNTDOWN_NUM_BITS < 2)
    909          #error "ERROR!  Not enough backoff countdown bits to be practical."
    910          #endif
    911          
    912          
    913          /**************************************************************************************************
    914          */

Errors: 26
Warnings: 2
